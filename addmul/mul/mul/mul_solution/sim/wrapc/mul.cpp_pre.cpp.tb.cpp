// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2021.2 (64-bit)
// Copyright 1986-2021 Xilinx, Inc. All Rights Reserved.
// ==============================================================
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.cpp"
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/custom_float_def.h" 1
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h" 1
# 43 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
# 1 "../../../ac_types/include/ac_fixed.h" 1
# 46 "../../../ac_types/include/ac_fixed.h"
# 1 "../../../ac_types/include/ac_int.h" 1
# 140 "../../../ac_types/include/ac_int.h"
# 1 "/usr/include/assert.h" 1 3 4
# 35 "/usr/include/assert.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 36 "/usr/include/assert.h" 2 3 4
# 66 "/usr/include/assert.h" 3 4

# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 141 "../../../ac_types/include/ac_int.h" 2

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 1 3
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
       
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 196 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 218 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 495 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 496 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 499 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 2 3
# 158 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 314 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1592 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 143 "../../../ac_types/include/ac_int.h" 2







# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/math.h" 1 3
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/math.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cpp_type_traits.h" 1 3
# 35 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cpp_type_traits.h" 3
       
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cpp_type_traits.h" 3
# 67 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/type_traits.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/type_traits.h" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {


# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 44 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw (); extern double __nan (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();




extern int totalorder (const double *__x, const double *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) throw ()

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw (); extern float __nanf (const char *__tagb) throw ();
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();




extern int totalorderf (const float *__x, const float *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) throw ()

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw (); extern long double __nanl (const char *__tagb) throw ();
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();




extern int totalorderl (const long double *__x, const long double *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) throw ()

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw (); extern _Float32 __nanf32 (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw (); extern _Float64 __nanf64 (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw (); extern _Float128 __nanf128 (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw (); extern _Float32x __nanf32x (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) throw ()

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw (); extern _Float64x __nanf64x (const char *__tagb) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) throw ()

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 503 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) throw ();


extern float fdiv (double __x, double __y) throw ();


extern float fmul (double __x, double __y) throw ();


extern float fsub (double __x, double __y) throw ();
# 504 "/usr/include/math.h" 2 3 4
# 517 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) throw ();


extern float fdivl (long double __x, long double __y) throw ();


extern float fmull (long double __x, long double __y) throw ();


extern float fsubl (long double __x, long double __y) throw ();
# 518 "/usr/include/math.h" 2 3 4
# 537 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) throw ();


extern double ddivl (long double __x, long double __y) throw ();


extern double dmull (long double __x, long double __y) throw ();


extern double dsubl (long double __x, long double __y) throw ();
# 538 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) throw ();
# 617 "/usr/include/math.h" 2 3 4
# 626 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) throw ();
# 627 "/usr/include/math.h" 2 3 4
# 636 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) throw ();
# 637 "/usr/include/math.h" 2 3 4
# 646 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) throw ();
# 647 "/usr/include/math.h" 2 3 4
# 666 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) throw ();
# 667 "/usr/include/math.h" 2 3 4
# 676 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) throw ();
# 677 "/usr/include/math.h" 2 3 4
# 686 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) throw ();
# 687 "/usr/include/math.h" 2 3 4
# 706 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) throw ();
# 707 "/usr/include/math.h" 2 3 4
# 716 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) throw ();
# 717 "/usr/include/math.h" 2 3 4
# 736 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) throw ();
# 737 "/usr/include/math.h" 2 3 4
# 773 "/usr/include/math.h" 3 4
extern int signgam;
# 853 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 973 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 974 "/usr/include/math.h" 2 3 4
# 985 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1016 "/usr/include/math.h" 3 4
extern "C++" {
# 1047 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1245 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 1246 "/usr/include/math.h" 2 3 4
# 1278 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};




template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 2 3
# 77 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 435 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 559 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 956 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3

}
# 1072 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 1797 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cmath" 3
}
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 151 "../../../ac_types/include/ac_int.h" 2
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 1 3
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 3
       
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stringfwd.h" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stringfwd.h" 3
       
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stringfwd.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/memoryfwd.h" 1 3
# 46 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/memoryfwd.h" 3
       
# 47 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 3
       
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 1 3
# 60 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functexcept.h" 1 3
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functexcept.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_defines.h" 1 3
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/numeric_traits.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/numeric_traits.h" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 1 3
# 59 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 1 3
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/concept_check.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/concept_check.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/concept_check.h" 3
# 35 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 182 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 314 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 342 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 926 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };
# 1774 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1863 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1893 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };





  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;
# 2540 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;


  template<template<typename...> class _Default,
    template<typename...> class _Op, typename... _Args>
    using __detected_or_t_ =
      __detected_or_t<_Default<_Args...>, _Op, _Args...>;
# 2590 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename _Tp>
    inline
    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };


}
# 58 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 159 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 174 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, const _U1&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, const _U2&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<const _U1&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<const _U2&, _T2>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _MoveConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, _U1&&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, _U2&&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyMoveConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<_U1&&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<_U2&&, _T2>>>::value;
  }
# 146 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }







      template<typename _U1 = _T1, typename _U2=_T2, typename
                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 210 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3
      template<typename _U1, typename _U2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
         _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _U1, _T2>()),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                           _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _T1, _U2>()),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
           _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__is_nothrow_swappable<_T1>::value
               && __is_nothrow_swappable<_T2>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 422 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 441 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_pair.h" 3

}
# 65 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 230 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/debug/assertions.h" 1 3
# 66 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 133 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 192 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 1 3
# 66 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ptr_traits.h" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = typename _Tp::template rebind<_Up>;

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind
   = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
      static_assert(!is_same<rebind<element_type>, __undefined>::value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 160 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 290 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }




  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 441 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 476 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 533 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 567 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 609 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 628 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 679 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 723 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 747 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 847 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 999 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/debug/debug.h" 1 3
# 48 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/predefined_ops.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
# 72 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 1 3
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
       
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 216 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdarg.h" 1 3 4
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 50 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();







extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__leaf__)) btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw () __asm__ ("" "__isoc99_swscanf")


                                                          ;
# 671 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;






extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vswscanf")


                                                          ;
# 726 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 781 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 807 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 817 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 856 "/usr/include/wchar.h" 3 4
}
# 45 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 2 3
# 62 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 2 3
# 68 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdint" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdint" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdint" 3
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdint" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdint.h" 1 3 4
# 9 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdint.h" 2 3 4
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 421 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/allocator.h" 1 3
# 46 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/allocator.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/new_allocator.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/new_allocator.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/new" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/new" 3
       
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/new" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3

#pragma GCC visibility push(default)


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 129 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 138 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3
}

namespace __gnu_cxx
{

# 160 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_ptr.h" 1 3
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 113 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 140 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 171 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/nested_exception.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 46 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp =
            dynamic_cast<const nested_exception*>(std::__addressof(__t)))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop
# 172 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/exception" 2 3
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 116 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));



inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/allocator.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      typedef true_type is_always_equal;

    };
# 96 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 3
       
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/clocale" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/clocale" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/clocale" 2 3
# 51 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/iosfwd" 1 3
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/iosfwd" 3
       
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cctype" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cctype" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cctype" 2 3
# 62 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ostream_insert.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ostream_insert.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ostream_insert.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cxxabi_forced.h" 1 3
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cxxabi_forced.h" 3
       
# 35 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3



# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 1 3
# 63 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/backward/binders.h" 1 3
# 60 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/stl_function.h" 2 3
# 49 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/range_access.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/range_access.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/range_access.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/initializer_list" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/initializer_list" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/range_access.h" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 319 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/range_access.h" 3

}
# 52 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 1 3
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
       
# 38 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 3


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int getcpu (unsigned int *, unsigned int *) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 100 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 120 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 155 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 193 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 238 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 470 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 482 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 516 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 718 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 789 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 997 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1010 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));





extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1056 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1123 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1157 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/alloc_traits.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/alloc_traits.h" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/alloc_traits.h" 3



# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 1 3
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Alloc, typename _Up>
      using __rebind = typename _Alloc::template rebind<_Up>::other;

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __diff_type = typename _Tp::difference_type;
    template<typename _Tp>
      using __size_type = typename _Tp::size_type;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,
         __allocator_traits_base::__rebind,
         _Alloc, _Up>;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;







      using const_pointer
 = __detected_or_t<__ptr_rebind<pointer, const value_type>,
     __c_pointer, _Alloc>;







      using void_pointer
 = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;







      using const_void_pointer
 = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,
     _Alloc>;







      using difference_type
 = __detected_or_t<typename pointer_traits<pointer>::difference_type,
     __diff_type, _Alloc>;







      using size_type
 = __detected_or_t<typename make_unsigned<difference_type>::type,
     __size_type, _Alloc>;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,
   "allocator defines rebind or is like Alloc<T, Args>");

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 279 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 294 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 306 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 321 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 334 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 346 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 357 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 414 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 428 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 440 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 452 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 464 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/alloc_traits.h" 3
  };


}
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 71 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 258 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 410 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 426 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 444 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 476 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 544 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {

  _M_destroy(_M_allocated_capacity);
  _M_data(_M_local_data());
  _M_set_length(0);
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 599 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 617 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 813 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 826 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 875 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 904 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 921 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 942 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 963 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1026 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1084 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1126 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1150 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1194 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1217 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1233 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1249 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1266 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1279 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1315 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1357 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1393 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1413 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1436 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1459 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1478 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1502 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1520 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1544 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
# 1560 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1579 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1620 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1642 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1667 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1692 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1716 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1734 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1754 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 1776 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1797 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 1822 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 1854 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1913 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 1956 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1966 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 1976 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2009 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 2022 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2037 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2054 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2067 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2084 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 2097 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2114 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2128 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2145 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2158 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2177 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2192 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2209 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2222 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2241 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2255 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2272 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2286 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2303 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2318 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2335 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2349 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2366 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2382 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2401 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2433 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2459 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2477 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2501 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2528 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
# 4927 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 5048 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 5095 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 5133 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 5171 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 5209 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 5247 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 5285 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 5305 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 5323 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 5346 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 5363 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 1 3
# 32 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 3
       
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 3
# 41 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
# 75 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 103 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 134 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 610 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4
}
# 76 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 2 3
# 118 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 201 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3

}
# 215 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 247 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cwchar" 3
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/lib/gcc/x86_64-pc-linux-gnu/6.2.0/include/stdarg.h" 1 3 4
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) throw ();







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) throw () __asm__ ("" "__isoc99_sscanf")

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4
# 873 "/usr/include/stdio.h" 3 4
}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 2 3
# 96 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cerrno" 1 3
# 39 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cerrno" 3
       
# 40 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/cerrno" 2 3
# 45 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 5403 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 3

# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/hash_bytes.h" 1 3
# 33 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/hash_bytes.h" 3
       
# 34 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 108 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 171 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 5629 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}
# 53 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 1 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.tcc" 1 3
# 42 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.tcc" 3
       
# 43 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1145 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/opt/Xilinx/Vitis_HLS/2021.2/tps/lnx64/gcc-6.2.0/include/c++/6.2.0/string" 2 3
# 152 "../../../ac_types/include/ac_int.h" 2
# 161 "../../../ac_types/include/ac_int.h"

# 161 "../../../ac_types/include/ac_int.h"
enum loop_limit
{
   exclude,
   include
};
# 260 "../../../ac_types/include/ac_int.h"
typedef unsigned long long Ulong;
typedef signed long long Slong;


   enum ac_base_mode
   {
      AC_BIN = 2,
      AC_OCT = 8,
      AC_DEC = 10,
      AC_HEX = 16
   };
   enum ac_special_val
   {
      AC_VAL_DC,
      AC_VAL_0,
      AC_VAL_MIN,
      AC_VAL_MAX,
      AC_VAL_QUANTUM
   };

   template <int W, bool S>
   class ac_int;

   namespace ac_private
   {
      enum
      {
         long_w = std::numeric_limits<unsigned long>::digits
      };
      const unsigned int all_ones = (unsigned)~0;



      template <typename T, typename std::enable_if<std::is_floating_point<T>::value, bool>::type* = nullptr>
      constexpr T float_floor(T v) noexcept
      {
         constexpr int max_bits = std::numeric_limits<T>::max_exponent == 128 ? 23 : 52;
         if(v != v || v >= T(1LL << max_bits) || v <= -T(1LL << max_bits))
         {
            return v;
         }
         else if(T(-1) < v && v < T(1))
         {
            return T(0);
         }
         const T rnd = T(static_cast<long long int>(v));
         return rnd - T(rnd != v && v < T(0));
      }

      __attribute__((always_inline)) inline constexpr double mgc_floor(double d)
      {
         return float_floor(d);
      }
      __attribute__((always_inline)) inline constexpr float mgc_floor(float d)
      {
         return float_floor(d);
      }
# 341 "../../../ac_types/include/ac_int.h"
      template <unsigned char N>
      struct s_N
      {
         template <unsigned X>
         struct s_X
         {
            enum
            {
               X2 = X >> N,
               N_div_2 = N >> 1,
               nbits = X ? (X2 ? N + (int)s_N<N_div_2>::template s_X<X2>::nbits :
                                 (int)s_N<N_div_2>::template s_X<X>::nbits) :
                           0
            };
         };
      };
      template <>
      struct s_N<0>
      {
         template <unsigned X>
         struct s_X
         {
            enum
            {
               nbits = !!X
            };
         };
      };

      template <int N>
      __attribute__((always_inline)) inline constexpr double ldexpr32(double d)
      {
         double d2 = d;
         if(N < 0)
         {
            if(0 <= -N) { for(int i = 0; i < -N + (exclude == loop_limit::include); ++i) {
# 376 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 376 "../../../ac_types/include/ac_int.h"
            { d2 /= (Ulong)1 << 32; } } } else { for(int i = 0; i >= -N + (exclude == loop_limit::exclude); --i) {
# 376 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 376 "../../../ac_types/include/ac_int.h"
            { d2 /= (Ulong)1 << 32; } } };
         }
         else
         {
            if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {
# 380 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 380 "../../../ac_types/include/ac_int.h"
            { d2 *= (Ulong)1 << 32; } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {
# 380 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 380 "../../../ac_types/include/ac_int.h"
            { d2 *= (Ulong)1 << 32; } } };
         }
         return d2;
      }
      template <>
      __attribute__((always_inline)) inline constexpr double ldexpr32<0>(double d)
      {
         return d;
      }
      template <>
      __attribute__((always_inline)) inline constexpr double ldexpr32<1>(double d)
      {
         return d * ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr double ldexpr32<-1>(double d)
      {
         return d / ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr double ldexpr32<2>(double d)
      {
         return (d * ((Ulong)1 << 32)) * ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr double ldexpr32<-2>(double d)
      {
         return (d / ((Ulong)1 << 32)) / ((Ulong)1 << 32);
      }

      template <int N>
      __attribute__((always_inline)) inline constexpr double ldexpr(double d)
      {
         return ldexpr32<N / 32>(N < 0 ? d / ((unsigned)1 << (-N & 31)) : d * ((unsigned)1 << (N & 31)));
      }

      template <int N>
      __attribute__((always_inline)) inline constexpr float ldexpr32(float d)
      {
         float d2 = d;
         if(N < 0)
         {
            if(0 <= -N) { for(int i = 0; i < -N + (exclude == loop_limit::include); ++i) {
# 422 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 422 "../../../ac_types/include/ac_int.h"
            { d2 /= (Ulong)1 << 32; } } } else { for(int i = 0; i >= -N + (exclude == loop_limit::exclude); --i) {
# 422 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 422 "../../../ac_types/include/ac_int.h"
            { d2 /= (Ulong)1 << 32; } } };
         }
         else
         {
            if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {
# 426 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 426 "../../../ac_types/include/ac_int.h"
            { d2 *= (Ulong)1 << 32; } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {
# 426 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 426 "../../../ac_types/include/ac_int.h"
            { d2 *= (Ulong)1 << 32; } } };
         }
         return d2;
      }
      template <>
      __attribute__((always_inline)) inline constexpr float ldexpr32<0>(float d)
      {
         return d;
      }
      template <>
      __attribute__((always_inline)) inline constexpr float ldexpr32<1>(float d)
      {
         return d * ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr float ldexpr32<-1>(float d)
      {
         return d / ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr float ldexpr32<2>(float d)
      {
         return (d * ((Ulong)1 << 32)) * ((Ulong)1 << 32);
      }
      template <>
      __attribute__((always_inline)) inline constexpr float ldexpr32<-2>(float d)
      {
         return (d / ((Ulong)1 << 32)) / ((Ulong)1 << 32);
      }

      template <int N>
      __attribute__((always_inline)) inline constexpr float ldexpr(float d)
      {
         return ldexpr32<N / 32>(N < 0 ? d / ((unsigned)1 << (-N & 31)) : d * ((unsigned)1 << (N & 31)));
      }

      template <int N, bool C>
      class iv_base
      {






         int v[N] ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
            constexpr const unsigned rem = (32 - W) & 31;
            set(N - 1,
                S ? (((int)(((unsigned)v[N - 1]) << rem)) >> rem) : (rem ? ((unsigned)v[N - 1] << rem) >> rem : 0));
         }

         __attribute__((always_inline)) inline void assign_int64(Slong l)
         {
            set(0, static_cast<int>(l));
            if(N > 1)
            {
               set(1, static_cast<int>(l >> 32));
               if(2 <= N) { for(int i = 2; i < N + (exclude == loop_limit::include); ++i) {
# 488 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 488 "../../../ac_types/include/ac_int.h"
               { set(i, (v[1] < 0) ? ~0 : 0); } } } else { for(int i = 2; i >= N + (exclude == loop_limit::exclude); --i) {
# 488 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 488 "../../../ac_types/include/ac_int.h"
               { set(i, (v[1] < 0) ? ~0 : 0); } } };
            }
         }

         __attribute__((always_inline)) inline constexpr void assign_uint64(Ulong l)
         {
            set(0, static_cast<int>(l));
            if(N > 1)
            {
               set(1, static_cast<int>(l >> 32));
               if(2 <= N) { for(int i = 2; i < N + (exclude == loop_limit::include); ++i) {
# 498 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 498 "../../../ac_types/include/ac_int.h"
               { set(i, 0); } } } else { for(int i = 2; i >= N + (exclude == loop_limit::exclude); --i) {
# 498 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 498 "../../../ac_types/include/ac_int.h"
               { set(i, 0); } } };
            }
         }
         __attribute__((always_inline)) inline constexpr void set(int x, int value)
         {
            v[x] = value;
         }

         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return N == 1 ? v[0] : ((Ulong)v[1] << 32) | (Ulong)(unsigned)v[0];
         }

         __attribute__((always_inline)) inline constexpr int operator[](int x) const
         {
            return v[x];
         }

         iv_base() = default;
         template <int N2, bool C2>
         __attribute__((always_inline)) inline constexpr iv_base(const iv_base<N2, C2>& b)
         {
            constexpr int M = ((N) < (N2) ? (N) : (N2));
            if(0 <= M) { for(int idx = 0; idx < M + (exclude == loop_limit::include); ++idx) {
# 521 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 521 "../../../ac_types/include/ac_int.h"
            { set(idx, b[idx]); } } } else { for(int idx = 0; idx >= M + (exclude == loop_limit::exclude); --idx) {
# 521 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 521 "../../../ac_types/include/ac_int.h"
            { set(idx, b[idx]); } } };
            auto last = v[M - 1] < 0 ? ~0 : 0;
            if(M <= N) { for(int idx = M; idx < N + (exclude == loop_limit::include); ++idx) {
# 523 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 523 "../../../ac_types/include/ac_int.h"
            { set(idx, last); } } } else { for(int idx = M; idx >= N + (exclude == loop_limit::exclude); --idx) {
# 523 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 523 "../../../ac_types/include/ac_int.h"
            { set(idx, last); } } };
         }
      } __attribute__((aligned(8)));

      template <int N>
      class iv_base<N, true>
      {






         int v[N - 1] ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
         }

         __attribute__((always_inline)) inline void assign_int64(Slong l)
         {
            set(0, static_cast<int>(l));
            if(N > 2)
            {
               set(1, static_cast<int>(l >> 32));
               if(2 <= N) { for(int i = 2; i < N + (exclude == loop_limit::include); ++i) {
# 550 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 550 "../../../ac_types/include/ac_int.h"
               { set(i, (v[1] < 0) ? ~0 : 0); } } } else { for(int i = 2; i >= N + (exclude == loop_limit::exclude); --i) {
# 550 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 550 "../../../ac_types/include/ac_int.h"
               { set(i, (v[1] < 0) ? ~0 : 0); } } };
            }
         }

         __attribute__((always_inline)) inline constexpr void assign_uint64(Ulong l)
         {
            set(0, static_cast<int>(l));
            if(N > 2)
            {
               set(1, static_cast<int>(l >> 32));
               if(2 <= N - 1) { for(int i = 2; i < N - 1 + (exclude == loop_limit::include); ++i) {
# 560 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 560 "../../../ac_types/include/ac_int.h"
               { set(i, 0); } } } else { for(int i = 2; i >= N - 1 + (exclude == loop_limit::exclude); --i) {
# 560 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 560 "../../../ac_types/include/ac_int.h"
               { set(i, 0); } } };
            }
         }

         __attribute__((always_inline)) inline constexpr void set(int x, int value)
         {
            if(x != N - 1)
               v[x] = value;


         }

         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return N <= 2 ? v[0] : ((Ulong)v[1] << 32) | (Ulong)(unsigned)v[0];
         }

         __attribute__((always_inline)) inline constexpr int operator[](int x) const
         {
            if(x != N - 1)
               return v[x];
            else
               return 0;
         }

         __attribute__((always_inline)) inline constexpr iv_base()
         {
         }

         template <int N2, bool C2>
         __attribute__((always_inline)) inline constexpr iv_base(const iv_base<N2, C2>& b)
         {
            constexpr int M = ((N - 1) < (N2) ? (N - 1) : (N2));
            if(0 <= M) { for(int idx = 0; idx < M + (exclude == loop_limit::include); ++idx) {
# 593 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 593 "../../../ac_types/include/ac_int.h"
            { set(idx, b[idx]); } } } else { for(int idx = 0; idx >= M + (exclude == loop_limit::exclude); --idx) {
# 593 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 593 "../../../ac_types/include/ac_int.h"
            { set(idx, b[idx]); } } };
            auto last = v[M - 1] < 0 ? ~0 : 0;
            if(M <= N - 1) { for(int idx = M; idx < N - 1 + (exclude == loop_limit::include); ++idx) {
# 595 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 595 "../../../ac_types/include/ac_int.h"
            { set(idx, last); } } } else { for(int idx = M; idx >= N - 1 + (exclude == loop_limit::exclude); --idx) {
# 595 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 595 "../../../ac_types/include/ac_int.h"
            { set(idx, last); } } };
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<1, false>
      {
         int v ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
            constexpr const unsigned rem = (32 - W) & 31;
            v = S ? (((int)(((unsigned)v) << rem)) >> rem) : (rem ? ((unsigned)v << rem) >> rem : 0);
         }
         void assign_int64(Slong l)
         {
            v = static_cast<int>(l);
         }
         void constexpr assign_uint64(Ulong l)
         {
            v = static_cast<int>(l);
         }
         constexpr void set(int, int value)
         {
            v = value;
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return v;
         }
         constexpr int operator[](int) const
         {
            return v;
         }
         iv_base() = default;
         template <int N2, bool C2>
         constexpr iv_base(const iv_base<N2, C2>& b) : v(b[0])
         {
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<1, true>
      {

      };

      template <>
      class iv_base<2, false>
      {
         long long int v ;

       public:
         template <int W, bool S>
         constexpr void bit_adjust()
         {
            constexpr const unsigned rem = (64 - W) & 63;
            v = S ? (((long long int)(((unsigned long long)v) << rem)) >> rem) :
                    (rem ? ((unsigned long long)v << rem) >> rem : 0);
         }
         void assign_int64(Slong l)
         {
            v = l;
         }
         void constexpr assign_uint64(Ulong l)
         {
            v = static_cast<Slong>(l);
         }
         constexpr void set(int x, int value)
         {
            if(x)
               v = (all_ones & v) | (((Slong)value) << 32);
            else
               v = ((((Ulong)all_ones) << 32) & v) | ((Ulong)((unsigned)value));
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return v;
         }
         constexpr int operator[](int x) const
         {
            return x ? (int)(v >> 32) : (int)v;
         }
         iv_base() = default;
         template <int N2, bool C2>
         constexpr iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 2)
            {
               v = b.to_int64();
            }
            else
            {
               ;
               v = b[0];
            }
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<2, true>
      {
         int v ;

       public:
         template <int W, bool S>
         constexpr void bit_adjust()
         {
         }
         void assign_int64(Slong l)
         {
            v = l;
         }
         void constexpr assign_uint64(Ulong l)
         {
            v = static_cast<Slong>(l);
         }
         constexpr void set(int x, int value)
         {
            if(!x)
               v = value;
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return v;
         }
         constexpr int operator[](int x) const
         {
            return x ? 0 : v;
         }
         iv_base() = default;
         template <int N2, bool C2>
         constexpr iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 2)
            {
               v = b.to_int64();
            }
            else
            {
               ;
               v = b[0];
            }
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<3, false>
      {
         long long int va ;
         long long int v2 ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
            constexpr const unsigned rem = (64 - W) & 63;
            v2 = S ? (((long long int)(((unsigned long long)v2) << rem)) >> rem) :
                     (rem ? ((unsigned long long)v2 << rem) >> rem : 0);
         }
         void assign_int64(Slong l)
         {
            va = l;
            v2 = va < 0 ? ~0LL : 0;
         }
         void constexpr assign_uint64(Ulong l)
         {
            va = static_cast<Slong>(l);
            v2 = 0;
         }
         constexpr void set(int x, int value)
         {
            x = x & 3;
            if(x == 0)
               va = ((((Ulong)all_ones) << 32) & va) | ((Ulong)((unsigned)value));
            else if(x == 1)
               va = (all_ones & va) | (((Slong)value) << 32);
            else
               v2 = value;
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return va;
         }
         constexpr int operator[](int x) const
         {
            x = x & 3;
            return x == 0 ? (int)va : (x == 1 ? (int)(va >> 32) : v2);
         }
         iv_base() = default;
         template <int N2, bool C2>
         constexpr iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 3)
            {
               va = b.to_int64();
               v2 = b[2];
            }
            else if(M == 2)
            {
               va = b.to_int64();
               v2 = va < 0 ? ~0 : 0;
            }
            else
            {
               ;
               va = b.to_int64();
               v2 = va < 0 ? ~0LL : 0;
            }
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<3, true>
      {
         long long int va ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
         }
         void assign_int64(Slong l)
         {
            va = l;
         }
         void constexpr assign_uint64(Ulong l)
         {
            va = static_cast<Slong>(l);
         }
         constexpr void set(int x, int value)
         {
            x = x & 3;
            if(x == 0)
               va = ((((Ulong)all_ones) << 32) & va) | ((Ulong)((unsigned)value));
            else if(x == 1)
               va = (all_ones & va) | (((Slong)value) << 32);
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return va;
         }
         constexpr int operator[](int x) const
         {
            x = x & 3;
            return x == 0 ? (int)va : (x == 1 ? (int)(va >> 32) : 0);
         }
         iv_base() = default;
         template <int N2, bool C2>
         iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 3)
            {
               va = b.to_int64();
            }
            else if(M == 2)
            {
               va = b.to_int64();
            }
            else
            {
               ;
               va = b.to_int64();
            }
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<4, false>
      {
         long long int va ;
         long long int vb ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
            constexpr const unsigned rem = (64 - W) & 63;
            vb = S ? (((long long int)(((unsigned long long)vb) << rem)) >> rem) :
                     (rem ? ((unsigned long long)vb << rem) >> rem : 0);
         }
         void assign_int64(Slong l)
         {
            va = l;
            vb = va < 0 ? ~0LL : 0;
         }
         void constexpr assign_uint64(Ulong l)
         {
            va = static_cast<Slong>(l);
            vb = 0;
         }
         void set(int x, int value)
         {
            x = x & 3;
            if(x == 0)
               va = ((((Ulong)all_ones) << 32) & va) | ((Ulong)((unsigned)value));
            else if(x == 1)
               va = (all_ones & va) | (((Slong)value) << 32);
            else if(x == 2)
               vb = ((((Ulong)all_ones) << 32) & vb) | ((Ulong)((unsigned)value));
            else
               vb = (all_ones & vb) | (((Slong)value) << 32);
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return va;
         }
         constexpr int operator[](int x) const
         {
            x = x & 3;
            return x == 0 ? (int)va : (x == 1 ? (int)(va >> 32) : (x == 2 ? (int)vb : (int)(vb >> 32)));
         }

         iv_base() = default;
         template <int N2, bool C2>
         constexpr iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 4)
            {
               va = b.to_int64();
               vb = (((Slong)b[3]) << 32) | ((Ulong)((unsigned)b[2]));
            }
            else if(M == 3)
            {
               va = b.to_int64();
               vb = b[2];
            }
            else if(M == 2)
            {
               va = b.to_int64();
               vb = va < 0 ? ~0 : 0;
            }
            else
            {
               ;
               va = b.to_int64();
               vb = va < 0 ? ~0LL : 0;
            }
         }
      } __attribute__((aligned(8)));

      template <>
      class iv_base<4, true> : public iv_base<4, false>
      {
      };

      template <>
      class iv_base<5, true>
      {
         long long int va ;
         long long int vb ;

       public:
         template <int W, bool S>
         __attribute__((always_inline)) inline constexpr void bit_adjust()
         {
         }
         void assign_int64(Slong l)
         {
            va = l;
            vb = va < 0 ? ~0LL : 0;
         }
         void constexpr assign_uint64(Ulong l)
         {
            va = static_cast<Slong>(l);
            vb = 0;
         }
         void set(int x, int value)
         {
            x = x & 7;
            if(x == 0)
               va = ((((Ulong)all_ones) << 32) & va) | ((Ulong)((unsigned)value));
            else if(x == 1)
               va = (all_ones & va) | (((Slong)value) << 32);
            else if(x == 2)
               vb = ((((Ulong)all_ones) << 32) & vb) | ((Ulong)((unsigned)value));
            else if(x == 3)
               vb = (all_ones & vb) | (((Slong)value) << 32);
         }
         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return va;
         }
         constexpr int operator[](int x) const
         {
            x = x & 3;
            return x == 0 ? (int)va : (x == 1 ? (int)(va >> 32) : (x == 2 ? (int)vb : (x == 2 ? (int)(vb >> 32) : 0)));
         }
         iv_base() = default;
         template <int N2, bool C2>
         iv_base(const iv_base<N2, C2>& b)
         {
            const int M = ((2) < (N2) ? (2) : (N2));
            if(M == 4 || M == 5)
            {
               va = b.to_int64();
               vb = (((Slong)b[3]) << 32) | ((Ulong)((unsigned)b[2]));
            }
            else if(M == 3)
            {
               va = b.to_int64();
               vb = b[2];
            }
            else if(M == 2)
            {
               va = b.to_int64();
               vb = va < 0 ? ~0 : 0;
            }
            else
            {
               ;
               va = b.to_int64();
               vb = va < 0 ? ~0LL : 0;
            }
         }
      } __attribute__((aligned(8)));

      template <int N, int START, int N1, bool C1, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_copy(const iv_base<N1, C1>& op, iv_base<Nr, Cr>& r)
      {
         if(START < N)
         {
            if(START <= N) { for(int i = START; i < N + (exclude == loop_limit::include); ++i) {
# 1024 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1024 "../../../ac_types/include/ac_int.h"
            { r.set(i, op[i]); } } } else { for(int i = START; i >= N + (exclude == loop_limit::exclude); --i) {
# 1024 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1024 "../../../ac_types/include/ac_int.h"
            { r.set(i, op[i]); } } };
         }
      }

      template <int START, int N, int N1, bool C1>
      __attribute__((always_inline)) inline bool iv_equal_zero(const iv_base<N1, C1>& op)
      {
         bool retval = true;
         if(START < N)
         {
            if(START <= N) { for(int i = START; i < N + (exclude == loop_limit::include); ++i) {
# 1034 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1034 "../../../ac_types/include/ac_int.h"
            { retval &= !op[i]; } } } else { for(int i = START; i >= N + (exclude == loop_limit::exclude); --i) {
# 1034 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1034 "../../../ac_types/include/ac_int.h"
            { retval &= !op[i]; } } };
         }
         return retval;
      }

      template <int START, int N, int N1, bool C1>
      __attribute__((always_inline)) inline bool iv_equal_ones(const iv_base<N1, C1>& op)
      {
         bool retval = true;
         if(START < N)
         {
            if(START <= N) { for(int i = START; i < N + (exclude == loop_limit::include); ++i) {
# 1045 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1045 "../../../ac_types/include/ac_int.h"
            { retval &= !(~op[i]); } } } else { for(int i = START; i >= N + (exclude == loop_limit::exclude); --i) {
# 1045 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1045 "../../../ac_types/include/ac_int.h"
            { retval &= !(~op[i]); } } };
         }
         return retval;
      }

      template <int N1, bool C1, int N2, bool C2>
      __attribute__((always_inline)) inline bool iv_equal(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2)
      {
         const int M1 = ((N1) > (N2) ? (N1) : (N2));
         const int M2 = ((N1) < (N2) ? (N1) : (N2));
         const bool M1C1 = N1 >= N2 ? C1 : C2;
         const bool M2C1 = N1 >= N2 ? C2 : C1;
         const iv_base<M1, M1C1>& OP1 =
             N1 >= N2 ? static_cast<iv_base<M1, M1C1>>(op1) : static_cast<iv_base<M1, M1C1>>(op2);
         const iv_base<M2, M2C1>& OP2 =
             N1 >= N2 ? static_cast<iv_base<M2, M2C1>>(op2) : static_cast<iv_base<M2, M2C1>>(op1);

         bool retval = true;
         if(0 <= M2) { for(int i = 0; i < M2 + (exclude == loop_limit::include); ++i) {
# 1063 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1063 "../../../ac_types/include/ac_int.h"
         { retval &= OP1[i] == OP2[i]; } } } else { for(int i = 0; i >= M2 + (exclude == loop_limit::exclude); --i) {
# 1063 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1063 "../../../ac_types/include/ac_int.h"
         { retval &= OP1[i] == OP2[i]; } } };
         if(!retval)
         {
            return retval;
         }
         int ext = OP2[M2 - 1] < 0 ? ~0 : 0;
         retval = true;
         if(M2 <= M1) { for(int i = M2; i < M1 + (exclude == loop_limit::include); ++i) {
# 1070 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1070 "../../../ac_types/include/ac_int.h"
         { retval &= OP1[i] == ext; } } } else { for(int i = M2; i >= M1 + (exclude == loop_limit::exclude); --i) {
# 1070 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1070 "../../../ac_types/include/ac_int.h"
         { retval &= OP1[i] == ext; } } };
         return retval;
      }

      template <int B, int N, bool C>
      __attribute__((always_inline)) inline bool iv_equal_ones_from(const iv_base<N, C>& op)
      {
         if((B >= 32 * N && op[N - 1] >= 0) || (B & 31 && ~(op[B / 32] >> (B & 31))))
            return false;
         return iv_equal_ones<(B + 31) / 32, N>(op);
      }

      template <int B, int N, bool C>
      __attribute__((always_inline)) inline bool iv_equal_zeros_from(const iv_base<N, C>& op)
      {
         if((B >= 32 * N && op[N - 1] < 0) || (B & 31 && (op[B / 32] >> (B & 31))))
            return false;
         return iv_equal_zero<(B + 31) / 32, N>(op);
      }

      template <int B, int N, bool C>
      __attribute__((always_inline)) inline bool iv_equal_ones_to(const iv_base<N, C>& op)
      {
         if((B >= 32 * N && op[N - 1] >= 0) || (B & 31 && ~(op[B / 32] | (all_ones << (B & 31)))))
            return false;
         return iv_equal_ones<0, B / 32>(op);
      }

      template <int B, int N, bool C>
      __attribute__((always_inline)) inline bool iv_equal_zeros_to(const iv_base<N, C>& op)
      {
         if((B >= 32 * N && op[N - 1] < 0) || (B & 31 && (op[B / 32] & ~(all_ones << (B & 31)))))
            return false;
         if(B < 32)
            return true;
         return iv_equal_zero<0, (B / 32)>(op);
      }

      template <bool greater, int N1, bool C1, int N2, bool C2>
      __attribute__((always_inline)) inline bool iv_compare(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2)
      {
         const int M1 = ((N1) > (N2) ? (N1) : (N2));
         const int M2 = ((N1) < (N2) ? (N1) : (N2));
         const bool M1C1 = N1 >= N2 ? C1 : C2;
         const iv_base<M1, M1C1>& OP1 =
             N1 >= N2 ? static_cast<iv_base<M1, M1C1>>(op1) : static_cast<iv_base<M1, M1C1>>(op2);
         const bool M2C1 = N1 >= N2 ? C2 : C1;
         const iv_base<M2, M2C1>& OP2 =
             N1 >= N2 ? static_cast<iv_base<M2, M2C1>>(op2) : static_cast<iv_base<M2, M2C1>>(op1);
         const bool b = (N1 >= N2) == greater;
         int ext = OP2[M2 - 1] < 0 ? ~0 : 0;
         int i2 = M1 > M2 ? ext : OP2[M1 - 1];
         if(OP1[M1 - 1] != i2)
            return b ^ (OP1[M1 - 1] < i2);
         bool retval = false;
         bool invalidate = false;
         if((M1 - 2) >= M2)
         {
            if(M1 - 2 <= M2) { for(int i = M1 - 2; i < M2 + (include == loop_limit::include); ++i) {
# 1137 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1128 "../../../ac_types/include/ac_int.h"
            { if(!invalidate) { if((unsigned)OP1[i] != (unsigned)ext) { retval = b ^ ((unsigned)OP1[i] < (unsigned)ext); invalidate = true; } } } } } else { for(int i = M1 - 2; i >= M2 + (include == loop_limit::exclude); --i) {
# 1137 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1128 "../../../ac_types/include/ac_int.h"
            { if(!invalidate) { if((unsigned)OP1[i] != (unsigned)ext) { retval = b ^ ((unsigned)OP1[i] < (unsigned)ext); invalidate = true; } } } } }
# 1137 "../../../ac_types/include/ac_int.h"
              ;
         }
         if(invalidate)
         {
            return retval;
         }
         if((M2 - 1) >= 0)
         {
            if(M2 - 1 <= 0) { for(int i = M2 - 1; i < 0 + (include == loop_limit::include); ++i) {
# 1154 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1145 "../../../ac_types/include/ac_int.h"
            { if(!invalidate) { if((unsigned)OP1[i] != (unsigned)OP2[i]) { retval = b ^ ((unsigned)OP1[i] < (unsigned)OP2[i]); invalidate = true; } } } } } else { for(int i = M2 - 1; i >= 0 + (include == loop_limit::exclude); --i) {
# 1154 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1145 "../../../ac_types/include/ac_int.h"
            { if(!invalidate) { if((unsigned)OP1[i] != (unsigned)OP2[i]) { retval = b ^ ((unsigned)OP1[i] < (unsigned)OP2[i]); invalidate = true; } } } } }
# 1154 "../../../ac_types/include/ac_int.h"
              ;
         }
         if(invalidate)
         {
            return retval;
         }
         return false;
      }

      template <int START, int N, bool C>
      __attribute__((always_inline)) inline constexpr void iv_extend(iv_base<N, C>& r, int ext)
      {
         if(START < N)
         {
            if(START <= N) { for(int i = START; i < N + (exclude == loop_limit::include); ++i) {
# 1168 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1168 "../../../ac_types/include/ac_int.h"
            { r.set(i, ext); } } } else { for(int i = START; i >= N + (exclude == loop_limit::exclude); --i) {
# 1168 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1168 "../../../ac_types/include/ac_int.h"
            { r.set(i, ext); } } };
         }
      }

      template <int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_assign_int64(iv_base<Nr, Cr>& r, Slong l)
      {
         r.assign_int64(l);
      }

      template <int Nr, bool Cr>
      __attribute__((always_inline)) inline constexpr void iv_assign_uint64(iv_base<Nr, Cr>& r, Ulong l)
      {
         r.assign_uint64(l);
      }

      __attribute__((always_inline)) inline Ulong mult_u_u(int a, int b)
      {
         return (Ulong)(unsigned)a * (Ulong)(unsigned)b;
      }
      __attribute__((always_inline)) inline Slong mult_u_s(int a, int b)
      {
         return (Ulong)(unsigned)a * (Slong)(signed)b;
      }
      __attribute__((always_inline)) inline Slong mult_s_u(int a, int b)
      {
         return (Slong)(signed)a * (Ulong)(unsigned)b;
      }
      __attribute__((always_inline)) inline Slong mult_s_s(int a, int b)
      {
         return (Slong)(signed)a * (Slong)(signed)b;
      }
      __attribute__((always_inline)) inline void accumulate(Ulong a, Ulong& l1, Slong& l2)
      {
         l1 += (Ulong)(unsigned)a;
         l2 += a >> 32;
      }
      __attribute__((always_inline)) inline void accumulate(Slong a, Ulong& l1, Slong& l2)
      {
         l1 += (Ulong)(unsigned)a;
         l2 += a >> 32;
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_mult(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(Nr == 1)
            r.set(0, op1[0] * op2[0]);
         else if(Nr == 2)
            iv_assign_int64(r, (op1.to_int64() * op2.to_int64()));
         else if(N1 == 1 && N2 == 1)
            iv_assign_int64(r, (op1.to_int64() * op2.to_int64()));
         else
         {
            constexpr int M1 = ((N1) > (N2) ? (N1) : (N2));
            constexpr int M2 = ((N1) < (N2) ? (N1) : (N2));
            constexpr bool M1C1 = N1 >= N2 ? C1 : C2;
            constexpr bool M2C1 = N1 >= N2 ? C2 : C1;
            constexpr int T1 = ((M2 - 1) < (Nr) ? (M2 - 1) : (Nr));
            constexpr int T2 = ((M1 - 1) < (Nr) ? (M1 - 1) : (Nr));
            constexpr int T3 = ((M1 + M2 - 2) < (Nr) ? (M1 + M2 - 2) : (Nr));
            const iv_base<M1, M1C1> OP1 =
                N1 >= N2 ? static_cast<iv_base<M1, M1C1>>(op1) : static_cast<iv_base<M1, M1C1>>(op2);
            const iv_base<M2, M2C1> OP2 =
                N1 >= N2 ? static_cast<iv_base<M2, M2C1>>(op2) : static_cast<iv_base<M2, M2C1>>(op1);

            Ulong l1 = 0;
            Slong l2 = 0;
           
# 1247 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1236 "../../../ac_types/include/ac_int.h"
           
# 1247 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1236 "../../../ac_types/include/ac_int.h"
            if(0 <= T1) { for(int k = 0; k < T1 + (exclude == loop_limit::include); ++k) {
# 1247 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1236 "../../../ac_types/include/ac_int.h"
            { if(0 <= T1) { for(int i = 0; i < T1 + (include == loop_limit::include); ++i) { { if(i < k + 1) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } } else { for(int i = 0; i >= T1 + (include == loop_limit::exclude); --i) { { if(i < k + 1) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } }; l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } } else { for(int k = 0; k >= T1 + (exclude == loop_limit::exclude); --k) {
# 1247 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1236 "../../../ac_types/include/ac_int.h"
            { if(0 <= T1) { for(int i = 0; i < T1 + (include == loop_limit::include); ++i) { { if(i < k + 1) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } } else { for(int i = 0; i >= T1 + (include == loop_limit::exclude); --i) { { if(i < k + 1) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } }; l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } }
# 1247 "../../../ac_types/include/ac_int.h"
              ;
            if(T1 < T2)
            {
              






#pragma HLS UNROLL
# 1250 "../../../ac_types/include/ac_int.h"
              






#pragma HLS UNROLL
# 1250 "../../../ac_types/include/ac_int.h"
               if(T1 <= T2) { for(int k = T1; k < T2 + (exclude == loop_limit::include); ++k) {






#pragma HLS UNROLL
# 1250 "../../../ac_types/include/ac_int.h"
               { accumulate(mult_u_s(OP1[k - M2 + 1], OP2[M2 - 1]), l1, l2); if(0 <= M2 - 1) { for(int i = 0; i < M2 - 1 + (exclude == loop_limit::include); ++i) { { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } else { for(int i = 0; i >= M2 - 1 + (exclude == loop_limit::exclude); --i) { { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } }; l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } } else { for(int k = T1; k >= T2 + (exclude == loop_limit::exclude); --k) {






#pragma HLS UNROLL
# 1250 "../../../ac_types/include/ac_int.h"
               { accumulate(mult_u_s(OP1[k - M2 + 1], OP2[M2 - 1]), l1, l2); if(0 <= M2 - 1) { for(int i = 0; i < M2 - 1 + (exclude == loop_limit::include); ++i) { { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } else { for(int i = 0; i >= M2 - 1 + (exclude == loop_limit::exclude); --i) { { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } }; l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } }






                 ;
            }
            if(T2 < T3)
            {
              
# 1274 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1261 "../../../ac_types/include/ac_int.h"
              
# 1274 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1261 "../../../ac_types/include/ac_int.h"
               if(T2 <= T3) { for(int k = T2; k < T3 + (exclude == loop_limit::include); ++k) {
# 1274 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1261 "../../../ac_types/include/ac_int.h"
               { accumulate(mult_u_s(OP1[k - M2 + 1], OP2[M2 - 1]), l1, l2); if(0 <= M2 - 1) { for(int i = 0; i < M2 - 1 + (exclude == loop_limit::include); ++i) { { if(i >= (k - T2 + 1)) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } } else { for(int i = 0; i >= M2 - 1 + (exclude == loop_limit::exclude); --i) { { if(i >= (k - T2 + 1)) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } }; accumulate(mult_s_u(OP1[M1 - 1], OP2[k - M1 + 1]), l1, l2); l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } } else { for(int k = T2; k >= T3 + (exclude == loop_limit::exclude); --k) {
# 1274 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1261 "../../../ac_types/include/ac_int.h"
               { accumulate(mult_u_s(OP1[k - M2 + 1], OP2[M2 - 1]), l1, l2); if(0 <= M2 - 1) { for(int i = 0; i < M2 - 1 + (exclude == loop_limit::include); ++i) { { if(i >= (k - T2 + 1)) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } } else { for(int i = 0; i >= M2 - 1 + (exclude == loop_limit::exclude); --i) { { if(i >= (k - T2 + 1)) { accumulate(mult_u_u(OP1[k - i], OP2[i]), l1, l2); } } } }; accumulate(mult_s_u(OP1[M1 - 1], OP2[k - M1 + 1]), l1, l2); l2 += (Ulong)(unsigned)(l1 >> 32); r.set(k, (int)l1); l1 = (unsigned)l2; l2 >>= 32; } } }
# 1274 "../../../ac_types/include/ac_int.h"
                 ;
            }
            if(Nr >= M1 + M2 - 1)
            {
               accumulate(mult_s_s(OP1[M1 - 1], OP2[M2 - 1]), l1, l2);
               r.set(M1 + M2 - 2, (int)l1);
               if(Nr >= M1 + M2)
               {
                  l2 += (Ulong)(unsigned)(l1 >> 32);
                  r.set(M1 + M2 - 1, (int)l2);
                  iv_extend<M1 + M2>(r, (r[M1 + M2 - 1] < 0) ? ~0 : 0);
               }
            }
         }
      }

      template <int N, bool C>
      __attribute__((always_inline)) inline constexpr bool iv_uadd_carry(const iv_base<N, C>& op1, bool carry, iv_base<N, C>& r)
      {
         Slong l = carry;
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1294 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1294 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } }



           ;
         return l != 0;
      }

      template <int START, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline bool iv_add_int_carry(const iv_base<N, C>& op1, int op2, bool carry, iv_base<Nr, Cr>& r)
      {
         if(N == START)
            return carry;
         if(N == START + 1)
         {
            Ulong l = carry + (Slong)op1[START] + (Slong)op2;
            r.set(START, (int)l);
            return (l >> 32) & 1;
         }
         Slong l = carry + (Ulong)(unsigned)op1[START] + (Slong)op2;
         r.set(START, (int)l);
         l >>= 32;
         if((START + 1) < (N - 1))
         {
            if(START + 1 <= N - 1) { for(int i = START + 1; i < N - 1 + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1318 "../../../ac_types/include/ac_int.h"
            { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = START + 1; i >= N - 1 + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1318 "../../../ac_types/include/ac_int.h"
            { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } }



              ;
         }
         l += (Slong)op1[N - 1];
         r.set(N - 1, (int)l);
         return (l >> 32) & 1;
      }

      template <int N, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline bool iv_uadd_n(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         ;
         Ulong l = 0;
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1334 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i] + (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1334 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i] + (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } }



           ;
         return l & 1;
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_add(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(Nr == 1)
            r.set(0, op1[0] + op2[0]);
         else
         {
            constexpr int M1 = ((N1) > (N2) ? (N1) : (N2));
            constexpr int M2 = ((N1) < (N2) ? (N1) : (N2));
            constexpr bool M1C1 = N1 >= N2 ? C1 : C2;
            constexpr bool M2C1 = N1 >= N2 ? C2 : C1;
            constexpr int T1 = ((M2 - 1) < (Nr) ? (M2 - 1) : (Nr));
            constexpr int T2 = ((M1) < (Nr) ? (M1) : (Nr));
            const iv_base<M1, M1C1> OP1 =
                N1 >= N2 ? static_cast<iv_base<M1, M1C1>>(op1) : static_cast<iv_base<M1, M1C1>>(op2);
            const iv_base<M2, M2C1> OP2 =
                N1 >= N2 ? static_cast<iv_base<M2, M2C1>>(op2) : static_cast<iv_base<M2, M2C1>>(op1);

            bool carry = iv_uadd_n<T1>(OP1, OP2, r);
            carry = iv_add_int_carry<T1>(OP1, OP2[T1], carry, r);
            iv_extend<T2>(r, carry ? ~0 : 0);
         }
      }

      template <int N, int START, int N1, bool C1, int Nr, bool Cr>
      __attribute__((always_inline)) inline bool iv_sub_int_borrow(const iv_base<N1, C1>& op1, int op2, bool borrow, iv_base<Nr, Cr>& r)
      {
         if(START == N)
            return borrow;
         if(N == (START + 1))
         {
            Ulong l = (Slong)op1[START] - (Slong)op2 - borrow;
            r.set(START, (int)l);
            return (l >> 32) & 1;
         }
         Slong l = (Ulong)(unsigned)op1[START] - (Slong)op2 - borrow;
         r.set(START, (int)l);
         l >>= 32;
         if((START + 1) < (N - 1))
         {
            if(START + 1 <= N - 1) { for(int i = START + 1; i < N - 1 + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1382 "../../../ac_types/include/ac_int.h"
            { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = START + 1; i >= N - 1 + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1382 "../../../ac_types/include/ac_int.h"
            { l += (Ulong)(unsigned)op1[i]; r.set(i, (int)l); l >>= 32; } } }



              ;
         }
         l += (Slong)op1[N - 1];
         r.set(N - 1, (int)l);
         return (l >> 32) & 1;
      }

      template <int N, int START, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline bool iv_sub_int_borrow(int op1, const iv_base<N2, C2>& op2, bool borrow, iv_base<Nr, Cr>& r)
      {
         if(START == N)
            return borrow;
         if(N == START + 1)
         {
            Ulong l = (Slong)op1 - (Slong)op2[START] - borrow;
            r.set(START, (int)l);
            return (l >> 32) & 1;
         }
         Slong l = (Slong)op1 - (Ulong)(unsigned)op2[START] - borrow;
         r.set(START, (int)l);
         l >>= 32;
         if((START + 1) < (N - 1))
         {
            if(START + 1 <= N - 1) { for(int i = START + 1; i < N - 1 + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1409 "../../../ac_types/include/ac_int.h"
            { l -= (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = START + 1; i >= N - 1 + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1409 "../../../ac_types/include/ac_int.h"
            { l -= (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } }



              ;
         }
         l -= (Slong)op2[N - 1];
         r.set(N - 1, (int)l);
         return (l >> 32) & 1;
      }

      template <int N, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline bool iv_usub_n(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         ;
         Slong l = 0;
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1425 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i] - (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1425 "../../../ac_types/include/ac_int.h"
         { l += (Ulong)(unsigned)op1[i] - (Ulong)(unsigned)op2[i]; r.set(i, (int)l); l >>= 32; } } }



           ;
         return l & 1;
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_sub(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(Nr == 1)
            r.set(0, op1[0] - op2[0]);
         else
         {
            const int M1 = ((N1) > (N2) ? (N1) : (N2));
            const int M2 = ((N1) < (N2) ? (N1) : (N2));
            const int T1 = ((M2 - 1) < (Nr) ? (M2 - 1) : (Nr));
            const int T2 = ((M1) < (Nr) ? (M1) : (Nr));

            bool borrow = iv_usub_n<T1>(op1, op2, r);
            if(N1 > N2)
               borrow = iv_sub_int_borrow<T2, T1>(op1, op2[T1], borrow, r);
            else
               borrow = iv_sub_int_borrow<T2, T1>(op1[T1], op2, borrow, r);
            iv_extend<T2>(r, borrow ? ~0 : 0);
         }
      }

      template <int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_neg(const iv_base<N, C>& op1, iv_base<Nr, Cr>& r)
      {
         Slong l = 0;
         if(0 <= ((N) < (Nr) ? (N) : (Nr))) { for(int k = 0; k < ((N) < (Nr) ? (N) : (Nr)) + (exclude == loop_limit::include); ++k) {



#pragma HLS UNROLL
# 1458 "../../../ac_types/include/ac_int.h"
         { l -= (Ulong)(unsigned)op1[k]; r.set(k, (unsigned)l); l >>= 32; } } } else { for(int k = 0; k >= ((N) < (Nr) ? (N) : (Nr)) + (exclude == loop_limit::exclude); --k) {



#pragma HLS UNROLL
# 1458 "../../../ac_types/include/ac_int.h"
         { l -= (Ulong)(unsigned)op1[k]; r.set(k, (unsigned)l); l >>= 32; } } }



           ;
         if(Nr > N)
         {
            r.set(N, (unsigned)(l - (op1[N - 1] < 0 ? ~0 : 0)));
            iv_extend<N + 1>(r, r[N] < 0 ? ~0 : 0);
         }
      }

      template <bool S, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_abs(const iv_base<N, C>& op1, iv_base<Nr, Cr>& r)
      {
         if(S && op1[N - 1] < 0)
         {
            iv_neg(op1, r);
         }
         else
         {
            iv_copy<((N) < (Nr) ? (N) : (Nr)), 0>(op1, r);
            iv_extend<N>(r, 0);
         }
      }

      template <int N, int D, int Q, int R, typename uw2, typename sw4, typename uw4, int w1_length, int Nn, bool Cn,
                int Nd, bool Cd, int Nq, bool Cq, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_udiv(const iv_base<Nn, Cn>& n, const iv_base<Nd, Cd>& d, iv_base<Nq, Cq>& q,
                                  iv_base<Nr, Cr>& r)
      {
         constexpr int w2_length = 2 * w1_length;
         int d_msi = D - 1;
         bool loop_finished = false;
         if(D - 1 <= 0) { for(int index = D - 1; index < 0 + (exclude == loop_limit::include); ++index) {




#pragma HLS UNROLL
# 1492 "../../../ac_types/include/ac_int.h"
         { if(!loop_finished && d_msi > 0 && !d[d_msi]) d_msi--; else loop_finished = true; } } } else { for(int index = D - 1; index >= 0 + (exclude == loop_limit::exclude); --index) {




#pragma HLS UNROLL
# 1492 "../../../ac_types/include/ac_int.h"
         { if(!loop_finished && d_msi > 0 && !d[d_msi]) d_msi--; else loop_finished = true; } } }




           ;
         uw4 d1 = 0;
         if(!d_msi && !d[0])
         {
            d1 = n[0] / d[0];
            return;
         }
         int n_msi = N - 1;
         loop_finished = false;
         if(N - 1 <= 0) { for(int index = N - 1; index < 0 + (exclude == loop_limit::include); ++index) {




#pragma HLS UNROLL
# 1506 "../../../ac_types/include/ac_int.h"
         { if(!loop_finished && n_msi > 0 && !n[n_msi]) n_msi--; else loop_finished = true; } } } else { for(int index = N - 1; index >= 0 + (exclude == loop_limit::exclude); --index) {




#pragma HLS UNROLL
# 1506 "../../../ac_types/include/ac_int.h"
         { if(!loop_finished && n_msi > 0 && !n[n_msi]) n_msi--; else loop_finished = true; } } }




           ;
         if(0 <= Q) { for(int i = 0; i < Q + (exclude == loop_limit::include); ++i) {
# 1512 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1512 "../../../ac_types/include/ac_int.h"
         { q.set(i, 0); } } } else { for(int i = 0; i >= Q + (exclude == loop_limit::exclude); --i) {
# 1512 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1512 "../../../ac_types/include/ac_int.h"
         { q.set(i, 0); } } };
         if(0 <= R) { for(int i = 0; i < R + (exclude == loop_limit::include); ++i) {
# 1513 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1513 "../../../ac_types/include/ac_int.h"
         { r.set(i, n[i]); } } } else { for(int i = 0; i >= R + (exclude == loop_limit::exclude); --i) {
# 1513 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1513 "../../../ac_types/include/ac_int.h"
         { r.set(i, n[i]); } } };

         bool d_mss_odd = (bool)(d[d_msi] >> w1_length);
         int d_mss = 2 * d_msi + d_mss_odd;
         d1 = (uw4)(uw2)d[d_msi] << (w1_length << (int)!d_mss_odd);
         if(d_msi)
            d1 |= (uw2)d[d_msi - 1] >> (d_mss_odd ? w1_length : 0);
         bool n_mss_odd = (bool)(n[n_msi] >> w1_length);
         int n_mss = 2 * n_msi + n_mss_odd;
         if(n_mss < d_mss)
         {


         }
         else
         {
            uw2 r1[N + 1];
            r1[n_msi + 1] = 0;
            if(0 <= N) { for(int index = 0; index < N + (include == loop_limit::include); ++index) {


#pragma HLS UNROLL
# 1531 "../../../ac_types/include/ac_int.h"
            { if(index <= n_msi) r1[index] = n[index]; } } } else { for(int index = 0; index >= N + (include == loop_limit::exclude); --index) {


#pragma HLS UNROLL
# 1531 "../../../ac_types/include/ac_int.h"
            { if(index <= n_msi) r1[index] = n[index]; } } }


              ;
            if(2 * N - 1 <= 0) { for(int k = 2 * N - 1; k < 0 + (include == loop_limit::include); ++k) {
# 1595 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1535 "../../../ac_types/include/ac_int.h"
            { if(k <= n_mss && k >= d_mss) { int k_msi = k >> 1; bool odd = k & 1; uw2 r1m1 = k_msi > 0 ? r1[k_msi - 1] : (uw2)0; uw4 n1 = odd ? (uw4)((r1[k_msi + 1] << w1_length) | (r1[k_msi] >> w1_length)) << w2_length | ((r1[k_msi] << w1_length) | (r1m1 >> w1_length)) : (uw4)r1[k_msi] << w2_length | r1m1; uw2 q1 = n1 / d1; if(q1 >> w1_length) q1--; ; unsigned k2 = k - d_mss; unsigned k2_i = k2 >> 1; bool odd_2 = k2 & 1; uw2 q2 = q1 << (odd_2 ? w1_length : 0); sw4 l = 0; for(int j = 0; j <= d_msi; j++) { l += r1[k2_i + j]; bool l_sign = l < 0; sw4 prod = (uw4)(uw2)d[j] * (uw4)q2; l -= prod; bool ov1 = (l >= 0) & ((prod < 0) | l_sign); bool ov2 = (l < 0) & (prod < 0) & l_sign; r1[k2_i + j] = (uw2)l; l >>= w2_length; if(ov1) l |= ((uw4)-1 << w2_length); if(ov2) l ^= ((sw4)1 << w2_length); } if(odd_2 | d_mss_odd) { l += r1[k2_i + d_msi + 1]; r1[k2_i + d_msi + 1] = (uw2)l; } if(l < 0) { l = 0; for(int j = 0; j <= d_msi; j++) { l += (sw4)(uw2)d[j] << (odd_2 ? w1_length : 0); l += r1[k2_i + j]; r1[k2_i + j] = (uw2)l; l >>= w2_length; } if(odd_2 | d_mss_odd) r1[k2_i + d_msi + 1] += (uw2)l; q1--; } if(Q && k2_i < Q) { if(odd_2) q.set(k2_i, q1 << w1_length); else q.set(k2_i, q[k2_i] | q1); } } } } } else { for(int k = 2 * N - 1; k >= 0 + (include == loop_limit::exclude); --k) {
# 1595 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1535 "../../../ac_types/include/ac_int.h"
            { if(k <= n_mss && k >= d_mss) { int k_msi = k >> 1; bool odd = k & 1; uw2 r1m1 = k_msi > 0 ? r1[k_msi - 1] : (uw2)0; uw4 n1 = odd ? (uw4)((r1[k_msi + 1] << w1_length) | (r1[k_msi] >> w1_length)) << w2_length | ((r1[k_msi] << w1_length) | (r1m1 >> w1_length)) : (uw4)r1[k_msi] << w2_length | r1m1; uw2 q1 = n1 / d1; if(q1 >> w1_length) q1--; ; unsigned k2 = k - d_mss; unsigned k2_i = k2 >> 1; bool odd_2 = k2 & 1; uw2 q2 = q1 << (odd_2 ? w1_length : 0); sw4 l = 0; for(int j = 0; j <= d_msi; j++) { l += r1[k2_i + j]; bool l_sign = l < 0; sw4 prod = (uw4)(uw2)d[j] * (uw4)q2; l -= prod; bool ov1 = (l >= 0) & ((prod < 0) | l_sign); bool ov2 = (l < 0) & (prod < 0) & l_sign; r1[k2_i + j] = (uw2)l; l >>= w2_length; if(ov1) l |= ((uw4)-1 << w2_length); if(ov2) l ^= ((sw4)1 << w2_length); } if(odd_2 | d_mss_odd) { l += r1[k2_i + d_msi + 1]; r1[k2_i + d_msi + 1] = (uw2)l; } if(l < 0) { l = 0; for(int j = 0; j <= d_msi; j++) { l += (sw4)(uw2)d[j] << (odd_2 ? w1_length : 0); l += r1[k2_i + j]; r1[k2_i + j] = (uw2)l; l >>= w2_length; } if(odd_2 | d_mss_odd) r1[k2_i + d_msi + 1] += (uw2)l; q1--; } if(Q && k2_i < Q) { if(odd_2) q.set(k2_i, q1 << w1_length); else q.set(k2_i, q[k2_i] | q1); } } } } }
# 1595 "../../../ac_types/include/ac_int.h"
              ;
            if(R)
            {
               int r_msi = ((R - 1) < (n_msi) ? (R - 1) : (n_msi));
               for(int j = 0; j <= r_msi; j++)
                  r.set(j, r1[j]);
               for(int j = r_msi + 1; j < R; j++)
                  r.set(j, 0);
            }
         }
      }

      template <int Num_s, int Den_s, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_div(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         enum
         {
            N1_over = N1 + (Den_s && (Num_s == 2))
         };
         if(N1_over == 1 && N2 == 1)
         {
            r.set(0, op1[0] / op2[0]);
            iv_extend<1>(r, ((Num_s || Den_s) && (r[0] < 0)) ? ~0 : 0);
         }
         else if(N1_over <= 2 && N2 <= 2)
            iv_assign_int64(r, op1.to_int64() / op2.to_int64());
         else if(!Num_s && !Den_s)
         {
            iv_base<1, false> dummy;
            iv_udiv<N1, N2, N1, 0, unsigned, Slong, Ulong, 16>(op1, op2, r, dummy);
            iv_extend<N1>(r, 0);
         }
         else
         {
            enum
            {
               N1_neg = N1 + (Num_s == 2),
               N2_neg = N2 + (Den_s == 2)
            };
            iv_base<N1_neg, false> numerator;
            iv_base<N2_neg, false> denominator;
            iv_base<N1_neg, false> quotient;
            iv_abs<(bool)Num_s>(op1, numerator);
            iv_abs<(bool)Den_s>(op2, denominator);
            iv_base<1, false> dummy;
            iv_udiv<N1_neg, N2_neg, N1_neg, 0, unsigned, Slong, Ulong, 16>(numerator, denominator, quotient, dummy);
            if((Num_s && op1[N1 - 1] < 0) ^ (Den_s && op2[N2 - 1] < 0))
               iv_neg(quotient, r);
            else
            {
               iv_copy<((N1_neg) < (Nr) ? (N1_neg) : (Nr)), 0>(quotient, r);
               iv_extend<N1_neg>(r, (Num_s || Den_s) && r[N1_neg - 1] < 0 ? ~0 : 0);
            }
         }
      }

      template <int Num_s, int Den_s, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_rem(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         enum
         {
            N1_over = N1 + (Den_s && (Num_s == 2))
         };
         if(N1_over == 1 && N2 == 1)
         {
            r.set(0, op1[0] % op2[0]);
            iv_extend<1>(r, Num_s && r[0] < 0 ? ~0 : 0);
         }
         else if(N1_over <= 2 && N2 <= 2)
            iv_assign_int64(r, op1.to_int64() % op2.to_int64());
         else if(!Num_s && !Den_s)
         {
            iv_base<1, false> dummy;
            iv_udiv<N1, N2, 0, N2, unsigned, Slong, Ulong, 16>(op1, op2, dummy, r);
            iv_extend<N2>(r, 0);
         }
         else
         {
            enum
            {
               N1_neg = N1 + (Num_s == 2),
               N2_neg = N2 + (Den_s == 2)
            };
            iv_base<N1_neg, false> numerator;
            iv_base<N2_neg, false> denominator;
            iv_base<N2, false> remainder;
            iv_abs<(bool)Num_s>(op1, numerator);
            iv_abs<(bool)Den_s>(op2, denominator);
            iv_base<1, false> dummy;
            iv_udiv<N1_neg, N2_neg, 0, N2, unsigned, Slong, Ulong, 16>(numerator, denominator, dummy, remainder);
            if((Num_s && op1[N1 - 1] < 0))
               iv_neg(remainder, r);
            else
            {
               iv_copy<((N2) < (Nr) ? (N2) : (Nr)), 0>(remainder, r);
               iv_extend<N2>(r, Num_s && r[N2 - 1] < 0 ? ~0 : 0);
            }
         }
      }

      template <int N, int START, int N1, bool C1, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_complement_n(const iv_base<N1, C1>& op, iv_base<Nr, Cr>& r)
      {
         if(START < N)
         {
            if(START <= N) { for(int i = START; i < N + (exclude == loop_limit::include); ++i) {
# 1700 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1700 "../../../ac_types/include/ac_int.h"
            { r.set(i, ~op[i]); } } } else { for(int i = START; i >= N + (exclude == loop_limit::exclude); --i) {
# 1700 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1700 "../../../ac_types/include/ac_int.h"
            { r.set(i, ~op[i]); } } };
         }
      }

      template <int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_complement(const iv_base<N, C>& op, iv_base<Nr, Cr>& r)
      {
         const int M = ((N) < (Nr) ? (N) : (Nr));
         iv_bitwise_complement_n<M, 0>(op, r);
         iv_extend<M>(r, (r[M - 1] < 0) ? ~0 : 0);
      }

      template <int N, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_and_n(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {
# 1715 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1715 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] & op2[i]); } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {
# 1715 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1715 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] & op2[i]); } } };
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_and(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         const int M1 = ((((N1) > (N2) ? (N1) : (N2))) < (Nr) ? (((N1) > (N2) ? (N1) : (N2))) : (Nr));
         const int M2 = ((((N1) < (N2) ? (N1) : (N2))) < (Nr) ? (((N1) < (N2) ? (N1) : (N2))) : (Nr));
         const bool M1C1 = N1 > N2 ? C1 : C2;
         const iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>& OP1 = N1 > N2 ? static_cast<iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>>(op1) :
                                                              static_cast<iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>>(op2);
         const bool M2C1 = N1 > N2 ? C2 : C1;
         const iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>& OP2 = N1 > N2 ? static_cast<iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>>(op2) :
                                                              static_cast<iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>>(op1);

         iv_bitwise_and_n<M2>(op1, op2, r);
         if(OP2[M2 - 1] < 0)
            iv_copy<M1, M2>(OP1, r);
         else
            iv_extend<M2>(r, 0);
         iv_extend<M1>(r, (r[M1 - 1] < 0) ? ~0 : 0);
      }

      template <int N, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_or_n(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {
# 1741 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1741 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] | op2[i]); } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {
# 1741 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1741 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] | op2[i]); } } };
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_or(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         const int M1 = ((((N1) > (N2) ? (N1) : (N2))) < (Nr) ? (((N1) > (N2) ? (N1) : (N2))) : (Nr));
         const int M2 = ((((N1) < (N2) ? (N1) : (N2))) < (Nr) ? (((N1) < (N2) ? (N1) : (N2))) : (Nr));
         const bool M1C1 = N1 >= N2 ? C1 : C2;
         const iv_base<M1, M1C1>& OP1 =
             N1 >= N2 ? static_cast<iv_base<M1, M1C1>>(op1) : static_cast<iv_base<M1, M1C1>>(op2);
         const bool M2C1 = N1 >= N2 ? C2 : C1;
         const iv_base<M2, M2C1>& OP2 =
             N1 >= N2 ? static_cast<iv_base<M2, M2C1>>(op2) : static_cast<iv_base<M2, M2C1>>(op1);

         iv_bitwise_or_n<M2>(op1, op2, r);
         if(OP2[M2 - 1] < 0)
            iv_extend<M2>(r, ~0);
         else
            iv_copy<M1, M2>(OP1, r);
         iv_extend<M1>(r, (r[M1 - 1] < 0) ? ~0 : 0);
      }

      template <int N, int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_xor_n(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         if(0 <= N) { for(int i = 0; i < N + (exclude == loop_limit::include); ++i) {
# 1767 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1767 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] ^ op2[i]); } } } else { for(int i = 0; i >= N + (exclude == loop_limit::exclude); --i) {
# 1767 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1767 "../../../ac_types/include/ac_int.h"
         { r.set(i, op1[i] ^ op2[i]); } } };
      }

      template <int N1, bool C1, int N2, bool C2, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_bitwise_xor(const iv_base<N1, C1>& op1, const iv_base<N2, C2>& op2, iv_base<Nr, Cr>& r)
      {
         const int M1 = ((((N1) > (N2) ? (N1) : (N2))) < (Nr) ? (((N1) > (N2) ? (N1) : (N2))) : (Nr));
         const int M2 = ((((N1) < (N2) ? (N1) : (N2))) < (Nr) ? (((N1) < (N2) ? (N1) : (N2))) : (Nr));
         const bool M1C1 = N1 >= N2 ? C1 : C2;
         const bool M2C1 = N1 >= N2 ? C2 : C1;
         const iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>& OP1 = N1 >= N2 ? static_cast<iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>>(op1) :
                                                               static_cast<iv_base<((N1) > (N2) ? (N1) : (N2)), M1C1>>(op2);
         const iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>& OP2 = N1 >= N2 ? static_cast<iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>>(op2) :
                                                               static_cast<iv_base<((N1) < (N2) ? (N1) : (N2)), M2C1>>(op1);

         iv_bitwise_xor_n<M2>(op1, op2, r);
         if(OP2[M2 - 1] < 0)
            iv_bitwise_complement_n<M1, M2>(OP1, r);
         else
            iv_copy<M1, M2>(OP1, r);
         iv_extend<M1>(r, (r[M1 - 1] < 0) ? ~0 : 0);
      }

      template <int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_shift_l(const iv_base<N, C>& op1, unsigned op2, iv_base<Nr, Cr>& r)
      {
         ;
         unsigned s31 = op2 & 31;
         unsigned ishift = (op2 >> 5) > Nr ? Nr : (op2 >> 5);
         if(s31 && ishift != Nr)
         {
            unsigned lw = 0;
            if(0 <= Nr) { for(unsigned i = 0; i < Nr + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1799 "../../../ac_types/include/ac_int.h"
            { unsigned hw = (i >= ishift) ? op1[i - ishift] : 0; r.set(i, (hw << s31) | (lw >> (32 - s31))); lw = hw; } } } else { for(unsigned i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1799 "../../../ac_types/include/ac_int.h"
            { unsigned hw = (i >= ishift) ? op1[i - ishift] : 0; r.set(i, (hw << s31) | (lw >> (32 - s31))); lw = hw; } } }



              ;
         }
         else
         {
            if(0 <= Nr) { for(unsigned i = 0; i < Nr + (exclude == loop_limit::include); ++i) {
# 1807 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1807 "../../../ac_types/include/ac_int.h"
            { r.set(i, (i >= ishift) ? op1[i - ishift] : 0); } } } else { for(unsigned i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {
# 1807 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1807 "../../../ac_types/include/ac_int.h"
            { r.set(i, (i >= ishift) ? op1[i - ishift] : 0); } } };
         }
      }

      template <int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_shift_r(const iv_base<N, C>& op1, unsigned op2, iv_base<Nr, Cr>& r)
      {
         unsigned s31 = op2 & 31;
         unsigned ishift = (op2 >> 5) > N ? N : (op2 >> 5);
         int ext = op1[N - 1] < 0 ? ~0 : 0;
         if(s31 && ishift != N)
         {
            unsigned lw = (ishift < N) ? op1[ishift] : ext;
            if(0 <= Nr) { for(unsigned i = 0; i < Nr + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1820 "../../../ac_types/include/ac_int.h"
            { unsigned hw = (i + ishift + 1 < N) ? op1[i + ishift + 1] : ext; r.set(i, (lw >> s31) | (hw << (32 - s31))); lw = hw; } } } else { for(unsigned i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1820 "../../../ac_types/include/ac_int.h"
            { unsigned hw = (i + ishift + 1 < N) ? op1[i + ishift + 1] : ext; r.set(i, (lw >> s31) | (hw << (32 - s31))); lw = hw; } } }



              ;
         }
         else
         {
            if(0 <= Nr) { for(unsigned i = 0; i < Nr + (exclude == loop_limit::include); ++i) {
# 1828 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1828 "../../../ac_types/include/ac_int.h"
            { r.set(i, (i + ishift < N) ? op1[i + ishift] : ext); } } } else { for(unsigned i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {
# 1828 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1828 "../../../ac_types/include/ac_int.h"
            { r.set(i, (i + ishift < N) ? op1[i + ishift] : ext); } } };
         }
      }

      template <bool S, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_shift_l2(const iv_base<N, C>& op1, signed op2, iv_base<Nr, Cr>& r)
      {
         if(S && op2 < 0)
            iv_shift_r(op1, -op2, r);
         else
            iv_shift_l(op1, op2, r);
      }

      template <bool S, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_shift_r2(const iv_base<N, C>& op1, signed op2, iv_base<Nr, Cr>& r)
      {
         if(S && op2 < 0)
            iv_shift_l(op1, -op2, r);
         else
            iv_shift_r(op1, op2, r);
      }

      template <int B, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline constexpr void iv_const_shift_l(const iv_base<N, C>& op1, iv_base<Nr, Cr>& r)
      {

         if(!B)
         {
            constexpr int M1 = ((N) < (Nr) ? (N) : (Nr));
            iv_copy<M1, 0>(op1, r);
            iv_extend<M1>(r, r[M1 - 1] < 0 ? -1 : 0);
         }
         else
         {
            constexpr unsigned s31 = B & 31;
            constexpr int ishift = (((B >> 5) > Nr) ? Nr : (B >> 5));
            constexpr int M1 = ((N + ishift) < (Nr) ? (N + ishift) : (Nr));
            if(0 <= ishift) { for(int idx = 0; idx < ishift + (exclude == loop_limit::include); ++idx) {
# 1865 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1865 "../../../ac_types/include/ac_int.h"
            { r.set(idx, 0); } } } else { for(int idx = 0; idx >= ishift + (exclude == loop_limit::exclude); --idx) {
# 1865 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1865 "../../../ac_types/include/ac_int.h"
            { r.set(idx, 0); } } };
            if(s31)
            {
               unsigned lw = 0;
               if(ishift < M1)
               {
                  if(ishift <= M1) { for(int i = ishift; i < M1 + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1871 "../../../ac_types/include/ac_int.h"
                  { unsigned hw = op1[i - ishift]; r.set(i, (hw << s31) | (lw >> ((32 - s31) & 31))); lw = hw; } } } else { for(int i = ishift; i >= M1 + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1871 "../../../ac_types/include/ac_int.h"
                  { unsigned hw = op1[i - ishift]; r.set(i, (hw << s31) | (lw >> ((32 - s31) & 31))); lw = hw; } } }



                    ;
               }
               if(Nr > M1)
               {
                  r.set(M1, (signed)lw >> ((32 - s31) & 31));
                  iv_extend<M1 + 1>(r, r[M1] < 0 ? ~0 : 0);
               }
            }
            else
            {
               if(ishift < M1)
               {
                  if(ishift <= M1) { for(int i = ishift; i < M1 + (exclude == loop_limit::include); ++i) {
# 1887 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1887 "../../../ac_types/include/ac_int.h"
                  { r.set(i, op1[i - ishift]); } } } else { for(int i = ishift; i >= M1 + (exclude == loop_limit::exclude); --i) {
# 1887 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1887 "../../../ac_types/include/ac_int.h"
                  { r.set(i, op1[i - ishift]); } } };
               }
               iv_extend<M1>(r, r[M1 - 1] < 0 ? -1 : 0);
            }
         }
      }

      template <int B, int N, bool C, int Nr, bool Cr>
      __attribute__((always_inline)) inline void iv_const_shift_r(const iv_base<N, C>& op1, iv_base<Nr, Cr>& r)
      {
         if(!B)
         {
            constexpr int M1 = ((N) < (Nr) ? (N) : (Nr));
            iv_copy<M1, 0>(op1, r);
            iv_extend<M1>(r, r[M1 - 1] < 0 ? ~0 : 0);
         }
         else
         {
            constexpr unsigned s31 = B & 31;
            constexpr int ishift = (((B >> 5) > N) ? N : (B >> 5));
            int ext = op1[N - 1] < 0 ? ~0 : 0;
            if(s31 && ishift != N)
            {
               unsigned lw = (ishift < N) ? op1[ishift] : ext;
               if(0 <= Nr) { for(int i = 0; i < Nr + (exclude == loop_limit::include); ++i) {



#pragma HLS UNROLL
# 1911 "../../../ac_types/include/ac_int.h"
               { unsigned hw = (i + ishift + 1 < N) ? op1[i + ishift + 1] : ext; r.set(i, (lw >> s31) | (hw << ((32 - s31) & 31))); lw = hw; } } } else { for(int i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {



#pragma HLS UNROLL
# 1911 "../../../ac_types/include/ac_int.h"
               { unsigned hw = (i + ishift + 1 < N) ? op1[i + ishift + 1] : ext; r.set(i, (lw >> s31) | (hw << ((32 - s31) & 31))); lw = hw; } } }



                 ;
            }
            else
            {
               if(0 <= Nr) { for(int i = 0; i < Nr + (exclude == loop_limit::include); ++i) {
# 1919 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1919 "../../../ac_types/include/ac_int.h"
               { r.set(i, (i + ishift < N) ? op1[i + ishift] : ext); } } } else { for(int i = 0; i >= Nr + (exclude == loop_limit::exclude); --i) {
# 1919 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 1919 "../../../ac_types/include/ac_int.h"
               { r.set(i, (i + ishift < N) ? op1[i + ishift] : ext); } } };
            }
         }
      }

      template <int N, bool C>
      __attribute__((always_inline)) inline constexpr void iv_conv_from_fraction(const double d, iv_base<N, C>& r, bool* qb, bool* rbits,
                                                          bool* o)
      {
         bool b = d < 0;
         double d2 = b ? -d : d;
         double dfloor = mgc_floor(d2);
         *o = dfloor != 0.0;
         d2 = d2 - dfloor;
         if(N - 1 <= 0) { for(int i = N - 1; i < 0 + (include == loop_limit::include); ++i) {




#pragma HLS UNROLL
# 1933 "../../../ac_types/include/ac_int.h"
         { d2 *= (Ulong)1 << 32; auto k = (unsigned int)d2; r.set(i, b ? ~k : k); d2 -= k; } } } else { for(int i = N - 1; i >= 0 + (include == loop_limit::exclude); --i) {




#pragma HLS UNROLL
# 1933 "../../../ac_types/include/ac_int.h"
         { d2 *= (Ulong)1 << 32; auto k = (unsigned int)d2; r.set(i, b ? ~k : k); d2 -= k; } } }




           ;
         d2 *= 2;
         bool k = ((int)d2) != 0;
         d2 -= k;
         *rbits = d2 != 0.0;
         *qb = (b && *rbits) ^ k;
         if(b && !*rbits && !*qb)
            iv_uadd_carry(r, true, r);
         *o |= b ^ (r[N - 1] < 0);
      }

      template <int N, bool C>
      __attribute__((always_inline)) inline constexpr void iv_conv_from_fraction(const float d, iv_base<N, C>& r, bool* qb, bool* rbits,
                                                          bool* o)
      {
         bool b = d < 0;
         float d2 = b ? -d : d;
         float dfloor = mgc_floor(d2);
         *o = dfloor != 0.0;
         d2 = d2 - dfloor;
         if(N - 1 <= 0) { for(int i = N - 1; i < 0 + (include == loop_limit::include); ++i) {




#pragma HLS UNROLL
# 1958 "../../../ac_types/include/ac_int.h"
         { d2 *= (Ulong)1 << 32; auto k = static_cast<unsigned int>(d2); r.set(i, b ? ~k : k); d2 -= k; } } } else { for(int i = N - 1; i >= 0 + (include == loop_limit::exclude); --i) {




#pragma HLS UNROLL
# 1958 "../../../ac_types/include/ac_int.h"
         { d2 *= (Ulong)1 << 32; auto k = static_cast<unsigned int>(d2); r.set(i, b ? ~k : k); d2 -= k; } } }




           ;
         d2 *= 2;
         bool k = ((int)d2) != 0;
         d2 -= k;
         *rbits = d2 != 0.0;
         *qb = (b && *rbits) ^ k;
         if(b && !*rbits && !*qb)
            iv_uadd_carry(r, true, r);
         *o |= b ^ (r[N - 1] < 0);
      }

      template <ac_base_mode b, int N, bool C>
      struct to_strImpl
      {
         static __attribute__((always_inline)) inline int to_str(iv_base<N, C>& v, int w, bool left_just, char* r)
         {
            const char digits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
            const unsigned char B = b == AC_BIN ? 1 : (b == AC_OCT ? 3 : (b == AC_HEX ? 4 : 0));
            int k = (w + B - 1) / B;
            int n = (w + 31) >> 5;
            int bits = 0;
            if(b != AC_BIN && left_just)
            {
               if((bits = -(w % B)))
                  r[--k] = 0;
            }
            for(int i = 0; i < n; i++)
            {
               if(b != AC_BIN && bits < 0)
                  r[k] += (unsigned char)((v[i] << (B + bits)) & (b - 1));
               unsigned int m = (unsigned)v[i] >> -bits;
               for(bits += 32; bits > 0 && k; bits -= B)
               {
                  r[--k] = (char)(m & (b - 1));
                  m >>= B;
               }
            }
            for(int i = 0; i < (w + B - 1) / B; i++)
               r[i] = digits[(int)r[i]];
            return (w + B - 1) / B;
         }
      };
      template <int N, bool C>
      struct to_strImpl<AC_DEC, N, C>
      {
         static __attribute__((always_inline)) inline int to_str(iv_base<N, C>& v, int w, bool left_just, char* r)
         {
            int k = 0;
            int msw = (w - 1) >> 5;
            if(left_just)
            {
               unsigned bits_msw = w & 31;
               if(bits_msw)
               {
                  unsigned left_shift = 32 - bits_msw;
                  for(int i = msw; i > 0; i--)
                     v.set(i, v[i] << left_shift | (unsigned)v[i - 1] >> bits_msw);
                  v.set(0, v[0] << left_shift);
               }
               int lsw = 0;
               while(lsw < msw || v[msw])
               {
                  Ulong l = 0;
                  for(int i = lsw; i <= msw; i++)
                  {
                     l += (Ulong)(unsigned)v[i] * 10;
                     v.set(i, l);
                     l >>= 32;
                     if(i == lsw && !v[i])
                        lsw++;
                  }
                  r[k++] = (char)('0' + (int)l);
               }
            }
            else
            {
               const unsigned d = 1000000000;
               for(; msw > 0 && !v[msw]; msw--)
               {
               }
               while(msw >= 0)
               {
                  Ulong nl = 0;
                  for(int i = msw; i >= 0; i--)
                  {
                     nl <<= 32;
                     nl |= (unsigned)v[i];
                     unsigned q = nl / d;
                     nl -= (Ulong)q * d;
                     v.set(i, q);
                  }
                  if(!v[msw])
                     msw--;
                  bool last = msw == -1;
                  auto rem = (unsigned)nl;
                  for(int i = 0; (i < 9 && !last) || rem; i++)
                  {
                     r[k++] = (char)('0' + (int)(rem % 10));
                     rem /= 10;
                  }
               }
               for(int i = 0; i < k / 2; i++)
               {
                  char c = r[i];
                  r[i] = r[k - 1 - i];
                  r[k - 1 - i] = c;
               }
            }
            r[k] = 0;
            return k;
         }
      };
      template <int N, bool C>
      __attribute__((always_inline)) inline int to_string(iv_base<N, C>& v, int w, bool sign_mag, ac_base_mode base, bool left_just, char* r)
      {
         int n = (w + 31) >> 5;
         bool neg = !sign_mag && v[n - 1] < 0;
         if(!left_just)
         {
            while(n-- && v[n] == (neg ? ~0 : 0))
            {
            }
            int w2 = 32 * (n + 1);
            if(w2)
            {
               int m = v[n];
               for(int i = 16; i > 0; i >>= 1)
               {
                  if((m >> i) == (neg ? ~0 : 0))
                     w2 -= i;
                  else
                     m >>= i;
               }
            }
            if(w2 < w)
               w = w2;
            w += !sign_mag;
         }
         if(base == AC_DEC)
            return to_strImpl<AC_DEC, N, C>::to_str(v, w, left_just, r);
         else if(base == AC_HEX)
            return to_strImpl<AC_HEX, N, C>::to_str(v, w, left_just, r);
         else if(base == AC_OCT)
            return to_strImpl<AC_OCT, N, C>::to_str(v, w, left_just, r);
         else if(base == AC_BIN)
            return to_strImpl<AC_BIN, N, C>::to_str(v, w, left_just, r);
         return 0;
      }

      template <int N, bool C>
      __attribute__((always_inline)) inline unsigned iv_leading_bits_base(const iv_base<N, C>& op, bool bit, int POS)
      {
         const unsigned char tab[] = {4, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
         unsigned t = bit ? ~op[POS] : op[POS];
         unsigned cnt = 0;
         if(t >> 16)
            t >>= 16;
         else
            cnt += 16;
         if(t >> 8)
            t >>= 8;
         else
            cnt += 8;
         if(t >> 4)
            t >>= 4;
         else
            cnt += 4;
         cnt += tab[t];
         return cnt;
      }

      template <int N, bool C>
      __attribute__((always_inline)) inline unsigned iv_leading_bits(const iv_base<N, C>& op, bool bit)
      {
         int ext_sign = bit ? -1 : 0;
         int k;
         for(k = N - 1; k >= 0 && op[k] == ext_sign; k--)
         {
         }
         return 32 * (N - 1 - k) + (k < 0 ? 0 : iv_leading_bits_base(op, bit, k));
      }




      template <int N, bool C>
      class iv
      {
       protected:
         class hex2doubleConverter
         {
            using size_t = decltype(sizeof(0));
            static constexpr const long double _0x1p256 = 0x1p256L;
            typedef union
            {
               double dvalue;
               unsigned long long int ull_value;
            } ieee_double_shape_type;

            template <size_t begin, char charToFind, size_t NN>
            struct HfindCharImpl
            {
               static constexpr size_t HfindChar(const char (&str)[NN])
               {
                  return (str[begin] == charToFind) * (begin + 1) +
                         HfindCharImpl<begin - 1, charToFind, NN>::HfindChar(str);
               }
            };
            template <char charToFind, size_t NN>
            struct HfindCharImpl<0, charToFind, NN>
            {
               static constexpr size_t HfindChar(const char (&str)[NN])
               {
                  return (str[0] == charToFind);
               }
            };
            template <size_t Index, int base, typename Int, size_t NN>
            struct getNumberImpl
            {
               __attribute__((always_inline)) inline static constexpr Int getNumber(const char (&str)[NN], size_t begin, size_t end)
               {
                  Int increment = (Index < begin || Index >= end) ? 0 : HhexDigit(str[Index]);
                  Int multiplier = (Index < begin || Index >= end) ? 1 : base;
                  return increment + multiplier * getNumberImpl<Index - 1, base, Int, NN>::getNumber(str, begin, end);
               }
            };
            template <int base, typename Int, size_t NN>
            struct getNumberImpl<0, base, Int, NN>
            {
               __attribute__((always_inline)) inline static constexpr Int getNumber(const char (&str)[NN], size_t begin, size_t end)
               {
                  Int increment = (0 < begin || 0 >= end) ? 0 : HhexDigit(str[0]);
                  return increment;
               }
            };


            static constexpr int HhexDigit(char c)
            {
               return '0' <= c && c <= '9' ? c - '0' :
                      'a' <= c && c <= 'f' ? c - 'a' + 0xa :
                      'A' <= c && c <= 'F' ? c - 'A' + 0xA :
                                             0;
            }

            static constexpr double Hscalbn(const double value, const int exponent)
            {
               ieee_double_shape_type in;
               in.dvalue = value;
               if(in.ull_value << 1 == 0)
                  return value;
               unsigned long long cur_exp = (((int)((in.ull_value >> 52) & 0x7ff)) + exponent);
               in.ull_value = (in.ull_value & (~(0x7ffULL << 52))) | (cur_exp << 52);
               return in.dvalue;
            }

            template <size_t NN>
            static constexpr size_t HmantissaEnd0(const char (&str)[NN])
            {
               return HfindCharImpl<NN - 1, 'p', NN>::HfindChar(str);
            }
            template <size_t NN>
            static constexpr size_t HmantissaEnd1(const size_t mantissa_end)
            {
               return mantissa_end == 0 ? NN : mantissa_end - 1;
            }

            template <size_t NN>
            static constexpr size_t HmantissaEnd(const char (&str)[NN])
            {
               return HmantissaEnd1<NN>(HmantissaEnd0(str));
            }

            template <size_t NN>
            static constexpr size_t HpointPos0(const char (&str)[NN])
            {
               return HfindCharImpl<NN - 1, '.', NN>::HfindChar(str);
            }
            template <size_t NN>
            static constexpr size_t HpointPos1(const size_t mantissa_end, const size_t pp0)
            {
               return pp0 == 0 ? mantissa_end : pp0 - 1;
            }
            template <size_t NN>
            static constexpr size_t HpointPos(const char (&str)[NN], const size_t mantissa_end)
            {
               return HpointPos1<NN>(mantissa_end, HpointPos0(str));
            }

            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr int Hexponent(const char (&str)[NN], const size_t mantissa_end)
            {
               return mantissa_end == NN ? 0 :
                                           (str[mantissa_end + 1] == '-' ? -1 : 1) *
                                               getNumberImpl<NN - 1, 10, int, NN>::getNumber(
                                                   str, mantissa_end + 1 + HisSign(mantissa_end + 1), NN - 1);
            }

            static constexpr bool HisSign(char ch)
            {
               return ch == '+' || ch == '-';
            }
            template <size_t NN>
            static constexpr size_t HmantissaBegin(const char (&str)[NN])
            {
               return HisSign(str[0]) + 2 * (str[HisSign(str[0])] == '0' && str[HisSign(str[0]) + 1] == 'x');
            }
            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr unsigned long long HbeforePoint(const char (&str)[NN],
                                                                            const size_t point_pos)
            {
               return getNumberImpl<NN - 1, 16, unsigned long long, NN>::getNumber(str, HmantissaBegin(str), point_pos);
            }

            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr unsigned long long Hfraction(const char (&str)[NN], const size_t point_pos,
                                                                         const size_t mantissa_end)
            {
               return getNumberImpl<NN - 1, 16, unsigned long long, NN>::getNumber(str, point_pos + 1, mantissa_end);
            }

            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr double get0(const char (&str)[NN], const size_t mantissa_end,
                                                        const size_t point_pos, const size_t exp)
            {



               return (str[0] == '-' ? -1 : 1) *
                      (Hscalbn(HbeforePoint(str, point_pos), exp) +
                       Hscalbn(Hfraction(str, point_pos, mantissa_end), exp - 4 * (mantissa_end - point_pos - 1)));
            }
            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr double get1(const char (&str)[NN], const size_t mantissa_end)
            {
               return get0(str, mantissa_end, HpointPos(str, mantissa_end), Hexponent(str, mantissa_end));
            }

          public:
            template <size_t NN>
            __attribute__((always_inline)) inline static constexpr double get(const char (&str)[NN])
            {
               return get1(str, HmantissaEnd(str));
            }
         };
         iv_base<N, C> v;

       public:
         template <int N2, bool C2>
         friend class iv;
         __attribute__((always_inline)) inline
         constexpr iv()
         {
         }

         template <int N2, bool C2>
         __attribute__((always_inline)) inline constexpr iv(const iv<N2, C2>& b)
         {
            const int M = ((N) < (N2) ? (N) : (N2));
            iv_copy<M, 0>(b.v, v);
            iv_extend<M>(v, (v[M - 1] < 0) ? ~0 : 0);
         }

         __attribute__((always_inline)) inline constexpr iv(Slong t)
         {
            iv_assign_int64(v, t);
         }

         __attribute__((always_inline)) inline constexpr iv(Ulong t)
         {
            iv_assign_uint64(v, t);
         }

         __attribute__((always_inline)) inline constexpr iv(int t)
         {
            v.set(0, t);
            iv_extend<1>(v, (t < 0) ? ~0 : 0);
         }

         __attribute__((always_inline)) inline constexpr iv(unsigned int t)
         {
            v.set(0, t);
            iv_extend<1>(v, 0);
         }

         __attribute__((always_inline)) inline constexpr iv(long t)
         {
            if(long_w == 32)
            {
               v.set(0, t);
               iv_extend<1>(v, (t < 0) ? ~0 : 0);
            }
            else
               iv_assign_int64(v, t);
         }

         __attribute__((always_inline)) inline constexpr iv(unsigned long t)
         {
            if(long_w == 32)
            {
               v.set(0, t);
               iv_extend<1>(v, 0);
            }
            else
               iv_assign_uint64(v, t);
         }

         __attribute__((always_inline)) inline constexpr iv(double d)
         {
            double d2 = ldexpr32<-N>(d);
            bool qb = false, rbits = false, o = false;
            iv_conv_from_fraction(d2, v, &qb, &rbits, &o);
         }

         __attribute__((always_inline)) inline constexpr iv(float d)
         {
            float d2 = ldexpr32<-N>(d);
            bool qb = false, rbits = false, o = false;
            iv_conv_from_fraction(d2, v, &qb, &rbits, &o);
         }

         template <size_t NN>
         __attribute__((always_inline)) inline constexpr iv(const char (&str)[NN])
         {
            *this = iv(hex2doubleConverter::get(str));
         }


         __attribute__((always_inline)) inline constexpr Slong to_int64() const
         {
            return v.to_int64();
         }
         __attribute__((always_inline)) inline constexpr Ulong to_uint64() const
         {
            return (Ulong)v.to_int64();
         }
         __attribute__((always_inline)) inline double to_double() const
         {
            double a = v[N - 1];
            if((N - 2) >= 0)
            {
               if(N - 2 <= 0) { for(int i = N - 2; i < 0 + (include == loop_limit::include); ++i) {


#pragma HLS UNROLL
# 2404 "../../../ac_types/include/ac_int.h"
               { a *= (Ulong)1 << 32; a += (unsigned)v[i]; } } } else { for(int i = N - 2; i >= 0 + (include == loop_limit::exclude); --i) {


#pragma HLS UNROLL
# 2404 "../../../ac_types/include/ac_int.h"
               { a *= (Ulong)1 << 32; a += (unsigned)v[i]; } } }


                 ;
            }
            return a;
         }
         __attribute__((always_inline)) inline constexpr float to_float() const
         {
            float a = v[N - 1];
            if((N - 2) >= 0)
            {
               if(N - 2 <= 0) { for(int i = N - 2; i < 0 + (include == loop_limit::include); ++i) {


#pragma HLS UNROLL
# 2416 "../../../ac_types/include/ac_int.h"
               { a *= (Ulong)1 << 32; a += (unsigned)v[i]; } } } else { for(int i = N - 2; i >= 0 + (include == loop_limit::exclude); --i) {


#pragma HLS UNROLL
# 2416 "../../../ac_types/include/ac_int.h"
               { a *= (Ulong)1 << 32; a += (unsigned)v[i]; } } }


                 ;
            }
            return a;
         }
         __attribute__((always_inline)) inline constexpr void conv_from_fraction(double d, bool* qb, bool* rbits, bool* o)
         {
            iv_conv_from_fraction(d, v, qb, rbits, o);
         }
         __attribute__((always_inline)) inline constexpr void conv_from_fraction(float d, bool* qb, bool* rbits, bool* o)
         {
            iv_conv_from_fraction(d, v, qb, rbits, o);
         }

         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void mult(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_mult(v, op2.v, r.v);
         }
         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void add(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_add(v, op2.v, r.v);
         }
         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void sub(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_sub(v, op2.v, r.v);
         }
         template <int Num_s, int Den_s, int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void div(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_div<Num_s, Den_s>(v, op2.v, r.v);
         }
         template <int Num_s, int Den_s, int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void rem(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_rem<Num_s, Den_s>(v, op2.v, r.v);
         }
         __attribute__((always_inline)) inline void increment()
         {
            iv_uadd_carry(v, true, v);
         }
         __attribute__((always_inline)) inline void decrement()
         {
            iv_sub_int_borrow<N>(v, 0, true, v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void neg(iv<Nr, Cr>& r) const
         {
            iv_neg(v, r.v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void shift_l(unsigned op2, iv<Nr, Cr>& r) const
         {
            iv_shift_l(v, op2, r.v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void shift_l2(signed op2, iv<Nr, Cr>& r) const
         {
            iv_shift_l2<true>(v, op2, r.v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void shift_r(unsigned op2, iv<Nr, Cr>& r) const
         {
            iv_shift_r(v, op2, r.v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void shift_r2(signed op2, iv<Nr, Cr>& r) const
         {
            iv_shift_r2<true>(v, op2, r.v);
         }
         template <int B, int Nr, bool Cr>
         __attribute__((always_inline)) inline constexpr void const_shift_l(iv<Nr, Cr>& r) const
         {
            iv_const_shift_l<B>(v, r.v);
         }
         template <int B, int Nr, bool Cr>
         __attribute__((always_inline)) inline void const_shift_r(iv<Nr, Cr>& r) const
         {
            iv_const_shift_r<B>(v, r.v);
         }
         template <int Nr, bool Cr>
         __attribute__((always_inline)) inline void bitwise_complement(iv<Nr, Cr>& r) const
         {
            iv_bitwise_complement(v, r.v);
         }
         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void bitwise_and(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_bitwise_and(v, op2.v, r.v);
         }
         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void bitwise_or(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_bitwise_or(v, op2.v, r.v);
         }
         template <int N2, bool C2, int Nr, bool Cr>
         __attribute__((always_inline)) inline void bitwise_xor(const iv<N2, C2>& op2, iv<Nr, Cr>& r) const
         {
            iv_bitwise_xor(v, op2.v, r.v);
         }
         template <int N2, bool C2>
         __attribute__((always_inline)) inline bool equal(const iv<N2, C2>& op2) const
         {
            return iv_equal(v, op2.v);
         }
         template <int N2, bool C2>
         __attribute__((always_inline)) inline bool greater_than(const iv<N2, C2>& op2) const
         {
            return iv_compare<true>(v, op2.v);
         }
         template <int N2, bool C2>
         __attribute__((always_inline)) inline bool less_than(const iv<N2, C2>& op2) const
         {
            return iv_compare<false>(v, op2.v);
         }
         __attribute__((always_inline)) inline bool equal_zero() const
         {
            return iv_equal_zero<0, N>(v);
         }
         template <int N2, bool C2>
         __attribute__((always_inline)) inline constexpr void set_slc(unsigned lsb, int WS, const iv<N2, C2>& op2)
         {
            ;
            unsigned msb = lsb + WS - 1;
            unsigned lsb_v = lsb >> 5;
            unsigned lsb_b = lsb & 31;
            unsigned msb_v = msb >> 5;
            unsigned msb_b = msb & 31;
            if(N2 == 1)
            {
               if(msb_v == lsb_v)
                  v.set(lsb_v,
                        v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & ((WS == 32 ? ~0 : ((1u << WS) - 1)) << lsb_b)));
               else
               {
                  v.set(lsb_v, v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & (all_ones << lsb_b)));
                  unsigned m = (((unsigned)op2.v[0] >> 1) >> (31 - lsb_b));
                  v.set(msb_v, v[msb_v] ^ ((v[msb_v] ^ m) & ~((all_ones << 1) << msb_b)));
               }
            }
            else
            {
               v.set(lsb_v, v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & (all_ones << lsb_b)));
               if(1 <= N2 - 1) { for(int i = 1; i < N2 - 1 + (exclude == loop_limit::include); ++i) {
#pragma HLS UNROLL
# 2563 "../../../ac_types/include/ac_int.h"
               { v.set(lsb_v + i, (op2.v[i] << lsb_b) | (((unsigned)op2.v[i - 1] >> 1) >> (31 - lsb_b))); } } } else { for(int i = 1; i >= N2 - 1 + (exclude == loop_limit::exclude); --i) {
#pragma HLS UNROLL
# 2563 "../../../ac_types/include/ac_int.h"
               { v.set(lsb_v + i, (op2.v[i] << lsb_b) | (((unsigned)op2.v[i - 1] >> 1) >> (31 - lsb_b))); } } }
                                                                                                                 ;
               unsigned t = (op2.v[N2 - 1] << lsb_b) | (((unsigned)op2.v[N2 - 2] >> 1) >> (31 - lsb_b));
               unsigned m = t;
               if(msb_v - lsb_v == N2)
               {
                  v.set(msb_v - 1, t);
                  m = (((unsigned)op2.v[N2 - 1] >> 1) >> (31 - lsb_b));
               }
               else
                  m = t;
               v.set(msb_v, v[msb_v] ^ ((v[msb_v] ^ m) & ~((all_ones << 1) << msb_b)));
            }
         }

         template <int N_2, bool C_2>
         __attribute__((always_inline)) inline constexpr void set_slc2(unsigned lsb, int WS, const iv<N_2, C_2>& op2)
         {
            ;
            const int N2 = (31 + WS) / 32;
            unsigned msb = lsb + WS - 1;
            unsigned lsb_v = lsb >> 5;
            unsigned lsb_b = lsb & 31;
            unsigned msb_v = msb >> 5;
            unsigned msb_b = msb & 31;
            if(N2 == 1)
            {
               if(msb_v == lsb_v)
                  v.set(lsb_v,
                        v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & ((WS == 32 ? ~0 : ((1u << WS) - 1)) << lsb_b)));
               else
               {
                  v.set(lsb_v, v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & (all_ones << lsb_b)));
                  unsigned m = (((unsigned)op2.v[0] >> 1) >> (31 - lsb_b));
                  v.set(msb_v, v[msb_v] ^ ((v[msb_v] ^ m) & ~((all_ones << 1) << msb_b)));
               }
            }
            else
            {
               v.set(lsb_v, v[lsb_v] ^ ((v[lsb_v] ^ (op2.v[0] << lsb_b)) & (all_ones << lsb_b)));
               if(1 <= N2 - 1) { for(int i = 1; i < N2 - 1 + (exclude == loop_limit::include); ++i) {
#pragma HLS UNROLL
# 2603 "../../../ac_types/include/ac_int.h"
               { v.set(lsb_v + i, (op2.v[i] << lsb_b) | (((unsigned)op2.v[i - 1] >> 1) >> (31 - lsb_b))); } } } else { for(int i = 1; i >= N2 - 1 + (exclude == loop_limit::exclude); --i) {
#pragma HLS UNROLL
# 2603 "../../../ac_types/include/ac_int.h"
               { v.set(lsb_v + i, (op2.v[i] << lsb_b) | (((unsigned)op2.v[i - 1] >> 1) >> (31 - lsb_b))); } } }
                                                                                                                 ;
               unsigned t = (op2.v[N2 - 1] << lsb_b) | (((unsigned)op2.v[N2 - 2] >> 1) >> (31 - lsb_b));
               unsigned m = 0;
               if(static_cast<int>(msb_v - lsb_v) == N2)
               {
                  v.set(msb_v - 1, t);
                  m = (((unsigned)op2.v[N2 - 1] >> 1) >> (31 - lsb_b));
               }
               else
                  m = t;
               v.set(msb_v, v[msb_v] ^ ((v[msb_v] ^ m) & ~((all_ones << 1) << msb_b)));
            }
         }
         unsigned leading_bits(bool bit) const
         {
            return iv_leading_bits(v, bit);
         }
      };

      template <>
      template <>
      __attribute__((always_inline)) inline constexpr void iv<1, false>::set_slc(unsigned lsb, int WS, const iv<1, false>& op2)
      {
         v.set(0, v[0] ^ ((v[0] ^ ((unsigned)op2.v[0] << lsb)) & ((WS == 32 ? ~0u : ((1u << WS) - 1)) << lsb)));
      }
      template <>
      template <>
      __attribute__((always_inline)) inline constexpr void iv<2, false>::set_slc(unsigned lsb, int WS, const iv<1, false>& op2)
      {
         Ulong l = to_uint64();
         Ulong l2 = op2.to_uint64();
         l ^= (l ^ (l2 << lsb)) & (((1ULL << WS) - 1) << lsb);
         *this = iv(l);
      }
      template <>
      template <>
      __attribute__((always_inline)) inline constexpr void iv<2, false>::set_slc(unsigned lsb, int WS, const iv<2, false>& op2)
      {
         Ulong l = to_uint64();
         Ulong l2 = op2.to_uint64();
         l ^= (l ^ (l2 << lsb)) & ((WS == 64 ? ~0ULL : ((1ULL << WS) - 1)) << lsb);
         *this = iv(l);
      }


      template <int N, bool S, bool LTE64, bool C, int W>
      class iv_conv : public iv<N, C>
      {
       protected:
         __attribute__((always_inline)) inline
         constexpr iv_conv()
         {
         }
         template <class T>
         __attribute__((always_inline)) inline constexpr iv_conv(const T& t) : iv<N, C>(t)
         {
         }
      };

      template <int N, bool C, int W>
      class iv_conv<N, false, true, C, W> : public iv<N, C>
      {
       public:
         __attribute__((always_inline)) inline
         operator Ulong() const
         {
            auto res = iv<N, C>::to_uint64();
            if(W != 64)
               res = (res << (64 - W)) >> (64 - W);
            return res;
         }

       protected:
         __attribute__((always_inline)) inline
         constexpr iv_conv()
         {
         }
         template <class T>
         __attribute__((always_inline)) inline constexpr iv_conv(const T& t) : iv<N, C>(t)
         {
         }
      };

      template <int N, bool C, int W>
      class iv_conv<N, true, true, C, W> : public iv<N, C>
      {
       public:
         __attribute__((always_inline)) inline
         operator Slong() const
         {
            auto res = iv<N, C>::to_int64();
            if(W != 64)
               res = (res << (64 - W)) >> (64 - W);
            return res;
         }

       protected:
         __attribute__((always_inline)) inline
         constexpr iv_conv()
         {
         }
         template <class T>
         __attribute__((always_inline)) inline constexpr iv_conv(const T& t) : iv<N, C>(t)
         {
         }
      };



      template <typename T>
      struct c_prom
      {
         typedef int promoted_type;
      };
      template <>
      struct c_prom<unsigned>
      {
         typedef unsigned promoted_type;
      };
      template <>
      struct c_prom<long>
      {
         typedef long promoted_type;
      };
      template <>
      struct c_prom<unsigned long>
      {
         typedef unsigned long promoted_type;
      };
      template <>
      struct c_prom<Slong>
      {
         typedef Slong promoted_type;
      };
      template <>
      struct c_prom<Ulong>
      {
         typedef Ulong promoted_type;
      };
      template <>
      struct c_prom<float>
      {
         typedef float promoted_type;
      };
      template <>
      struct c_prom<double>
      {
         typedef double promoted_type;
      };

      template <typename T, typename T2>
      struct c_arith
      {


      };
      template <typename T>
      struct c_arith<T, T>
      {
         typedef T arith_conv;
      };
# 2778 "../../../ac_types/include/ac_int.h"
      template <> struct c_arith<double, float> { typedef double arith_conv; }; template <> struct c_arith<float, double> { typedef double arith_conv; };
      template <> struct c_arith<double, int> { typedef double arith_conv; }; template <> struct c_arith<int, double> { typedef double arith_conv; };
      template <> struct c_arith<double, unsigned> { typedef double arith_conv; }; template <> struct c_arith<unsigned, double> { typedef double arith_conv; };
      template <> struct c_arith<double, long> { typedef double arith_conv; }; template <> struct c_arith<long, double> { typedef double arith_conv; };
      template <> struct c_arith<double, unsigned long> { typedef double arith_conv; }; template <> struct c_arith<unsigned long, double> { typedef double arith_conv; };
      template <> struct c_arith<double, Slong> { typedef double arith_conv; }; template <> struct c_arith<Slong, double> { typedef double arith_conv; };
      template <> struct c_arith<double, Ulong> { typedef double arith_conv; }; template <> struct c_arith<Ulong, double> { typedef double arith_conv; };
      template <> struct c_arith<float, int> { typedef float arith_conv; }; template <> struct c_arith<int, float> { typedef float arith_conv; };
      template <> struct c_arith<float, unsigned> { typedef float arith_conv; }; template <> struct c_arith<unsigned, float> { typedef float arith_conv; };
      template <> struct c_arith<float, long> { typedef float arith_conv; }; template <> struct c_arith<long, float> { typedef float arith_conv; };
      template <> struct c_arith<float, unsigned long> { typedef float arith_conv; }; template <> struct c_arith<unsigned long, float> { typedef float arith_conv; };
      template <> struct c_arith<float, Slong> { typedef float arith_conv; }; template <> struct c_arith<Slong, float> { typedef float arith_conv; };
      template <> struct c_arith<float, Ulong> { typedef float arith_conv; }; template <> struct c_arith<Ulong, float> { typedef float arith_conv; };

      template <> struct c_arith<Slong, int> { typedef Slong arith_conv; }; template <> struct c_arith<int, Slong> { typedef Slong arith_conv; };
      template <> struct c_arith<Slong, unsigned> { typedef Slong arith_conv; }; template <> struct c_arith<unsigned, Slong> { typedef Slong arith_conv; };
      template <> struct c_arith<Ulong, int> { typedef Ulong arith_conv; }; template <> struct c_arith<int, Ulong> { typedef Ulong arith_conv; };
      template <> struct c_arith<Ulong, unsigned> { typedef Ulong arith_conv; }; template <> struct c_arith<unsigned, Ulong> { typedef Ulong arith_conv; };

      template <typename T>
      struct map
      {
         typedef T t;
      };
      template <typename T>
      struct c_type_params
      {

      };

      template <typename T>
      __attribute__((always_inline)) inline const char* c_type_name()
      {
         return "unknown";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<bool>()
      {
         return "bool";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<char>()
      {
         return "char";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<signed char>()
      {
         return "signed char";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<unsigned char>()
      {
         return "unsigned char";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<signed short>()
      {
         return "signed short";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<unsigned short>()
      {
         return "unsigned short";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<int>()
      {
         return "int";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<unsigned>()
      {
         return "unsigned";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<signed long>()
      {
         return "signed long";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<unsigned long>()
      {
         return "unsigned long";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<signed long long>()
      {
         return "signed long long";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<unsigned long long>()
      {
         return "unsigned long long";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<float>()
      {
         return "float";
      }
      template <>
      __attribute__((always_inline)) inline const char* c_type_name<double>()
      {
         return "double";
      }

      template <typename T>
      struct c_type;

      template <typename T>
      struct rt_c_type_T
      {
         template <typename T2>
         struct op1
         {
            typedef typename T::template rt_T<c_type<T2>>::mult mult;
            typedef typename T::template rt_T<c_type<T2>>::plus plus;
            typedef typename T::template rt_T<c_type<T2>>::minus2 minus;
            typedef typename T::template rt_T<c_type<T2>>::minus minus2;
            typedef typename T::template rt_T<c_type<T2>>::logic logic;
            typedef typename T::template rt_T<c_type<T2>>::div2 div;
            typedef typename T::template rt_T<c_type<T2>>::div div2;
         };
      };
      template <typename T>
      struct c_type
      {
         typedef typename c_prom<T>::promoted_type c_prom_T;
         struct rt_unary
         {
            typedef c_prom_T neg;
            typedef c_prom_T mag_sqr;
            typedef c_prom_T mag;
            template <unsigned N>
            struct set
            {
               typedef c_prom_T sum;
            };
         };
         template <typename T2>
         struct rt_T
         {
            typedef typename rt_c_type_T<T2>::template op1<T>::mult mult;
            typedef typename rt_c_type_T<T2>::template op1<T>::plus plus;
            typedef typename rt_c_type_T<T2>::template op1<T>::minus minus;
            typedef typename rt_c_type_T<T2>::template op1<T>::minus2 minus2;
            typedef typename rt_c_type_T<T2>::template op1<T>::logic logic;
            typedef typename rt_c_type_T<T2>::template op1<T>::div div;
            typedef typename rt_c_type_T<T2>::template op1<T>::div2 div2;
         };
         __attribute__((always_inline)) inline static std::string type_name()
         {
            std::string r = c_type_name<T>();
            return r;
         }
      };

      template <typename T>
      struct rt_c_type_T<c_type<T>>
      {
         typedef typename c_prom<T>::promoted_type c_prom_T;
         template <typename T2>
         struct op1
         {
            typedef typename c_prom<T2>::promoted_type c_prom_T2;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv mult;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv plus;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv minus;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv minus2;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv logic;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv div;
            typedef typename c_arith<c_prom_T, c_prom_T2>::arith_conv div2;
         };
      };
# 2993 "../../../ac_types/include/ac_int.h"
      template <> struct map<bool> { typedef c_type<bool> t; }; template <> struct c_type_params<bool> { enum { W = 1, I = 1, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<char> { typedef c_type<char> t; }; template <> struct c_type_params<char> { enum { W = 8, I = 8, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<signed char> { typedef c_type<signed char> t; }; template <> struct c_type_params<signed char> { enum { W = 8, I = 8, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<unsigned char> { typedef c_type<unsigned char> t; }; template <> struct c_type_params<unsigned char> { enum { W = 8, I = 8, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<signed short> { typedef c_type<signed short> t; }; template <> struct c_type_params<signed short> { enum { W = 16, I = 16, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<unsigned short> { typedef c_type<unsigned short> t; }; template <> struct c_type_params<unsigned short> { enum { W = 16, I = 16, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<signed int> { typedef c_type<signed int> t; }; template <> struct c_type_params<signed int> { enum { W = 32, I = 32, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<unsigned int> { typedef c_type<unsigned int> t; }; template <> struct c_type_params<unsigned int> { enum { W = 32, I = 32, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<signed long> { typedef c_type<signed long> t; }; template <> struct c_type_params<signed long> { enum { W = ac_private::long_w, I = ac_private::long_w, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<unsigned long> { typedef c_type<unsigned long> t; }; template <> struct c_type_params<unsigned long> { enum { W = ac_private::long_w, I = ac_private::long_w, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<signed long long> { typedef c_type<signed long long> t; }; template <> struct c_type_params<signed long long> { enum { W = 64, I = 64, E = 0, S = true, floating_point = 0 }; };
      template <> struct map<unsigned long long> { typedef c_type<unsigned long long> t; }; template <> struct c_type_params<unsigned long long> { enum { W = 64, I = 64, E = 0, S = false, floating_point = 0 }; };
      template <> struct map<float> { typedef c_type<float> t; }; template <> struct c_type_params<float> { enum { W = 25, I = 1, E = 8, S = true, floating_point = 1 }; };
      template <> struct map<double> { typedef c_type<double> t; }; template <> struct c_type_params<double> { enum { W = 54, I = 1, E = 11, S = true, floating_point = 2 }; };
# 3015 "../../../ac_types/include/ac_int.h"
      template <typename T>
      struct rt_ac_int_T
      {
         template <int W, bool S>
         struct op1
         {
            typedef typename T::template rt_T<ac_int<W, S>>::mult mult;
            typedef typename T::template rt_T<ac_int<W, S>>::plus plus;
            typedef typename T::template rt_T<ac_int<W, S>>::minus2 minus;
            typedef typename T::template rt_T<ac_int<W, S>>::minus minus2;
            typedef typename T::template rt_T<ac_int<W, S>>::logic logic;
            typedef typename T::template rt_T<ac_int<W, S>>::div2 div;
            typedef typename T::template rt_T<ac_int<W, S>>::div div2;
         };
      };
   }

   namespace ac
   {

      template <unsigned X>
      struct nbits
      {
         enum
         {
            val = ac_private::s_N<16>::s_X<X>::nbits
         };
      };

      template <unsigned X>
      struct log2_floor
      {
         enum
         {
            val = nbits<X>::val - 1
         };
      };


      template <>
      struct log2_floor<0>
      {
      };

      template <unsigned X>
      struct log2_ceil
      {
         enum
         {
            lf = log2_floor<X>::val,
            val = (X == (1 << lf) ? lf : lf + 1)
         };
      };


      template <>
      struct log2_ceil<0>
      {
      };

      template <int LowerBound, int UpperBound>
      struct int_range
      {
         enum
         {
            l_s = (LowerBound < 0),
            u_s = (UpperBound < 0),
            signedness = l_s || u_s,
            l_nbits = nbits<((LowerBound + l_s) < 0 ? (-LowerBound + l_s) : (LowerBound + l_s)) + l_s>::val,
            u_nbits = nbits<((UpperBound + u_s) < 0 ? (-UpperBound + u_s) : (UpperBound + u_s)) + u_s>::val,
            nbits = ((l_nbits) > (u_nbits + (!u_s && signedness)) ? (l_nbits) : (u_nbits + (!u_s && signedness)))
         };
         typedef ac_int<nbits, signedness> type;
      };
   }

   enum ac_q_mode
   {
      AC_TRN,
      AC_RND,
      AC_TRN_ZERO,
      AC_RND_ZERO,
      AC_RND_INF,
      AC_RND_MIN_INF,
      AC_RND_CONV,
      AC_RND_CONV_ODD
   };
   enum ac_o_mode
   {
      AC_WRAP,
      AC_SAT,
      AC_SAT_ZERO,
      AC_SAT_SYM
   };
   template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
   class ac_fixed;
   template <int W1, bool S1>
   struct range_ref;





   template <int W, bool S = true>
   class ac_int : public ac_private::iv_conv<(W + 31 + !S) / 32, S, W <= 64, !S && ((W % 32) == 0), W>



   {
      enum
      {
         N = (W + 31 + !S) / 32
      };
      typedef ac_private::iv_conv<N, S, W <= 64, !S && ((W % 32) == 0), W> ConvBase;
      typedef ac_private::iv<N, !S && ((W % 32) == 0)> Base;

      __attribute__((always_inline)) inline constexpr void bit_adjust()
      {
         Base::v.template bit_adjust<W, S>();
      }
      template <size_t N>
      __attribute__((always_inline)) inline void bit_fill(const char (&str)[N])
      {
         if(str[0] == '0' && str[1] == 'x')
            bit_fill_hex(str, 2);
         if(str[0] == '0' && str[1] == 'o')
            bit_fill_oct(str, 2);
         else if(str[0] == '0' && str[1] == 'b')
            bit_fill_bin(str, 2);
         else
            ;
      }
      __attribute__((always_inline)) inline bool is_neg() const
      {
         return S && Base::v[N - 1] < 0;
      }


      template <int WE, bool SE>
      __attribute__((always_inline)) inline bool normalize_private(ac_int<WE, SE>& exp, bool reserved_min_exp = false)
      {
         int expt = exp;
         int lshift = leading_sign();
         bool fully_normalized = true;
         ac_int<WE, SE> min_exp;
         min_exp.template set_val<AC_VAL_MIN>();
         int max_shift = exp - min_exp - reserved_min_exp;
         if(lshift > max_shift)
         {
            lshift = ac_int<WE, false>(max_shift);
            expt = min_exp + reserved_min_exp;
            fully_normalized = false;
         }
         else
         {
            expt -= lshift;
         }
         if(Base::equal_zero())
         {
            expt = 0;
            fully_normalized = true;
         }
         exp = expt;
         Base r;
         Base::shift_l(lshift, r);
         Base::operator=(r);
         bit_adjust();
         return fully_normalized;
      }

    public:
      static const int width = W;
      static const int i_width = W;
      static const bool sign = S;
      static const ac_q_mode q_mode = AC_TRN;
      static const ac_o_mode o_mode = AC_WRAP;
      static const int e_width = 0;

      template <int W2, bool S2>
      struct rt
      {
         enum
         {
            mult_w = W + W2,
            mult_s = S || S2,
            plus_w = ((W + (S2 && !S)) > (W2 + (S && !S2)) ? (W + (S2 && !S)) : (W2 + (S && !S2))) + 1,
            plus_s = S || S2,
            minus_w = ((W + (S2 && !S)) > (W2 + (S && !S2)) ? (W + (S2 && !S)) : (W2 + (S && !S2))) + 1,
            minus_s = true,
            div_w = W + S2,
            div_s = S || S2,
            mod_w = ((W) < (W2 + (!S2 && S)) ? (W) : (W2 + (!S2 && S))),
            mod_s = S,
            logic_w = ((W + (S2 && !S)) > (W2 + (S && !S2)) ? (W + (S2 && !S)) : (W2 + (S && !S2))),
            logic_s = S || S2
         };
         typedef ac_int<mult_w, mult_s> mult;
         typedef ac_int<plus_w, plus_s> plus;
         typedef ac_int<minus_w, minus_s> minus;
         typedef ac_int<logic_w, logic_s> logic;
         typedef ac_int<div_w, div_s> div;
         typedef ac_int<mod_w, mod_s> mod;
         typedef ac_int<W, S> arg1;
      };

      template <typename T>
      struct rt_T
      {
         typedef typename ac_private::map<T>::t map_T;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::mult mult;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::plus plus;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::minus minus;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::minus2 minus2;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::logic logic;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::div div;
         typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W, S>::div2 div2;
         typedef ac_int<W, S> arg1;
      };

      struct rt_unary
      {
         enum
         {
            neg_w = W + 1,
            neg_s = true,
            mag_sqr_w = 2 * W - S,
            mag_sqr_s = false,
            mag_w = W + S,
            mag_s = false,
            leading_sign_w = ac::log2_ceil<W + !S>::val,
            leading_sign_s = false
         };
         typedef ac_int<neg_w, neg_s> neg;
         typedef ac_int<mag_sqr_w, mag_sqr_s> mag_sqr;
         typedef ac_int<mag_w, mag_s> mag;
         typedef ac_int<leading_sign_w, leading_sign_s> leading_sign;
         template <unsigned N>
         struct set
         {
            enum
            {
               sum_w = W + ac::log2_ceil<N>::val,
               sum_s = S
            };
            typedef ac_int<sum_w, sum_s> sum;
         };
      };

      template <int W2, bool S2>
      friend class ac_int;
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      friend class ac_fixed;

      __attribute__((always_inline)) inline
      constexpr ac_int()
      {



      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_int(const ac_int<W2, S2>& op)
      {
         Base::operator=(op);
         bit_adjust();
      }

      __attribute__((always_inline)) inline constexpr ac_int(bool b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(char b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(signed char b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(unsigned char b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(signed short b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(unsigned short b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(signed int b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(unsigned int b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(signed long b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(unsigned long b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(Slong b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(Ulong b) : ConvBase(b)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(float d) : ConvBase(d)
      {
         bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_int(double d) : ConvBase(d)
      {
         bit_adjust();
      }

      template <size_t N>
      __attribute__((always_inline)) inline constexpr ac_int(const char (&str)[N])
      {
         bit_fill(str);
         bit_adjust();
      }






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"





      template <ac_special_val V>
      __attribute__((always_inline)) inline ac_int& set_val()
      {
         if(V == AC_VAL_DC)
         {


            bit_adjust();
         }
         else if(V == AC_VAL_0 || V == AC_VAL_MIN || V == AC_VAL_QUANTUM)
         {
            Base::operator=(0);
            if(S && V == AC_VAL_MIN)
            {
               const unsigned int rem = (W - 1) & 31;
               Base::v.set(N - 1, (~0u << rem));
            }
            else if(V == AC_VAL_QUANTUM)
               Base::v.set(0, 1);
         }
         else if(V == AC_VAL_MAX)
         {
            Base::operator=(-1);
            const unsigned int rem = (32 - W - (unsigned)!S) & 31;
            Base::v.set(N - 1, ((unsigned)(-1) >> 1) >> rem);
         }
         return *this;
      }




#pragma GCC diagnostic pop






      __attribute__((always_inline)) inline int to_int() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         return op1_local.v[0];
      }
      __attribute__((always_inline)) inline unsigned to_uint() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         return op1_local.v[0];
      }
      __attribute__((always_inline)) inline long to_long() const
      {
         return ac_private::long_w == 32 ? (long)Base::v[0] : (long)Base::to_int64();
      }
      __attribute__((always_inline)) inline unsigned long to_ulong() const
      {
         return ac_private::long_w == 32 ? (unsigned long)Base::v[0] : (unsigned long)Base::to_uint64();
      }
      __attribute__((always_inline)) inline constexpr Slong to_int64() const
      {
         return Base::to_int64();
      }
      __attribute__((always_inline)) inline constexpr Ulong to_uint64() const
      {
         return Base::to_uint64();
      }
      __attribute__((always_inline)) inline double to_double() const
      {
         return Base::to_double();
      }
      __attribute__((always_inline)) inline float to_float() const
      {
         return Base::to_float();
      }
      __attribute__((always_inline)) inline int length() const
      {
         return W;
      }

      __attribute__((always_inline)) inline explicit operator bool() const
      {
         return !Base::equal_zero();
      }

      __attribute__((always_inline)) inline explicit operator char() const
      {
         return (char)to_int();
      }

      __attribute__((always_inline)) inline explicit operator signed char() const
      {
         return (signed char)to_int();
      }

      __attribute__((always_inline)) inline explicit operator unsigned char() const
      {
         return (unsigned char)to_uint();
      }

      __attribute__((always_inline)) inline explicit operator short() const
      {
         return (short)to_int();
      }

      __attribute__((always_inline)) inline explicit operator unsigned short() const
      {
         return (unsigned short)to_uint();
      }
      __attribute__((always_inline)) inline explicit operator int() const
      {
         return to_int();
      }
      __attribute__((always_inline)) inline explicit operator unsigned() const
      {
         return to_uint();
      }
      __attribute__((always_inline)) inline explicit operator long() const
      {
         return to_long();
      }
      __attribute__((always_inline)) inline explicit operator unsigned long() const
      {
         return to_ulong();
      }
      __attribute__((always_inline)) inline explicit operator double() const
      {
         return to_double();
      }
      __attribute__((always_inline)) inline explicit operator float() const
      {
         return to_float();
      }

      __attribute__((always_inline)) inline std::string to_string(ac_base_mode base_rep, bool sign_mag = false) const
      {


         char r[N * 32 + 4] = {0};
         int i = 0;
         if(sign_mag)
            r[i++] = is_neg() ? '-' : '+';
         else if(base_rep == AC_DEC && is_neg())
            r[i++] = '-';
         if(base_rep != AC_DEC)
         {
            r[i++] = '0';
            r[i++] = base_rep == AC_BIN ? 'b' : (base_rep == AC_OCT ? 'o' : 'x');
         }
         int str_w;
         if((base_rep == AC_DEC || sign_mag) && is_neg())
         {
            ac_int<W, false> mag = operator-();
            str_w = ac_private::to_string(mag.v, W + 1, sign_mag, base_rep, false, r + i);
         }
         else
         {
            ac_int<W, S> tmp = *this;
            str_w = ac_private::to_string(tmp.v, W + !S, sign_mag, base_rep, false, r + i);
         }
         if(!str_w)
         {
            r[i] = '0';
            r[i + 1] = 0;
         }
         return std::string(r);
      }
      __attribute__((always_inline)) inline
      static std::string type_name()
      {
         const char* tf[] = {",false>", ",true>"};
         std::string r = "ac_int<";
         r += ac_int<32, true>(W).to_string(AC_DEC);
         r += tf[S];
         return r;
      }


      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::mult operator*(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::mult r;
         op1_local.Base::mult(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::plus operator+(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::plus r;
         op1_local.Base::add(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::minus operator-(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::minus r;
         op1_local.Base::sub(op2_local, r);
         r.bit_adjust();
         return r;
      }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wenum-compare"


      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::div operator/(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::div r;
         enum
         {
            Nminus = ac_int<W + S, S>::N,
            N2 = ac_int<W2, S2>::N,
            N2minus = ac_int<W2 + S2, S2>::N,
            num_s = S + (Nminus > N),
            den_s = S2 + (N2minus > N2),
            Nr = rt<W2, S2>::div::N
         };
         op1_local.Base::template div<num_s, den_s>(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::mod operator%(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::mod r;
         enum
         {
            Nminus = ac_int<W + S, S>::N,
            N2 = ac_int<W2, S2>::N,
            N2minus = ac_int<W2 + S2, S2>::N,
            num_s = S + (Nminus > N),
            den_s = S2 + (N2minus > N2),
            Nr = rt<W2, S2>::mod::N
         };
         op1_local.Base::template rem<num_s, den_s>(op2_local, r);
         r.bit_adjust();
         return r;
      }

#pragma GCC diagnostic pop


      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator*=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::mult(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator+=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::add(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator-=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::sub(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wenum-compare"

      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator/=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         enum
         {
            Nminus = ac_int<W + S, S>::N,
            N2 = ac_int<W2, S2>::N,
            N2minus = ac_int<W2 + S2, S2>::N,
            num_s = S + (Nminus > N),
            den_s = S2 + (N2minus > N2),
            Nr = N
         };
         Base r;
         Base::template div<num_s, den_s>(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator%=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         enum
         {
            Nminus = ac_int<W + S, S>::N,
            N2 = ac_int<W2, S2>::N,
            N2minus = ac_int<W2 + S2, S2>::N,
            num_s = S + (Nminus > N),
            den_s = S2 + (N2minus > N2),
            Nr = N
         };
         Base r;
         Base::template rem<num_s, den_s>(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }

#pragma GCC diagnostic pop


      __attribute__((always_inline)) inline ac_int& operator++()
      {
         bit_adjust();
         Base::increment();
         bit_adjust();
         return *this;
      }
      __attribute__((always_inline)) inline ac_int& operator--()
      {
         bit_adjust();
         Base::decrement();
         bit_adjust();
         return *this;
      }

      __attribute__((always_inline)) inline const ac_int operator++(int)
      {
         bit_adjust();
         ac_int t = *this;
         Base::increment();
         t.bit_adjust();
         return t;
      }
      __attribute__((always_inline)) inline const ac_int operator--(int)
      {
         bit_adjust();
         ac_int t = *this;
         Base::decrement();
         t.bit_adjust();
         return t;
      }

      __attribute__((always_inline)) inline const ac_int operator+() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         return op1_local;
      }
      __attribute__((always_inline)) inline const typename rt_unary::neg operator-() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         typename rt_unary::neg r;
         op1_local.Base::neg(r);
         r.bit_adjust();
         return r;
      }

      __attribute__((always_inline)) inline bool operator!() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         return op1_local.Base::equal_zero();
      }
      __attribute__((always_inline)) inline const ac_int<W + !S, true> operator~() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W + !S, true> r;
         op1_local.Base::bitwise_complement(r);
         r.bit_adjust();
         return r;
      }

      __attribute__((always_inline)) inline const ac_int<W, false> bit_complement() const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W, false> r;
         op1_local.Base::bitwise_complement(r);
         r.bit_adjust();
         return r;
      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::logic operator&(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::logic r;
         op1_local.Base::bitwise_and(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::logic operator|(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::logic r;
         op1_local.Base::bitwise_or(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const typename rt<W2, S2>::logic operator^(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, S2>::logic r;
         op1_local.Base::bitwise_xor(op2_local, r);
         r.bit_adjust();
         return r;
      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator&=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::bitwise_and(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator|=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::bitwise_or(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_int& operator^=(const ac_int<W2, S2>& op2)
      {
         bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::bitwise_xor(op2_local, r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }

      template <int W2>
      __attribute__((always_inline)) inline const ac_int operator<<(const ac_int<W2, true>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, true> op2_local = op2;
         op2_local.bit_adjust();
         ac_int r;
         op1_local.Base::shift_l2(op2_local.to_int(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline const ac_int operator<<(const ac_int<W2, false>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, false> op2_local = op2;
         op2_local.bit_adjust();
         ac_int r;
         op1_local.Base::shift_l(op2_local.to_uint(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline const ac_int operator>>(const ac_int<W2, true>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, true> op2_local = op2;
         op2_local.bit_adjust();
         ac_int r;
         op1_local.Base::shift_r2(op2_local.to_int(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline const ac_int operator>>(const ac_int<W2, false>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, false> op2_local = op2;
         op2_local.bit_adjust();
         ac_int r;
         op1_local.Base::shift_r(op2_local.to_uint(), r);
         r.bit_adjust();
         return r;
      }


      template <int W2>
      __attribute__((always_inline)) inline ac_int& operator<<=(const ac_int<W2, true>& op2)
      {
         bit_adjust();
         ac_int<W2, true> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::shift_l2(op2_local.to_int(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_int& operator<<=(const ac_int<W2, false>& op2)
      {
         bit_adjust();
         ac_int<W2, false> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::shift_l(op2_local.to_uint(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_int& operator>>=(const ac_int<W2, true>& op2)
      {
         bit_adjust();
         ac_int<W2, true> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::shift_r2(op2_local.to_int(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_int& operator>>=(const ac_int<W2, false>& op2)
      {
         bit_adjust();
         ac_int<W2, false> op2_local = op2;
         op2_local.bit_adjust();
         Base r;
         Base::shift_r(op2_local.to_uint(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator==(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return op1_local.Base::equal(op2_local);
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator!=(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return !op1_local.Base::equal(op2_local);
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator<(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return op1_local.Base::less_than(op2_local);
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator>=(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return !op1_local.Base::less_than(op2_local);
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator>(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return op1_local.Base::greater_than(op2);
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator<=(const ac_int<W2, S2>& op2) const
      {
         ac_int<W, S> op1_local = *this;
         op1_local.bit_adjust();
         ac_int<W2, S2> op2_local = op2;
         op2_local.bit_adjust();
         return !op1_local.Base::greater_than(op2_local);
      }


      template <int WS, int WX, bool SX>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(const ac_int<WX, SX>& index) const
      {
         using ac_intX = ac_int<WX, SX>;
         ac_int<WS, S> r;
         ;
         ac_int<WX - SX, false> uindex = index;
         Base::shift_r(uindex.to_uint(), r);
         r.bit_adjust();
         return r;
      }
      __attribute__((always_inline)) inline
      ac_int<W, S> operator()(int Hi, int Lo) const
      {
         return slc(Hi, Lo);
      }

      __attribute__((always_inline)) inline
      range_ref<W, S> operator()(int Hi, int Lo)
      {
         return range_ref<W, S>(*this, Hi, Lo);
      }
      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline ac_int<W, S> operator()(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo) const
      {
         int Hi = _Hi.to_int();
         int Lo = _Lo.to_int();
         ;
         ;
         return operator()(Hi, Lo);
      }
      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline range_ref<W, S> operator()(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo)
      {
         int Hi = _Hi.to_int();
         int Lo = _Lo.to_int();
         ;
         ;
         return range_ref<W, S>(*this, Hi, Lo);
      }

      __attribute__((always_inline)) inline
      ac_int<W, S> range(int Hi, int Lo) const
      {
         return operator()(Hi, Lo);
      }
      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline ac_int<W, S> range(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo) const
      {
         return operator()(_Hi, _Lo);
      }
      __attribute__((always_inline)) inline
      range_ref<W, S> range(int Hi, int Lo)
      {
         return range_ref<W, S>(*this, Hi, Lo);
      }

      template <int WS>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(signed index) const
      {
         ac_int<WS, S> r;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         Base::shift_r(uindex, r);
         r.bit_adjust();
         return r;
      }
      template <int WS>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(unsigned uindex) const
      {
         ac_int<WS, S> r;
         Base::shift_r(uindex, r);
         r.bit_adjust();
         return r;
      }
      __attribute__((always_inline)) inline ac_int<W, S> slc(int Hi, int Lo) const
      {
         ;
         ;
         ;
         ;
         ac_int<W, false> r(*this);
         r = r << ac_int<W, false>(W - 1 - Hi);
         r.bit_adjust();
         return r >> ac_int<W, false>(Lo + W - 1 - Hi);
      }

      template <int W2, bool S2, int WX, bool SX>
      __attribute__((always_inline)) inline constexpr ac_int& set_slc(const ac_int<WX, SX> lsb, const ac_int<W2, S2>& slc)
      {
         ;
         ac_int<WX - SX, false> ulsb = lsb;
         Base::set_slc(ulsb.to_uint(), W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_int& set_slc(signed lsb, const ac_int<W2, S2>& slc)
      {
         ;
         unsigned ulsb = lsb & ((unsigned)~0 >> 1);
         Base::set_slc(ulsb, W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_int& set_slc(unsigned ulsb, const ac_int<W2, S2>& slc)
      {
         ;
         Base::set_slc(ulsb, W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_int& set_slc(int umsb, int ulsb, const ac_int<W2, S2>& slc)
      {
         ;
         Base::set_slc2(ulsb, umsb + 1 - ulsb, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }

      class ac_bitref
      {
         ac_int& d_bv;
         unsigned d_index;

       public:
         __attribute__((always_inline)) inline ac_bitref(ac_int* bv, unsigned index = 0) : d_bv(*bv), d_index(index)
         {
         }
         __attribute__((always_inline)) inline
         operator bool() const
         {
            return (d_index < W) ? (d_bv.v[d_index >> 5] >> (d_index & 31) & 1) : 0;
         }

         template <int W2, bool S2>
         __attribute__((always_inline)) inline operator ac_int<W2, S2>() const
         {
            return operator bool();
         }

         __attribute__((always_inline)) inline
         ac_bitref operator=(int val)
         {

            if(d_index < W)
            {

               unsigned pos = d_index >> 5;
               auto value = static_cast<unsigned>(d_bv.v[pos]);
               unsigned d_index_masked = d_index & 31;
               unsigned bool_val = val & 1;
               unsigned mask_0 = 1U << d_index_masked;
               unsigned mask_0_neg = ~mask_0;
               value &= mask_0_neg;
               value |= bool_val << d_index_masked;
               d_bv.v.set(d_index >> 5, static_cast<int>(value));
               d_bv.bit_adjust();
            }
            return *this;
         }
         template <int W2, bool S2>
         __attribute__((always_inline)) inline ac_bitref operator=(const ac_int<W2, S2>& val)
         {
            return operator=(val.to_int());
         }
         __attribute__((always_inline)) inline
         ac_bitref operator=(const ac_bitref& val)
         {
            return operator=((int)(bool)val);
         }
      };

      __attribute__((always_inline)) inline
      ac_bitref operator[](unsigned int uindex)
      {
         ;
         ac_bitref bvh(this, uindex);
         return bvh;
      }
      __attribute__((always_inline)) inline
      ac_bitref operator[](int index)
      {
         ;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         ac_bitref bvh(this, uindex);
         return bvh;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_bitref operator[](const ac_int<W2, S2>& index)
      {
         ;
         ;
         ac_int<W2 - S2, false> uindex = index;
         ac_bitref bvh(this, uindex.to_uint());
         return bvh;
      }
      __attribute__((always_inline)) inline
      constexpr bool operator[](unsigned int uindex) const
      {
         ;
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex & 31) & 1) : 0;
      }
      __attribute__((always_inline)) inline
      constexpr bool operator[](int index) const
      {
         ;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex & 31) & 1) : 0;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr bool operator[](const ac_int<W2, S2>& index) const
      {
         ;
         ;
         ac_int<W2 - S2, false> uindex = index;
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex.to_uint() & 31) & 1) : 0;
      }





      __attribute__((always_inline)) inline
      typename rt_unary::leading_sign leading_sign() const
      {
         unsigned ls = Base::leading_bits(S & (Base::v[N - 1] < 0)) - (32 * N - W) - S;
         return ls;
      }
      __attribute__((always_inline)) inline
      typename rt_unary::leading_sign leading_sign(bool& all_sign) const
      {
         unsigned ls = Base::leading_bits(S & (Base::v[N - 1] < 0)) - (32 * N - W) - S;
         all_sign = (ls == W - S);
         return ls;
      }

      template <int WE, bool SE>
      __attribute__((always_inline)) inline bool normalize(ac_int<WE, SE>& exp)
      {
         return normalize_private(exp);
      }


      template <int WE, bool SE>
      __attribute__((always_inline)) inline bool normalize_RME(ac_int<WE, SE>& exp)
      {
         return normalize_private(exp, true);
      }
      __attribute__((always_inline)) inline
      bool and_reduce() const
      {
         return ac_private::iv_equal_ones_to<W, N>(Base::v);
      }
      __attribute__((always_inline)) inline
      bool or_reduce() const
      {
         return !Base::equal_zero();
      }
      __attribute__((always_inline)) inline
      bool xor_reduce() const
      {
         unsigned r = Base::v[N - 1];
         if(S)
         {
            const unsigned rem = (32 - W) & 31;
            r = (r << rem) >> rem;
         }
         if(N > 1)
            r ^= Base::v[N - 2];
         if(N > 2)
         {
            if(0 <= N - 2) { for(int i = 0; i < N - 2 + (exclude == loop_limit::include); ++i) {
# 4289 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4289 "../../../ac_types/include/ac_int.h"
            { r ^= Base::v[i]; } } } else { for(int i = 0; i >= N - 2 + (exclude == loop_limit::exclude); --i) {
# 4289 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4289 "../../../ac_types/include/ac_int.h"
            { r ^= Base::v[i]; } } };
         }
         if(W > 16)
            r ^= r >> 16;
         if(W > 8)
            r ^= r >> 8;
         if(W > 4)
            r ^= r >> 4;
         if(W > 2)
            r ^= r >> 2;
         if(W > 1)
            r ^= r >> 1;
         return r & 1;
      }

      template <size_t NN>
      __attribute__((always_inline)) inline constexpr void bit_fill_bin(const char (&str)[NN], unsigned start = 0);

      template <size_t NN>
      __attribute__((always_inline)) inline constexpr void bit_fill_oct(const char (&str)[NN], unsigned start = 0)
      {


         ac_int<W, S> res = 0;
         bool loop_exit = false;
# 4333 "../../../ac_types/include/ac_int.h"
      if(0 <= NN) { for(int i = 0; i < NN + (exclude == loop_limit::include); ++i) {
# 4349 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4333 "../../../ac_types/include/ac_int.h"
      { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c >= '0' && c <= '8') h = c - '0'; else { ; loop_exit = true; continue; } res <<= (ac_int<W, false>(3)); res |= (ac_int<4, false>(h)); } } } } else { for(int i = 0; i >= NN + (exclude == loop_limit::exclude); --i) {
# 4349 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4333 "../../../ac_types/include/ac_int.h"
      { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c >= '0' && c <= '8') h = c - '0'; else { ; loop_exit = true; continue; } res <<= (ac_int<W, false>(3)); res |= (ac_int<4, false>(h)); } } } }
# 4349 "../../../ac_types/include/ac_int.h"
        ;

         *this = res;
      }

      template <size_t NN>
      __attribute__((always_inline)) inline constexpr void bit_fill_hex(const char (&str)[NN], unsigned start = 0)
      {


         ac_int<W, S> res = 0;
         bool loop_exit = false;
# 4384 "../../../ac_types/include/ac_int.h"
      if(0 <= NN) { for(int i = 0; i < NN + (exclude == loop_limit::include); ++i) {
# 4404 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4384 "../../../ac_types/include/ac_int.h"
      { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c >= '0' && c <= '9') h = c - '0'; else if(c >= 'A' && c <= 'F') h = c - 'A' + 10; else if(c >= 'a' && c <= 'f') h = c - 'a' + 10; else { ; loop_exit = true; continue; } res <<= (ac_int<W, false>(4)); res |= (ac_int<4, false>(h)); } } } } else { for(int i = 0; i >= NN + (exclude == loop_limit::exclude); --i) {
# 4404 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4384 "../../../ac_types/include/ac_int.h"
      { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c >= '0' && c <= '9') h = c - '0'; else if(c >= 'A' && c <= 'F') h = c - 'A' + 10; else if(c >= 'a' && c <= 'f') h = c - 'a' + 10; else { ; loop_exit = true; continue; } res <<= (ac_int<W, false>(4)); res |= (ac_int<4, false>(h)); } } } }
# 4404 "../../../ac_types/include/ac_int.h"
        ;

         *this = res;
      }

      template <int Na>
      __attribute__((always_inline)) inline void bit_fill(const int (&ivec)[Na], bool bigendian = true)
      {






         enum
         {
            N0 = (W + 31) / 32,
            M = ((N0) < (Na) ? (N0) : (Na))
         };
         ac_int<M * 32, false> res = 0;
         if(0 <= M) { for(int i = 0; i < M + (exclude == loop_limit::include); ++i) {
# 4424 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4424 "../../../ac_types/include/ac_int.h"
         { res.set_slc(i * 32, ac_int<32>(ivec[bigendian ? M - 1 - i : i])); } } } else { for(int i = 0; i >= M + (exclude == loop_limit::exclude); --i) {
# 4424 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4424 "../../../ac_types/include/ac_int.h"
         { res.set_slc(i * 32, ac_int<32>(ivec[bigendian ? M - 1 - i : i])); } } };
         *this = res;
      }
   };

   template <int W1, bool S1>
   struct range_ref
   {
      ac_int<W1, S1>& ref;
      int low;
      int high;
      __attribute__((always_inline)) inline range_ref(ac_int<W1, S1>& _ref, int _high, int _low) : ref(_ref), low(_low), high(_high)
      {
         ;
         ;
         ;
      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline const range_ref& operator=(const ac_int<W2, S2>& op) const
      {
         ref.set_slc(high, low, op);
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline operator ac_int<W2, S2>() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline const range_ref& operator=(const ac_fixed<W2, I2, S2, Q2, O2>& b) const
      {
         return operator=(b.to_ac_int());
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline const range_ref& operator=(const range_ref<W2, S2>& b) const
      {
         const ac_int<W1, false> r = b.ref.slc(b.high, b.low);
         return operator=(r);
      }
      __attribute__((always_inline)) inline int to_int() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_int();
      }
      __attribute__((always_inline)) inline unsigned to_uint() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_uint();
      }
      __attribute__((always_inline)) inline long to_long() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_long();
      }
      __attribute__((always_inline)) inline unsigned long to_ulong() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_ulong();
      }
      __attribute__((always_inline)) inline constexpr Slong to_int64() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_int64();
      }
      __attribute__((always_inline)) inline constexpr Ulong to_uint64() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_uint64();
      }
      __attribute__((always_inline)) inline double to_double() const
      {
         const ac_int<W1, false> r = ref.slc(high, low);
         return r.to_double();
      }

      __attribute__((always_inline)) inline int length() const
      {
         return W1;
      }
      __attribute__((always_inline)) inline operator int() const
      {
         return to_int();
      }
      __attribute__((always_inline)) inline operator unsigned() const
      {
         return to_uint();
      }
      __attribute__((always_inline)) inline operator long() const
      {
         return to_long();
      }
      __attribute__((always_inline)) inline operator unsigned long() const
      {
         return to_ulong();
      }
      __attribute__((always_inline)) inline operator Slong() const
      {
         return to_int64();
      }
      __attribute__((always_inline)) inline operator Ulong() const
      {
         return to_uint64();
      }
      __attribute__((always_inline)) inline operator double() const
      {
         return to_double();
      }
   };

   namespace ac
   {
      template <typename T, typename T2>
      struct rt_2T
      {
         typedef typename ac_private::map<T>::t map_T;
         typedef typename ac_private::map<T2>::t map_T2;
         typedef typename map_T::template rt_T<map_T2>::mult mult;
         typedef typename map_T::template rt_T<map_T2>::plus plus;
         typedef typename map_T::template rt_T<map_T2>::minus minus;
         typedef typename map_T::template rt_T<map_T2>::minus2 minus2;
         typedef typename map_T::template rt_T<map_T2>::logic logic;
         typedef typename map_T::template rt_T<map_T2>::div div;
         typedef typename map_T::template rt_T<map_T2>::div2 div2;
      };
   }

   namespace ac
   {
      template <typename T>
      struct ac_int_represent
      {
         enum
         {
            t_w = ac_private::c_type_params<T>::W,
            t_s = ac_private::c_type_params<T>::S
         };
         typedef ac_int<t_w, t_s> type;
      };
      template <>
      struct ac_int_represent<float>
      {
      };
      template <>
      struct ac_int_represent<double>
      {
      };
      template <int W, bool S>
      struct ac_int_represent<ac_int<W, S>>
      {
         typedef ac_int<W, S> type;
      };
   }

   namespace ac_private
   {
      template <int W2, bool S2>
      struct rt_ac_int_T<ac_int<W2, S2>>
      {
         typedef ac_int<W2, S2> i2_t;
         template <int W, bool S>
         struct op1
         {
            typedef ac_int<W, S> i_t;
            typedef typename i_t::template rt<W2, S2>::mult mult;
            typedef typename i_t::template rt<W2, S2>::plus plus;
            typedef typename i_t::template rt<W2, S2>::minus minus;
            typedef typename i2_t::template rt<W, S>::minus minus2;
            typedef typename i_t::template rt<W2, S2>::logic logic;
            typedef typename i_t::template rt<W2, S2>::div div;
            typedef typename i2_t::template rt<W, S>::div div2;
            typedef typename i_t::template rt<W2, S2>::mod mod;
            typedef typename i2_t::template rt<W, S>::mod mod2;
         };
      };

      template <typename T>
      struct rt_ac_int_T<c_type<T>>
      {
         typedef typename ac::ac_int_represent<T>::type i2_t;
         enum
         {
            W2 = i2_t::width,
            S2 = i2_t::sign
         };
         template <int W, bool S>
         struct op1
         {
            typedef ac_int<W, S> i_t;
            typedef typename i_t::template rt<W2, S2>::mult mult;
            typedef typename i_t::template rt<W2, S2>::plus plus;
            typedef typename i_t::template rt<W2, S2>::minus minus;
            typedef typename i2_t::template rt<W, S>::minus minus2;
            typedef typename i_t::template rt<W2, S2>::logic logic;
            typedef typename i_t::template rt<W2, S2>::div div;
            typedef typename i2_t::template rt<W, S>::div div2;
            typedef typename i_t::template rt<W2, S2>::mod mod;
            typedef typename i2_t::template rt<W, S>::mod mod2;
         };
      };
   }



   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, true>::ac_int(bool b)
   {
      v.set(0, b ? -1 : 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(signed char b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(unsigned char b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(signed short b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(unsigned short b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(signed int b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(unsigned int b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(signed long b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(unsigned long b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(Ulong b)
   {
      v.set(0, (int)b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<1, false>::ac_int(Slong b)
   {
      v.set(0, (int)b & 1);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, true>::ac_int(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, false>::ac_int(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, true>::ac_int(signed char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, false>::ac_int(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, true>::ac_int(unsigned char b)
   {
      v.set(0, (signed char)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<8, false>::ac_int(signed char b)
   {
      v.set(0, (unsigned char)b);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, true>::ac_int(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, false>::ac_int(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, true>::ac_int(signed char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, false>::ac_int(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, true>::ac_int(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, false>::ac_int(signed char b)
   {
      v.set(0, (unsigned short)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, true>::ac_int(signed short b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, false>::ac_int(unsigned short b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, true>::ac_int(unsigned short b)
   {
      v.set(0, (signed short)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<16, false>::ac_int(signed short b)
   {
      v.set(0, (unsigned short)b);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, true>::ac_int(signed int b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, true>::ac_int(unsigned int b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, false>::ac_int(signed int b)
   {
      v.set(0, b);
      v.set(1, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, false>::ac_int(unsigned int b)
   {
      v.set(0, b);
      v.set(1, 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, true>::ac_int(Slong b)
   {
      v.set(0, (int)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, true>::ac_int(Ulong b)
   {
      v.set(0, (int)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, false>::ac_int(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<32, false>::ac_int(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_int<64, true>::ac_int(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<64, true>::ac_int(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<64, false>::ac_int(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)((Ulong)b >> 32));
      v.set(2, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_int<64, false>::ac_int(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
      v.set(2, 0);
   }

   template <int W, bool S>
   template <size_t NN>
   __attribute__((always_inline)) inline constexpr void ac_int<W, S>::bit_fill_bin(const char (&str)[NN], unsigned start)
   {
      ac_int<W, S> res = 0;
      bool loop_exit = false;
# 4873 "../../../ac_types/include/ac_int.h"
   if(0 <= NN) { for(int i = 0; i < NN + (exclude == loop_limit::include); ++i) {
# 4891 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4873 "../../../ac_types/include/ac_int.h"
   { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c == '0') h = 0; else if(c == '1') h = 1; else { ; loop_exit = true; continue; } res <<= (ac_int<1, false>(1)); res |= (ac_int<1, false>(h)); } } } } else { for(int i = 0; i >= NN + (exclude == loop_limit::exclude); --i) {
# 4891 "../../../ac_types/include/ac_int.h"
#pragma HLS UNROLL
# 4873 "../../../ac_types/include/ac_int.h"
   { if(!loop_exit && i >= start) { char c = str[i]; int h = 0; if(c == '0') h = 0; else if(c == '1') h = 1; else { ; loop_exit = true; continue; } res <<= (ac_int<1, false>(1)); res |= (ac_int<1, false>(h)); } } } }
# 4891 "../../../ac_types/include/ac_int.h"
     ;

      *this = res;
   }


   template <int W, bool S>
   __attribute__((always_inline)) inline std::ostream& operator<<(std::ostream& os, const ac_int<W, S>& x)
   {
# 4914 "../../../ac_types/include/ac_int.h"
      return os;
   }

   template <int W, bool S>
   __attribute__((always_inline)) inline std::istream& operator>>(std::istream& in, ac_int<W, S>& x)
   {
# 4930 "../../../ac_types/include/ac_int.h"
      return in;
   }
# 5063 "../../../ac_types/include/ac_int.h"
   namespace ac
   {
      namespace ops_with_other_types
      {


         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::mult operator *(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::mult operator *(const ac_int<W, S>& op, bool i_op) { return op.operator *(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::plus operator +(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::plus operator +(const ac_int<W, S>& op, bool i_op) { return op.operator +(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::minus operator -(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::minus operator -(const ac_int<W, S>& op, bool i_op) { return op.operator -(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::div operator /(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::div operator /(const ac_int<W, S>& op, bool i_op) { return op.operator /(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::mod operator %(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::mod operator %(const ac_int<W, S>& op, bool i_op) { return op.operator %(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::arg1 operator >>(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::arg1 operator >>(const ac_int<W, S>& op, bool i_op) { return op.operator >>(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::arg1 operator <<(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::arg1 operator <<(const ac_int<W, S>& op, bool i_op) { return op.operator <<(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::logic operator &(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::logic operator &(const ac_int<W, S>& op, bool i_op) { return op.operator &(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::logic operator |(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::logic operator |(const ac_int<W, S>& op, bool i_op) { return op.operator |(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<1, false>::template rt<W, S>::logic operator ^(bool i_op, const ac_int<W, S>& op) { return ac_int<1, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<1, false>::logic operator ^(const ac_int<W, S>& op, bool i_op) { return op.operator ^(ac_int<1, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, bool op2) { return op.operator ==(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, bool op2) { return op.operator !=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, bool op2) { return op.operator >(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, bool op2) { return op.operator >=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, bool op2) { return op.operator <(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, bool op2) { return op.operator <=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(bool op2, const ac_int<W, S>& op) { return ac_int<1, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, bool op2) { return op.operator +=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, bool op2) { return op.operator -=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, bool op2) { return op.operator *=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, bool op2) { return op.operator /=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, bool op2) { return op.operator %=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, bool op2) { return op.operator >>=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, bool op2) { return op.operator <<=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, bool op2) { return op.operator &=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, bool op2) { return op.operator |=(ac_int<1, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, bool op2) { return op.operator ^=(ac_int<1, false>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::mult operator *(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::mult operator *(const ac_int<W, S>& op, char i_op) { return op.operator *(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::plus operator +(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::plus operator +(const ac_int<W, S>& op, char i_op) { return op.operator +(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::minus operator -(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::minus operator -(const ac_int<W, S>& op, char i_op) { return op.operator -(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::div operator /(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::div operator /(const ac_int<W, S>& op, char i_op) { return op.operator /(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::mod operator %(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::mod operator %(const ac_int<W, S>& op, char i_op) { return op.operator %(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::arg1 operator >>(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::arg1 operator >>(const ac_int<W, S>& op, char i_op) { return op.operator >>(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::arg1 operator <<(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::arg1 operator <<(const ac_int<W, S>& op, char i_op) { return op.operator <<(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator &(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator &(const ac_int<W, S>& op, char i_op) { return op.operator &(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator |(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator |(const ac_int<W, S>& op, char i_op) { return op.operator |(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator ^(char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator ^(const ac_int<W, S>& op, char i_op) { return op.operator ^(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, char op2) { return op.operator ==(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, char op2) { return op.operator !=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, char op2) { return op.operator >(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, char op2) { return op.operator >=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, char op2) { return op.operator <(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, char op2) { return op.operator <=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, char op2) { return op.operator +=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, char op2) { return op.operator -=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, char op2) { return op.operator *=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, char op2) { return op.operator /=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, char op2) { return op.operator %=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, char op2) { return op.operator >>=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, char op2) { return op.operator <<=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, char op2) { return op.operator &=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, char op2) { return op.operator |=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, char op2) { return op.operator ^=(ac_int<8, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::mult operator *(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::mult operator *(const ac_int<W, S>& op, signed char i_op) { return op.operator *(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::plus operator +(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::plus operator +(const ac_int<W, S>& op, signed char i_op) { return op.operator +(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::minus operator -(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::minus operator -(const ac_int<W, S>& op, signed char i_op) { return op.operator -(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::div operator /(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::div operator /(const ac_int<W, S>& op, signed char i_op) { return op.operator /(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::mod operator %(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::mod operator %(const ac_int<W, S>& op, signed char i_op) { return op.operator %(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::arg1 operator >>(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::arg1 operator >>(const ac_int<W, S>& op, signed char i_op) { return op.operator >>(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::arg1 operator <<(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::arg1 operator <<(const ac_int<W, S>& op, signed char i_op) { return op.operator <<(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator &(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator &(const ac_int<W, S>& op, signed char i_op) { return op.operator &(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator |(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator |(const ac_int<W, S>& op, signed char i_op) { return op.operator |(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, true>::template rt<W, S>::logic operator ^(signed char i_op, const ac_int<W, S>& op) { return ac_int<8, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, true>::logic operator ^(const ac_int<W, S>& op, signed char i_op) { return op.operator ^(ac_int<8, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, signed char op2) { return op.operator ==(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, signed char op2) { return op.operator !=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, signed char op2) { return op.operator >(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, signed char op2) { return op.operator >=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, signed char op2) { return op.operator <(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, signed char op2) { return op.operator <=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(signed char op2, const ac_int<W, S>& op) { return ac_int<8, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, signed char op2) { return op.operator +=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, signed char op2) { return op.operator -=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, signed char op2) { return op.operator *=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, signed char op2) { return op.operator /=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, signed char op2) { return op.operator %=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, signed char op2) { return op.operator >>=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, signed char op2) { return op.operator <<=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, signed char op2) { return op.operator &=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, signed char op2) { return op.operator |=(ac_int<8, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, signed char op2) { return op.operator ^=(ac_int<8, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::mult operator *(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::mult operator *(const ac_int<W, S>& op, unsigned char i_op) { return op.operator *(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::plus operator +(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::plus operator +(const ac_int<W, S>& op, unsigned char i_op) { return op.operator +(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::minus operator -(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::minus operator -(const ac_int<W, S>& op, unsigned char i_op) { return op.operator -(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::div operator /(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::div operator /(const ac_int<W, S>& op, unsigned char i_op) { return op.operator /(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::mod operator %(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::mod operator %(const ac_int<W, S>& op, unsigned char i_op) { return op.operator %(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::arg1 operator >>(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::arg1 operator >>(const ac_int<W, S>& op, unsigned char i_op) { return op.operator >>(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::arg1 operator <<(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::arg1 operator <<(const ac_int<W, S>& op, unsigned char i_op) { return op.operator <<(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::logic operator &(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::logic operator &(const ac_int<W, S>& op, unsigned char i_op) { return op.operator &(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::logic operator |(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::logic operator |(const ac_int<W, S>& op, unsigned char i_op) { return op.operator |(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<8, false>::template rt<W, S>::logic operator ^(unsigned char i_op, const ac_int<W, S>& op) { return ac_int<8, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<8, false>::logic operator ^(const ac_int<W, S>& op, unsigned char i_op) { return op.operator ^(ac_int<8, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, unsigned char op2) { return op.operator ==(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, unsigned char op2) { return op.operator !=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, unsigned char op2) { return op.operator >(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, unsigned char op2) { return op.operator >=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, unsigned char op2) { return op.operator <(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, unsigned char op2) { return op.operator <=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(unsigned char op2, const ac_int<W, S>& op) { return ac_int<8, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, unsigned char op2) { return op.operator +=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, unsigned char op2) { return op.operator -=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, unsigned char op2) { return op.operator *=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, unsigned char op2) { return op.operator /=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, unsigned char op2) { return op.operator %=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, unsigned char op2) { return op.operator >>=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, unsigned char op2) { return op.operator <<=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, unsigned char op2) { return op.operator &=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, unsigned char op2) { return op.operator |=(ac_int<8, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, unsigned char op2) { return op.operator ^=(ac_int<8, false>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::mult operator *(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::mult operator *(const ac_int<W, S>& op, short i_op) { return op.operator *(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::plus operator +(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::plus operator +(const ac_int<W, S>& op, short i_op) { return op.operator +(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::minus operator -(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::minus operator -(const ac_int<W, S>& op, short i_op) { return op.operator -(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::div operator /(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::div operator /(const ac_int<W, S>& op, short i_op) { return op.operator /(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::mod operator %(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::mod operator %(const ac_int<W, S>& op, short i_op) { return op.operator %(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::arg1 operator >>(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::arg1 operator >>(const ac_int<W, S>& op, short i_op) { return op.operator >>(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::arg1 operator <<(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::arg1 operator <<(const ac_int<W, S>& op, short i_op) { return op.operator <<(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::logic operator &(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::logic operator &(const ac_int<W, S>& op, short i_op) { return op.operator &(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::logic operator |(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::logic operator |(const ac_int<W, S>& op, short i_op) { return op.operator |(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, true>::template rt<W, S>::logic operator ^(short i_op, const ac_int<W, S>& op) { return ac_int<16, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, true>::logic operator ^(const ac_int<W, S>& op, short i_op) { return op.operator ^(ac_int<16, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, short op2) { return op.operator ==(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, short op2) { return op.operator !=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, short op2) { return op.operator >(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, short op2) { return op.operator >=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, short op2) { return op.operator <(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, short op2) { return op.operator <=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(short op2, const ac_int<W, S>& op) { return ac_int<16, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, short op2) { return op.operator +=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, short op2) { return op.operator -=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, short op2) { return op.operator *=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, short op2) { return op.operator /=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, short op2) { return op.operator %=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, short op2) { return op.operator >>=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, short op2) { return op.operator <<=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, short op2) { return op.operator &=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, short op2) { return op.operator |=(ac_int<16, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, short op2) { return op.operator ^=(ac_int<16, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::mult operator *(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::mult operator *(const ac_int<W, S>& op, unsigned short i_op) { return op.operator *(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::plus operator +(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::plus operator +(const ac_int<W, S>& op, unsigned short i_op) { return op.operator +(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::minus operator -(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::minus operator -(const ac_int<W, S>& op, unsigned short i_op) { return op.operator -(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::div operator /(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::div operator /(const ac_int<W, S>& op, unsigned short i_op) { return op.operator /(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::mod operator %(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::mod operator %(const ac_int<W, S>& op, unsigned short i_op) { return op.operator %(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::arg1 operator >>(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::arg1 operator >>(const ac_int<W, S>& op, unsigned short i_op) { return op.operator >>(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::arg1 operator <<(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::arg1 operator <<(const ac_int<W, S>& op, unsigned short i_op) { return op.operator <<(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::logic operator &(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::logic operator &(const ac_int<W, S>& op, unsigned short i_op) { return op.operator &(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::logic operator |(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::logic operator |(const ac_int<W, S>& op, unsigned short i_op) { return op.operator |(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<16, false>::template rt<W, S>::logic operator ^(unsigned short i_op, const ac_int<W, S>& op) { return ac_int<16, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<16, false>::logic operator ^(const ac_int<W, S>& op, unsigned short i_op) { return op.operator ^(ac_int<16, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, unsigned short op2) { return op.operator ==(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, unsigned short op2) { return op.operator !=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, unsigned short op2) { return op.operator >(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, unsigned short op2) { return op.operator >=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, unsigned short op2) { return op.operator <(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, unsigned short op2) { return op.operator <=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(unsigned short op2, const ac_int<W, S>& op) { return ac_int<16, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, unsigned short op2) { return op.operator +=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, unsigned short op2) { return op.operator -=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, unsigned short op2) { return op.operator *=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, unsigned short op2) { return op.operator /=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, unsigned short op2) { return op.operator %=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, unsigned short op2) { return op.operator >>=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, unsigned short op2) { return op.operator <<=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, unsigned short op2) { return op.operator &=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, unsigned short op2) { return op.operator |=(ac_int<16, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, unsigned short op2) { return op.operator ^=(ac_int<16, false>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::mult operator *(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::mult operator *(const ac_int<W, S>& op, int i_op) { return op.operator *(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::plus operator +(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::plus operator +(const ac_int<W, S>& op, int i_op) { return op.operator +(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::minus operator -(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::minus operator -(const ac_int<W, S>& op, int i_op) { return op.operator -(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::div operator /(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::div operator /(const ac_int<W, S>& op, int i_op) { return op.operator /(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::mod operator %(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::mod operator %(const ac_int<W, S>& op, int i_op) { return op.operator %(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::arg1 operator >>(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::arg1 operator >>(const ac_int<W, S>& op, int i_op) { return op.operator >>(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::arg1 operator <<(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::arg1 operator <<(const ac_int<W, S>& op, int i_op) { return op.operator <<(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::logic operator &(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::logic operator &(const ac_int<W, S>& op, int i_op) { return op.operator &(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::logic operator |(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::logic operator |(const ac_int<W, S>& op, int i_op) { return op.operator |(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, true>::template rt<W, S>::logic operator ^(int i_op, const ac_int<W, S>& op) { return ac_int<32, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, true>::logic operator ^(const ac_int<W, S>& op, int i_op) { return op.operator ^(ac_int<32, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, int op2) { return op.operator ==(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, int op2) { return op.operator !=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, int op2) { return op.operator >(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, int op2) { return op.operator >=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, int op2) { return op.operator <(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, int op2) { return op.operator <=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(int op2, const ac_int<W, S>& op) { return ac_int<32, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, int op2) { return op.operator +=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, int op2) { return op.operator -=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, int op2) { return op.operator *=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, int op2) { return op.operator /=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, int op2) { return op.operator %=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, int op2) { return op.operator >>=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, int op2) { return op.operator <<=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, int op2) { return op.operator &=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, int op2) { return op.operator |=(ac_int<32, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, int op2) { return op.operator ^=(ac_int<32, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::mult operator *(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::mult operator *(const ac_int<W, S>& op, unsigned int i_op) { return op.operator *(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::plus operator +(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::plus operator +(const ac_int<W, S>& op, unsigned int i_op) { return op.operator +(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::minus operator -(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::minus operator -(const ac_int<W, S>& op, unsigned int i_op) { return op.operator -(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::div operator /(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::div operator /(const ac_int<W, S>& op, unsigned int i_op) { return op.operator /(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::mod operator %(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::mod operator %(const ac_int<W, S>& op, unsigned int i_op) { return op.operator %(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::arg1 operator >>(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::arg1 operator >>(const ac_int<W, S>& op, unsigned int i_op) { return op.operator >>(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::arg1 operator <<(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::arg1 operator <<(const ac_int<W, S>& op, unsigned int i_op) { return op.operator <<(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::logic operator &(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::logic operator &(const ac_int<W, S>& op, unsigned int i_op) { return op.operator &(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::logic operator |(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::logic operator |(const ac_int<W, S>& op, unsigned int i_op) { return op.operator |(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<32, false>::template rt<W, S>::logic operator ^(unsigned int i_op, const ac_int<W, S>& op) { return ac_int<32, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<32, false>::logic operator ^(const ac_int<W, S>& op, unsigned int i_op) { return op.operator ^(ac_int<32, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, unsigned int op2) { return op.operator ==(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, unsigned int op2) { return op.operator !=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, unsigned int op2) { return op.operator >(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, unsigned int op2) { return op.operator >=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, unsigned int op2) { return op.operator <(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, unsigned int op2) { return op.operator <=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(unsigned int op2, const ac_int<W, S>& op) { return ac_int<32, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, unsigned int op2) { return op.operator +=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, unsigned int op2) { return op.operator -=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, unsigned int op2) { return op.operator *=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, unsigned int op2) { return op.operator /=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, unsigned int op2) { return op.operator %=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, unsigned int op2) { return op.operator >>=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, unsigned int op2) { return op.operator <<=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, unsigned int op2) { return op.operator &=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, unsigned int op2) { return op.operator |=(ac_int<32, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, unsigned int op2) { return op.operator ^=(ac_int<32, false>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::mult operator *(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::mult operator *(const ac_int<W, S>& op, long i_op) { return op.operator *(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::plus operator +(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::plus operator +(const ac_int<W, S>& op, long i_op) { return op.operator +(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::minus operator -(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::minus operator -(const ac_int<W, S>& op, long i_op) { return op.operator -(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::div operator /(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::div operator /(const ac_int<W, S>& op, long i_op) { return op.operator /(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::mod operator %(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::mod operator %(const ac_int<W, S>& op, long i_op) { return op.operator %(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::arg1 operator >>(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::arg1 operator >>(const ac_int<W, S>& op, long i_op) { return op.operator >>(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::arg1 operator <<(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::arg1 operator <<(const ac_int<W, S>& op, long i_op) { return op.operator <<(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::logic operator &(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::logic operator &(const ac_int<W, S>& op, long i_op) { return op.operator &(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::logic operator |(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::logic operator |(const ac_int<W, S>& op, long i_op) { return op.operator |(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, true>::template rt<W, S>::logic operator ^(long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, true>::logic operator ^(const ac_int<W, S>& op, long i_op) { return op.operator ^(ac_int<ac_private::long_w, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, long op2) { return op.operator ==(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, long op2) { return op.operator !=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, long op2) { return op.operator >(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, long op2) { return op.operator >=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, long op2) { return op.operator <(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, long op2) { return op.operator <=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, long op2) { return op.operator +=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, long op2) { return op.operator -=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, long op2) { return op.operator *=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, long op2) { return op.operator /=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, long op2) { return op.operator %=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, long op2) { return op.operator >>=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, long op2) { return op.operator <<=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, long op2) { return op.operator &=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, long op2) { return op.operator |=(ac_int<ac_private::long_w, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, long op2) { return op.operator ^=(ac_int<ac_private::long_w, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::mult operator *(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::mult operator *(const ac_int<W, S>& op, unsigned long i_op) { return op.operator *(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::plus operator +(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::plus operator +(const ac_int<W, S>& op, unsigned long i_op) { return op.operator +(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::minus operator -(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::minus operator -(const ac_int<W, S>& op, unsigned long i_op) { return op.operator -(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::div operator /(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::div operator /(const ac_int<W, S>& op, unsigned long i_op) { return op.operator /(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::mod operator %(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::mod operator %(const ac_int<W, S>& op, unsigned long i_op) { return op.operator %(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::arg1 operator >>(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::arg1 operator >>(const ac_int<W, S>& op, unsigned long i_op) { return op.operator >>(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::arg1 operator <<(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::arg1 operator <<(const ac_int<W, S>& op, unsigned long i_op) { return op.operator <<(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::logic operator &(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::logic operator &(const ac_int<W, S>& op, unsigned long i_op) { return op.operator &(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::logic operator |(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::logic operator |(const ac_int<W, S>& op, unsigned long i_op) { return op.operator |(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<ac_private::long_w, false>::template rt<W, S>::logic operator ^(unsigned long i_op, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<ac_private::long_w, false>::logic operator ^(const ac_int<W, S>& op, unsigned long i_op) { return op.operator ^(ac_int<ac_private::long_w, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, unsigned long op2) { return op.operator ==(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, unsigned long op2) { return op.operator !=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, unsigned long op2) { return op.operator >(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, unsigned long op2) { return op.operator >=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, unsigned long op2) { return op.operator <(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, unsigned long op2) { return op.operator <=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(unsigned long op2, const ac_int<W, S>& op) { return ac_int<ac_private::long_w, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, unsigned long op2) { return op.operator +=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, unsigned long op2) { return op.operator -=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, unsigned long op2) { return op.operator *=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, unsigned long op2) { return op.operator /=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, unsigned long op2) { return op.operator %=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, unsigned long op2) { return op.operator >>=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, unsigned long op2) { return op.operator <<=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, unsigned long op2) { return op.operator &=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, unsigned long op2) { return op.operator |=(ac_int<ac_private::long_w, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, unsigned long op2) { return op.operator ^=(ac_int<ac_private::long_w, false>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::mult operator *(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::mult operator *(const ac_int<W, S>& op, Slong i_op) { return op.operator *(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::plus operator +(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::plus operator +(const ac_int<W, S>& op, Slong i_op) { return op.operator +(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::minus operator -(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::minus operator -(const ac_int<W, S>& op, Slong i_op) { return op.operator -(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::div operator /(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::div operator /(const ac_int<W, S>& op, Slong i_op) { return op.operator /(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::mod operator %(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::mod operator %(const ac_int<W, S>& op, Slong i_op) { return op.operator %(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::arg1 operator >>(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::arg1 operator >>(const ac_int<W, S>& op, Slong i_op) { return op.operator >>(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::arg1 operator <<(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::arg1 operator <<(const ac_int<W, S>& op, Slong i_op) { return op.operator <<(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::logic operator &(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::logic operator &(const ac_int<W, S>& op, Slong i_op) { return op.operator &(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::logic operator |(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::logic operator |(const ac_int<W, S>& op, Slong i_op) { return op.operator |(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, true>::template rt<W, S>::logic operator ^(Slong i_op, const ac_int<W, S>& op) { return ac_int<64, true>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, true>::logic operator ^(const ac_int<W, S>& op, Slong i_op) { return op.operator ^(ac_int<64, true>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, Slong op2) { return op.operator ==(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, Slong op2) { return op.operator !=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, Slong op2) { return op.operator >(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, Slong op2) { return op.operator >=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, Slong op2) { return op.operator <(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, Slong op2) { return op.operator <=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(Slong op2, const ac_int<W, S>& op) { return ac_int<64, true>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, Slong op2) { return op.operator +=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, Slong op2) { return op.operator -=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, Slong op2) { return op.operator *=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, Slong op2) { return op.operator /=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, Slong op2) { return op.operator %=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, Slong op2) { return op.operator >>=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, Slong op2) { return op.operator <<=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, Slong op2) { return op.operator &=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, Slong op2) { return op.operator |=(ac_int<64, true>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, Slong op2) { return op.operator ^=(ac_int<64, true>(op2)); }
         template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::mult operator *(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator *(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::mult operator *(const ac_int<W, S>& op, Ulong i_op) { return op.operator *(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::plus operator +(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator +(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::plus operator +(const ac_int<W, S>& op, Ulong i_op) { return op.operator +(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::minus operator -(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator -(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::minus operator -(const ac_int<W, S>& op, Ulong i_op) { return op.operator -(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::div operator /(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator /(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::div operator /(const ac_int<W, S>& op, Ulong i_op) { return op.operator /(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::mod operator %(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator %(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::mod operator %(const ac_int<W, S>& op, Ulong i_op) { return op.operator %(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::arg1 operator >>(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator >>(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::arg1 operator >>(const ac_int<W, S>& op, Ulong i_op) { return op.operator >>(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::arg1 operator <<(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator <<(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::arg1 operator <<(const ac_int<W, S>& op, Ulong i_op) { return op.operator <<(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::logic operator &(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator &(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::logic operator &(const ac_int<W, S>& op, Ulong i_op) { return op.operator &(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::logic operator |(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator |(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::logic operator |(const ac_int<W, S>& op, Ulong i_op) { return op.operator |(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<64, false>::template rt<W, S>::logic operator ^(Ulong i_op, const ac_int<W, S>& op) { return ac_int<64, false>(i_op).operator ^(op); } template <int W, bool S> __attribute__((always_inline)) inline typename ac_int<W, S>::template rt<64, false>::logic operator ^(const ac_int<W, S>& op, Ulong i_op) { return op.operator ^(ac_int<64, false>(i_op)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(const ac_int<W, S>& op, Ulong op2) { return op.operator ==(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator ==(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator ==(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(const ac_int<W, S>& op, Ulong op2) { return op.operator !=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator !=(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator !=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(const ac_int<W, S>& op, Ulong op2) { return op.operator >(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator >(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(const ac_int<W, S>& op, Ulong op2) { return op.operator >=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator >=(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator >=(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(const ac_int<W, S>& op, Ulong op2) { return op.operator <(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator <(op); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(const ac_int<W, S>& op, Ulong op2) { return op.operator <=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline bool operator <=(Ulong op2, const ac_int<W, S>& op) { return ac_int<64, false>(op2).operator <=(op); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator +=(ac_int<W, S>& op, Ulong op2) { return op.operator +=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator -=(ac_int<W, S>& op, Ulong op2) { return op.operator -=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator *=(ac_int<W, S>& op, Ulong op2) { return op.operator *=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator /=(ac_int<W, S>& op, Ulong op2) { return op.operator /=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator %=(ac_int<W, S>& op, Ulong op2) { return op.operator %=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator >>=(ac_int<W, S>& op, Ulong op2) { return op.operator >>=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator <<=(ac_int<W, S>& op, Ulong op2) { return op.operator <<=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator &=(ac_int<W, S>& op, Ulong op2) { return op.operator &=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator |=(ac_int<W, S>& op, Ulong op2) { return op.operator |=(ac_int<64, false>(op2)); } template <int W, bool S> __attribute__((always_inline)) inline ac_int<W, S>& operator ^=(ac_int<W, S>& op, Ulong op2) { return op.operator ^=(ac_int<64, false>(op2)); }


      }

      namespace ops_with_range_types
      {
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator +=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator +=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator +=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator +=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator +=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator -=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator -=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator -=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator -=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator -=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator *=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator *=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator *=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator *=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator *=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator /=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator /=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator /=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator /=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator /=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator %=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator %=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator %=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator %=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator %=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator >>=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator >>=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator >>=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator >>=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator >>=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator <<=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator <<=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator <<=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator <<=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator <<=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator &=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator &=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator &=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator &=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator &=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator |=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator |=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator |=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator |=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator |=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline ac_int<W1, S1>& operator ^=(ac_int<W1, S1>& op1, range_ref<W2, S2>& op2) { return op1.operator ^=(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator ^=(range_ref<W1, S1>& op1, ac_int<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline range_ref<W1, S1>& operator ^=(range_ref<W1, S1>& op1, range_ref<W2, S2>& op2) { ac_int<W1, false> tmp(op1); tmp.operator ^=(ac_int<W2, false>(op2)); op1 = tmp; return op1; }

         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator ==(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator ==(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator ==(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator ==(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator ==(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator ==(op2.operator ac_int<W2, false>()); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator !=(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator !=(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator !=(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator !=(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator !=(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator !=(op2.operator ac_int<W2, false>()); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator >(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator >(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator >(op2.operator ac_int<W2, false>()); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >=(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator >=(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >=(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator >=(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator >=(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator >=(op2.operator ac_int<W2, false>()); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator <(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator <(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator <(op2.operator ac_int<W2, false>()); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <=(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1).operator <=(op2.operator ac_int<W2, false>()); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <=(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1).operator <=(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline bool operator <=(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1.operator <=(op2.operator ac_int<W2, false>()); }

         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::plus operator +(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) +(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::plus operator +(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) +(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::plus operator +(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 +(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::minus operator -(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) -(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::minus operator -(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) -(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::minus operator -(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 -(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::mult operator *(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) *(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::mult operator *(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) *(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::mult operator *(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 *(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::div operator /(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) /(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::div operator /(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) /(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::div operator /(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 /(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::mod operator %(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) %(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::mod operator %(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) %(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::mod operator %(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 %(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::arg1 operator >>(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) >>(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::arg1 operator >>(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) >>(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::arg1 operator >>(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 >>(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::arg1 operator <<(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) <<(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::arg1 operator <<(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) <<(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::arg1 operator <<(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 <<(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator &(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) &(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator &(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) &(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::logic operator &(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 &(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator |(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) |(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator |(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) |(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::logic operator |(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 |(ac_int<W2, false>(op2)); }
         template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator ^(const range_ref<W1, S1>& op1, const range_ref<W2, S2>& op2) { return ac_int<W1, false>(op1) ^(ac_int<W2, false>(op2)); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template rt<W2, S2>::logic operator ^(const range_ref<W1, S1>& op1, const ac_int<W2, S2>& op2) { return ac_int<W1, false>(op1) ^(op2); } template <int W1, bool S1, int W2, bool S2> __attribute__((always_inline)) inline typename ac_int<W1, S1>::template RType<W2, S2>::logic operator ^(const ac_int<W1, S1>& op1, const range_ref<W2, S2>& op2) { return op1 ^(ac_int<W2, false>(op2)); }
      }



      template <typename T>
      __attribute__((always_inline)) inline T bit_fill_hex(const char* str)
      {
         T res;
         res.bit_fill_hex(str);
         return res;
      }





      template <typename T, int N>
      __attribute__((always_inline)) inline T bit_fill(const int (&ivec)[N], bool bigendian = true)
      {
         T res;
         res.bit_fill(ivec, bigendian);
         return res;
      }

   }





   template <typename T, int W, bool S>
   __attribute__((always_inline)) inline T* operator+(T* ptr, const ac_int<W, S>& op2)
   {
      return ptr + op2.to_int64();
   }
   template <typename T, int W, bool S>
   __attribute__((always_inline)) inline T* operator+(const ac_int<W, S>& op2, T* ptr)
   {
      return ptr + op2.to_int64();
   }

   template <typename T, int W, bool S>
   __attribute__((always_inline)) inline T* operator-(T* ptr, const ac_int<W, S>& op2)
   {
      return ptr - op2.to_int64();
   }



   using namespace ac::ops_with_other_types;
   using namespace ac::ops_with_range_types;

   namespace ac_intN
   {



      typedef ac_int<1, true> int1;
      typedef ac_int<1, false> uint1;
      typedef ac_int<2, true> int2;
      typedef ac_int<2, false> uint2;
      typedef ac_int<3, true> int3;
      typedef ac_int<3, false> uint3;
      typedef ac_int<4, true> int4;
      typedef ac_int<4, false> uint4;
      typedef ac_int<5, true> int5;
      typedef ac_int<5, false> uint5;
      typedef ac_int<6, true> int6;
      typedef ac_int<6, false> uint6;
      typedef ac_int<7, true> int7;
      typedef ac_int<7, false> uint7;
      typedef ac_int<8, true> int8;
      typedef ac_int<8, false> uint8;
      typedef ac_int<9, true> int9;
      typedef ac_int<9, false> uint9;
      typedef ac_int<10, true> int10;
      typedef ac_int<10, false> uint10;
      typedef ac_int<11, true> int11;
      typedef ac_int<11, false> uint11;
      typedef ac_int<12, true> int12;
      typedef ac_int<12, false> uint12;
      typedef ac_int<13, true> int13;
      typedef ac_int<13, false> uint13;
      typedef ac_int<14, true> int14;
      typedef ac_int<14, false> uint14;
      typedef ac_int<15, true> int15;
      typedef ac_int<15, false> uint15;
      typedef ac_int<16, true> int16;
      typedef ac_int<16, false> uint16;
      typedef ac_int<17, true> int17;
      typedef ac_int<17, false> uint17;
      typedef ac_int<18, true> int18;
      typedef ac_int<18, false> uint18;
      typedef ac_int<19, true> int19;
      typedef ac_int<19, false> uint19;
      typedef ac_int<20, true> int20;
      typedef ac_int<20, false> uint20;
      typedef ac_int<21, true> int21;
      typedef ac_int<21, false> uint21;
      typedef ac_int<22, true> int22;
      typedef ac_int<22, false> uint22;
      typedef ac_int<23, true> int23;
      typedef ac_int<23, false> uint23;
      typedef ac_int<24, true> int24;
      typedef ac_int<24, false> uint24;
      typedef ac_int<25, true> int25;
      typedef ac_int<25, false> uint25;
      typedef ac_int<26, true> int26;
      typedef ac_int<26, false> uint26;
      typedef ac_int<27, true> int27;
      typedef ac_int<27, false> uint27;
      typedef ac_int<28, true> int28;
      typedef ac_int<28, false> uint28;
      typedef ac_int<29, true> int29;
      typedef ac_int<29, false> uint29;
      typedef ac_int<30, true> int30;
      typedef ac_int<30, false> uint30;
      typedef ac_int<31, true> int31;
      typedef ac_int<31, false> uint31;
      typedef ac_int<32, true> int32;
      typedef ac_int<32, false> uint32;
      typedef ac_int<33, true> int33;
      typedef ac_int<33, false> uint33;
      typedef ac_int<34, true> int34;
      typedef ac_int<34, false> uint34;
      typedef ac_int<35, true> int35;
      typedef ac_int<35, false> uint35;
      typedef ac_int<36, true> int36;
      typedef ac_int<36, false> uint36;
      typedef ac_int<37, true> int37;
      typedef ac_int<37, false> uint37;
      typedef ac_int<38, true> int38;
      typedef ac_int<38, false> uint38;
      typedef ac_int<39, true> int39;
      typedef ac_int<39, false> uint39;
      typedef ac_int<40, true> int40;
      typedef ac_int<40, false> uint40;
      typedef ac_int<41, true> int41;
      typedef ac_int<41, false> uint41;
      typedef ac_int<42, true> int42;
      typedef ac_int<42, false> uint42;
      typedef ac_int<43, true> int43;
      typedef ac_int<43, false> uint43;
      typedef ac_int<44, true> int44;
      typedef ac_int<44, false> uint44;
      typedef ac_int<45, true> int45;
      typedef ac_int<45, false> uint45;
      typedef ac_int<46, true> int46;
      typedef ac_int<46, false> uint46;
      typedef ac_int<47, true> int47;
      typedef ac_int<47, false> uint47;
      typedef ac_int<48, true> int48;
      typedef ac_int<48, false> uint48;
      typedef ac_int<49, true> int49;
      typedef ac_int<49, false> uint49;
      typedef ac_int<50, true> int50;
      typedef ac_int<50, false> uint50;
      typedef ac_int<51, true> int51;
      typedef ac_int<51, false> uint51;
      typedef ac_int<52, true> int52;
      typedef ac_int<52, false> uint52;
      typedef ac_int<53, true> int53;
      typedef ac_int<53, false> uint53;
      typedef ac_int<54, true> int54;
      typedef ac_int<54, false> uint54;
      typedef ac_int<55, true> int55;
      typedef ac_int<55, false> uint55;
      typedef ac_int<56, true> int56;
      typedef ac_int<56, false> uint56;
      typedef ac_int<57, true> int57;
      typedef ac_int<57, false> uint57;
      typedef ac_int<58, true> int58;
      typedef ac_int<58, false> uint58;
      typedef ac_int<59, true> int59;
      typedef ac_int<59, false> uint59;
      typedef ac_int<60, true> int60;
      typedef ac_int<60, false> uint60;
      typedef ac_int<61, true> int61;
      typedef ac_int<61, false> uint61;
      typedef ac_int<62, true> int62;
      typedef ac_int<62, false> uint62;
      typedef ac_int<63, true> int63;
      typedef ac_int<63, false> uint63;
   }


   using namespace ac_intN;
# 5310 "../../../ac_types/include/ac_int.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"







   template <ac_special_val V, int W, bool S>
   __attribute__((always_inline)) inline ac_int<W, S> value(ac_int<W, S>)
   {
      ac_int<W, S> r;
      return r.template set_val<V>();
   }

   template <ac_special_val V, int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
   __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O> value(ac_fixed<W, I, S, Q, O>);
# 5364 "../../../ac_types/include/ac_int.h"
   template <ac_special_val val> __attribute__((always_inline)) inline bool value(bool); template <> __attribute__((always_inline)) inline bool value<AC_VAL_0>(bool) { return (bool)0; } template <> __attribute__((always_inline)) inline bool value<AC_VAL_DC>(bool) { bool x; return x; } template <> __attribute__((always_inline)) inline bool value<AC_VAL_QUANTUM>(bool) { return (bool)1; } template <> __attribute__((always_inline)) inline bool value<AC_VAL_MAX>(bool) { return (bool)(false ? ~(((bool)1) << (1 - 1)) : (bool)-1); } template <> __attribute__((always_inline)) inline bool value<AC_VAL_MIN>(bool) { return (bool)(false ? ((bool)1) << (1 - 1) : (bool)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline char value(char); template <> __attribute__((always_inline)) inline char value<AC_VAL_0>(char) { return (char)0; } template <> __attribute__((always_inline)) inline char value<AC_VAL_DC>(char) { char x; return x; } template <> __attribute__((always_inline)) inline char value<AC_VAL_QUANTUM>(char) { return (char)1; } template <> __attribute__((always_inline)) inline char value<AC_VAL_MAX>(char) { return (char)(true ? ~(((char)1) << (8 - 1)) : (char)-1); } template <> __attribute__((always_inline)) inline char value<AC_VAL_MIN>(char) { return (char)(true ? ((char)1) << (8 - 1) : (char)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline signed char value(signed char); template <> __attribute__((always_inline)) inline signed char value<AC_VAL_0>(signed char) { return (signed char)0; } template <> __attribute__((always_inline)) inline signed char value<AC_VAL_DC>(signed char) { signed char x; return x; } template <> __attribute__((always_inline)) inline signed char value<AC_VAL_QUANTUM>(signed char) { return (signed char)1; } template <> __attribute__((always_inline)) inline signed char value<AC_VAL_MAX>(signed char) { return (signed char)(true ? ~(((signed char)1) << (8 - 1)) : (signed char)-1); } template <> __attribute__((always_inline)) inline signed char value<AC_VAL_MIN>(signed char) { return (signed char)(true ? ((signed char)1) << (8 - 1) : (signed char)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline unsigned char value(unsigned char); template <> __attribute__((always_inline)) inline unsigned char value<AC_VAL_0>(unsigned char) { return (unsigned char)0; } template <> __attribute__((always_inline)) inline unsigned char value<AC_VAL_DC>(unsigned char) { unsigned char x; return x; } template <> __attribute__((always_inline)) inline unsigned char value<AC_VAL_QUANTUM>(unsigned char) { return (unsigned char)1; } template <> __attribute__((always_inline)) inline unsigned char value<AC_VAL_MAX>(unsigned char) { return (unsigned char)(false ? ~(((unsigned char)1) << (8 - 1)) : (unsigned char)-1); } template <> __attribute__((always_inline)) inline unsigned char value<AC_VAL_MIN>(unsigned char) { return (unsigned char)(false ? ((unsigned char)1) << (8 - 1) : (unsigned char)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline short value(short); template <> __attribute__((always_inline)) inline short value<AC_VAL_0>(short) { return (short)0; } template <> __attribute__((always_inline)) inline short value<AC_VAL_DC>(short) { short x; return x; } template <> __attribute__((always_inline)) inline short value<AC_VAL_QUANTUM>(short) { return (short)1; } template <> __attribute__((always_inline)) inline short value<AC_VAL_MAX>(short) { return (short)(true ? ~(((short)1) << (16 - 1)) : (short)-1); } template <> __attribute__((always_inline)) inline short value<AC_VAL_MIN>(short) { return (short)(true ? ((short)1) << (16 - 1) : (short)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline unsigned short value(unsigned short); template <> __attribute__((always_inline)) inline unsigned short value<AC_VAL_0>(unsigned short) { return (unsigned short)0; } template <> __attribute__((always_inline)) inline unsigned short value<AC_VAL_DC>(unsigned short) { unsigned short x; return x; } template <> __attribute__((always_inline)) inline unsigned short value<AC_VAL_QUANTUM>(unsigned short) { return (unsigned short)1; } template <> __attribute__((always_inline)) inline unsigned short value<AC_VAL_MAX>(unsigned short) { return (unsigned short)(false ? ~(((unsigned short)1) << (16 - 1)) : (unsigned short)-1); } template <> __attribute__((always_inline)) inline unsigned short value<AC_VAL_MIN>(unsigned short) { return (unsigned short)(false ? ((unsigned short)1) << (16 - 1) : (unsigned short)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline int value(int); template <> __attribute__((always_inline)) inline int value<AC_VAL_0>(int) { return (int)0; } template <> __attribute__((always_inline)) inline int value<AC_VAL_DC>(int) { int x; return x; } template <> __attribute__((always_inline)) inline int value<AC_VAL_QUANTUM>(int) { return (int)1; } template <> __attribute__((always_inline)) inline int value<AC_VAL_MAX>(int) { return (int)(true ? ~(((int)1) << (32 - 1)) : (int)-1); } template <> __attribute__((always_inline)) inline int value<AC_VAL_MIN>(int) { return (int)(true ? ((int)1) << (32 - 1) : (int)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline unsigned int value(unsigned int); template <> __attribute__((always_inline)) inline unsigned int value<AC_VAL_0>(unsigned int) { return (unsigned int)0; } template <> __attribute__((always_inline)) inline unsigned int value<AC_VAL_DC>(unsigned int) { unsigned int x; return x; } template <> __attribute__((always_inline)) inline unsigned int value<AC_VAL_QUANTUM>(unsigned int) { return (unsigned int)1; } template <> __attribute__((always_inline)) inline unsigned int value<AC_VAL_MAX>(unsigned int) { return (unsigned int)(false ? ~(((unsigned int)1) << (32 - 1)) : (unsigned int)-1); } template <> __attribute__((always_inline)) inline unsigned int value<AC_VAL_MIN>(unsigned int) { return (unsigned int)(false ? ((unsigned int)1) << (32 - 1) : (unsigned int)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline long value(long); template <> __attribute__((always_inline)) inline long value<AC_VAL_0>(long) { return (long)0; } template <> __attribute__((always_inline)) inline long value<AC_VAL_DC>(long) { long x; return x; } template <> __attribute__((always_inline)) inline long value<AC_VAL_QUANTUM>(long) { return (long)1; } template <> __attribute__((always_inline)) inline long value<AC_VAL_MAX>(long) { return (long)(true ? ~(((long)1) << (ac_private::long_w - 1)) : (long)-1); } template <> __attribute__((always_inline)) inline long value<AC_VAL_MIN>(long) { return (long)(true ? ((long)1) << (ac_private::long_w - 1) : (long)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline unsigned long value(unsigned long); template <> __attribute__((always_inline)) inline unsigned long value<AC_VAL_0>(unsigned long) { return (unsigned long)0; } template <> __attribute__((always_inline)) inline unsigned long value<AC_VAL_DC>(unsigned long) { unsigned long x; return x; } template <> __attribute__((always_inline)) inline unsigned long value<AC_VAL_QUANTUM>(unsigned long) { return (unsigned long)1; } template <> __attribute__((always_inline)) inline unsigned long value<AC_VAL_MAX>(unsigned long) { return (unsigned long)(false ? ~(((unsigned long)1) << (ac_private::long_w - 1)) : (unsigned long)-1); } template <> __attribute__((always_inline)) inline unsigned long value<AC_VAL_MIN>(unsigned long) { return (unsigned long)(false ? ((unsigned long)1) << (ac_private::long_w - 1) : (unsigned long)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline Slong value(Slong); template <> __attribute__((always_inline)) inline Slong value<AC_VAL_0>(Slong) { return (Slong)0; } template <> __attribute__((always_inline)) inline Slong value<AC_VAL_DC>(Slong) { Slong x; return x; } template <> __attribute__((always_inline)) inline Slong value<AC_VAL_QUANTUM>(Slong) { return (Slong)1; } template <> __attribute__((always_inline)) inline Slong value<AC_VAL_MAX>(Slong) { return (Slong)(true ? ~(((Slong)1) << (64 - 1)) : (Slong)-1); } template <> __attribute__((always_inline)) inline Slong value<AC_VAL_MIN>(Slong) { return (Slong)(true ? ((Slong)1) << (64 - 1) : (Slong)0); }
   template <ac_special_val val> __attribute__((always_inline)) inline Ulong value(Ulong); template <> __attribute__((always_inline)) inline Ulong value<AC_VAL_0>(Ulong) { return (Ulong)0; } template <> __attribute__((always_inline)) inline Ulong value<AC_VAL_DC>(Ulong) { Ulong x; return x; } template <> __attribute__((always_inline)) inline Ulong value<AC_VAL_QUANTUM>(Ulong) { return (Ulong)1; } template <> __attribute__((always_inline)) inline Ulong value<AC_VAL_MAX>(Ulong) { return (Ulong)(false ? ~(((Ulong)1) << (64 - 1)) : (Ulong)-1); } template <> __attribute__((always_inline)) inline Ulong value<AC_VAL_MIN>(Ulong) { return (Ulong)(false ? ((Ulong)1) << (64 - 1) : (Ulong)0); }
# 5387 "../../../ac_types/include/ac_int.h"
   namespace ac
   {


      template <ac_special_val V, int W, bool S>
      __attribute__((always_inline)) inline bool init_array(ac_int<W, S>* a, int n)
      {
         ac_int<W, S> t = value<V>(*a);
         for(int i = 0; i < n; i++)
            a[i] = t;
         return true;
      }

      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(bool* a, int n) { bool t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(char* a, int n) { char t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(signed char* a, int n) { signed char t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(unsigned char* a, int n) { unsigned char t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(signed short* a, int n) { signed short t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(unsigned short* a, int n) { unsigned short t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(signed int* a, int n) { signed int t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(unsigned int* a, int n) { unsigned int t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(signed long* a, int n) { signed long t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(unsigned long* a, int n) { unsigned long t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(signed long long* a, int n) { signed long long t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
      template <ac_special_val V> __attribute__((always_inline)) inline bool init_array(unsigned long long* a, int n) { unsigned long long t = value<V>(*a); for(int i = 0; i < n; i++) a[i] = t; return true; }
   }





#pragma GCC diagnostic pop
# 47 "../../../ac_types/include/ac_fixed.h" 2
# 73 "../../../ac_types/include/ac_fixed.h"
   namespace ac_private
   {
      template <typename T>
      struct rt_ac_fixed_T
      {
         template <int W, int I, bool S>
         struct op1
         {
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::mult mult;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::plus plus;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::minus2 minus;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::minus minus2;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::logic logic;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::div2 div;
            typedef typename T::template rt_T<ac_fixed<W, I, S, AC_TRN, AC_WRAP>>::div div2;
         };
      };

   }
# 101 "../../../ac_types/include/ac_fixed.h"
   template <int W, int I, bool S = true, ac_q_mode Q = AC_TRN, ac_o_mode O = AC_WRAP>
   class ac_fixed : private ac_private::iv<(W + 31 + !S) / 32, false>



   {
      enum
      {
         N = (W + 31 + !S) / 32
      };

      template <int W2>
      struct rt_priv
      {
         enum
         {
            w_shiftl = ((W + W2) > (1) ? (W + W2) : (1))
         };
         typedef ac_fixed<w_shiftl, I, S> shiftl;
      };

      typedef ac_private::iv<N, false> Base;

      __attribute__((always_inline)) inline constexpr void bit_adjust()
      {
         Base::v.template bit_adjust<W, S>();
      }
      __attribute__((always_inline)) inline constexpr Base& base()
      {
         return *this;
      }
      __attribute__((always_inline)) inline constexpr const Base& base() const
      {
         return *this;
      }

      __attribute__((always_inline)) inline void overflow_adjust(bool underflow, bool overflow)
      {
         if(O == AC_WRAP)
         {
            bit_adjust();
            return;
         }
         else if(O == AC_SAT_ZERO)
         {
            if((overflow || underflow))
               ac_private::iv_extend<0>(Base::v, 0);
            else
               bit_adjust();
         }
         else if(S)
         {
            if(overflow)
            {
               if(0 <= N - 1) { for(int idx = 0; idx < N - 1 + (exclude == loop_limit::include); ++idx) {
# 155 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 155 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, ~0); } } } else { for(int idx = 0; idx >= N - 1 + (exclude == loop_limit::exclude); --idx) {
# 155 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 155 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, ~0); } } };
               Base::v.set(N - 1, (~((unsigned)~0 << ((W - 1) & 31))));
            }
            else if(underflow)
            {
               if(0 <= N - 1) { for(int idx = 0; idx < N - 1 + (exclude == loop_limit::include); ++idx) {
# 160 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 160 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, 0); } } } else { for(int idx = 0; idx >= N - 1 + (exclude == loop_limit::exclude); --idx) {
# 160 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 160 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, 0); } } };
               Base::v.set(N - 1, ((unsigned)~0 << ((W - 1) & 31)));
               if(O == AC_SAT_SYM)
                  Base::v.set(0, Base::v[0] | 1);
            }
            else
               bit_adjust();
         }
         else
         {
            if(overflow)
            {
               if(0 <= N - 1) { for(int idx = 0; idx < N - 1 + (exclude == loop_limit::include); ++idx) {
# 172 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 172 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, ~0); } } } else { for(int idx = 0; idx >= N - 1 + (exclude == loop_limit::exclude); --idx) {
# 172 "../../../ac_types/include/ac_fixed.h"
#pragma HLS UNROLL
# 172 "../../../ac_types/include/ac_fixed.h"
               { Base::v.set(idx, ~0); } } };
               Base::v.set(N - 1, ~((unsigned)~0 << (W & 31)));
            }
            else if(underflow)
               ac_private::iv_extend<0>(Base::v, 0);
            else
               bit_adjust();
         }
      }

      constexpr __attribute__((always_inline)) inline bool quantization_adjust(bool qb, bool r, bool s)
      {
         if(Q == AC_TRN)
            return false;
         if(Q == AC_RND_ZERO)
            qb &= s || r;
         else if(Q == AC_RND_MIN_INF)
            qb &= r;
         else if(Q == AC_RND_INF)
            qb &= !s || r;
         else if(Q == AC_RND_CONV)
            qb &= (Base::v[0] & 1) || r;
         else if(Q == AC_RND_CONV_ODD)
            qb &= (!(Base::v[0] & 1)) || r;
         else if(Q == AC_TRN_ZERO)
            qb = s && (qb || r);
         return ac_private::iv_uadd_carry(Base::v, qb, Base::v);
      }

      __attribute__((always_inline)) inline bool is_neg() const
      {
         return S && Base::v[N - 1] < 0;
      }

    public:
      static const int width = W;
      static const int i_width = I;
      static const int iwidth = I;
      static const bool sign = S;
      static const ac_o_mode o_mode = O;
      static const ac_q_mode q_mode = Q;
      static const ac_q_mode qmode = Q;
      static const ac_o_mode omode = O;
      static const int e_width = 0;

      template <int W2, int I2, bool S2>
      struct rt
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2,
            mult_w = W + W2,
            mult_i = I + I2,
            mult_s = S || S2,
            plus_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1 + ((F) > (F2) ? (F) : (F2)),
            plus_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1,
            plus_s = S || S2,
            minus_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1 + ((F) > (F2) ? (F) : (F2)),
            minus_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1,
            minus_s = true,
            div_w = W + ((W2 - I2) > (0) ? (W2 - I2) : (0)) + S2,
            div_i = I + (W2 - I2) + S2,
            div_s = S || S2,
            logic_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + ((F) > (F2) ? (F) : (F2)),
            logic_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))),
            logic_s = S || S2
         };
         typedef ac_fixed<mult_w, mult_i, mult_s> mult;
         typedef ac_fixed<plus_w, plus_i, plus_s> plus;
         typedef ac_fixed<minus_w, minus_i, minus_s> minus;
         typedef ac_fixed<logic_w, logic_i, logic_s> logic;
         typedef ac_fixed<div_w, div_i, div_s> div;
         typedef ac_fixed<W, I, S> arg1;
      };

      template <typename T>
      struct rt_T
      {
         typedef typename ac_private::map<T>::t map_T;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::mult mult;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::plus plus;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::minus minus;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::minus2 minus2;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::logic logic;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::div div;
         typedef typename ac_private::rt_ac_fixed_T<map_T>::template op1<W, I, S>::div2 div2;
         typedef ac_fixed<W, I, S> arg1;
      };

      struct rt_unary
      {
         enum
         {
            neg_w = W + 1,
            neg_i = I + 1,
            neg_s = true,
            mag_sqr_w = 2 * W - S,
            mag_sqr_i = 2 * I - S,
            mag_sqr_s = false,
            mag_w = W + S,
            mag_i = I + S,
            mag_s = false,
            leading_sign_w = ac::log2_ceil<W + !S>::val,
            leading_sign_s = false
         };
         typedef ac_int<leading_sign_w, leading_sign_s> leading_sign;
         typedef ac_fixed<neg_w, neg_i, neg_s> neg;
         typedef ac_fixed<mag_sqr_w, mag_sqr_i, mag_sqr_s> mag_sqr;
         typedef ac_fixed<mag_w, mag_i, mag_s> mag;
         template <unsigned N>
         struct set
         {
            enum
            {
               sum_w = W + ac::log2_ceil<N>::val,
               sum_i = (sum_w - W) + I,
               sum_s = S
            };
            typedef ac_fixed<sum_w, sum_i, sum_s> sum;
         };
      };

      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      friend class ac_fixed;
      constexpr ac_fixed()
      {






      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline constexpr ac_fixed(const ac_fixed<W2, I2, S2, Q2, O2>& op)
      {
         enum
         {
            N2 = (W2 + 31 + !S2) / 32,
            F = W - I,
            F2 = W2 - I2,
            QUAN_INC = F2 > F && !(Q == AC_TRN || (Q == AC_TRN_ZERO && !S2))
         };
         bool carry = false;

         if(F2 == F)
            Base::operator=(op);
         else if(F2 > F)
         {
            op.template const_shift_r<F2 - F>(*this);

            if(Q != AC_TRN && !(Q == AC_TRN_ZERO && !S2))
            {
               bool qb = (F2 - F > W2) ? (op.v[N2 - 1] < 0) : (bool)op[F2 - F - 1];
               bool r =
                   (F2 > F + 1) ? !ac_private::iv_equal_zeros_to<((F2 > F + 1) ? F2 - F - 1 : 1), N2>(op.v) : false;
               carry = quantization_adjust(qb, r, S2 && op.v[N2 - 1] < 0);
            }
         }
         else
            op.template const_shift_l<F - F2>(*this);


         if(O != AC_WRAP &&
            ((!S && S2) || (I - S < I2 - S2 + (QUAN_INC || (S2 && O == AC_SAT_SYM && (O2 != AC_SAT_SYM || F2 > F))))))
         {
            bool deleted_bits_zero = (!(W & 31) && S) || 0 == (Base::v[N - 1] >> (W & 31));
            bool deleted_bits_one = (!(W & 31) && S) || 0 == (~(Base::v[N - 1] >> (W & 31)));
            bool neg_src = false;
            if((F2 - F + 32 * N) < W2)
            {
               bool all_ones = ac_private::iv_equal_ones_from<F2 - F + 32 * N, N2>(op.v);
               deleted_bits_zero =
                   deleted_bits_zero && (carry ? all_ones : ac_private::iv_equal_zeros_from<F2 - F + 32 * N, N2>(op.v));
               deleted_bits_one =
                   deleted_bits_one &&
                   (carry ? ac_private::iv_equal_ones_from<1 + F2 - F + 32 * N, N2>(op.v) && !op[F2 - F + 32 * N] :
                            all_ones);
               neg_src = S2 && op.v[N2 - 1] < 0 && 0 == (carry & all_ones);
            }
            else
               neg_src = S2 && op.v[N2 - 1] < 0 && Base::v[N - 1] < 0;
            bool neg_trg = S && (bool)this->operator[](W - 1);
            bool overflow = !neg_src && (neg_trg || !deleted_bits_zero);
            bool underflow = neg_src && (!neg_trg || !deleted_bits_one);
            if(O == AC_SAT_SYM && S && S2)
               underflow |=
                   neg_src && (W > 1 ? ac_private::iv_equal_zeros_to<((W > 1) ? W - 1 : 1), N>(Base::v) : true);
            overflow_adjust(underflow, overflow);
         }
         else
            bit_adjust();
      }

      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_fixed(const ac_int<W2, S2>& op)
      {
         ac_fixed<W2, W2, S2> f_op;
         f_op.base().operator=(op);
         *this = f_op;
      }

      template <int W2>
      typename rt_priv<W2>::shiftl shiftl() const
      {
         typedef typename rt_priv<W2>::shiftl shiftl_t;
         shiftl_t r;
         Base::template const_shift_l<W2>(r);
         return r;
      }

      __attribute__((always_inline)) inline constexpr ac_fixed(bool b)
      {
         *this = (ac_int<1, false>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(char b)
      {
         *this = (ac_int<8, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(signed char b)
      {
         *this = (ac_int<8, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(unsigned char b)
      {
         *this = (ac_int<8, false>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(signed short b)
      {
         *this = (ac_int<16, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(unsigned short b)
      {
         *this = (ac_int<16, false>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(signed int b)
      {
         *this = (ac_int<32, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(unsigned int b)
      {
         *this = (ac_int<32, false>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(signed long b)
      {
         *this = (ac_int<ac_private::long_w, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(unsigned long b)
      {
         *this = (ac_int<ac_private::long_w, false>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(Slong b)
      {
         *this = (ac_int<64, true>)b;
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(Ulong b)
      {
         *this = (ac_int<64, false>)b;
      }

      __attribute__((always_inline)) inline constexpr ac_fixed(double d)
      {

         double di = ac_private::ldexpr<-(I + !S + ((32 - W - !S) & 31))>(d);
         bool o = false, qb = false, r = false;
         bool neg_src = d < 0;
         Base::conv_from_fraction(di, &qb, &r, &o);
         quantization_adjust(qb, r, neg_src);

         neg_src &= o || Base::v[N - 1] < 0;

         if(O != AC_WRAP)
         {
            bool overflow = false, underflow = false;
            bool neg_trg = S && (bool)this->operator[](W - 1);
            if(o)
            {
               overflow = !neg_src;
               underflow = neg_src;
            }
            else
            {
               bool deleted_bits_zero = !(W & 31) & S || !(Base::v[N - 1] >> (W & 31));
               bool deleted_bits_one = !(W & 31) & S || !~(Base::v[N - 1] >> (W & 31));
               overflow = !neg_src && (neg_trg || !deleted_bits_zero);
               underflow = neg_src && (!neg_trg || !deleted_bits_one);
            }
            if(O == AC_SAT_SYM && S)
               underflow |=
                   neg_src && (W > 1 ? ac_private::iv_equal_zeros_to<((W > 1) ? W - 1 : 1), N>(Base::v) : true);
            overflow_adjust(underflow, overflow);
         }
         else
            bit_adjust();
      }
      __attribute__((always_inline)) inline constexpr ac_fixed(float d)
      {

         float di = ac_private::ldexpr<-(I + !S + ((32 - W - !S) & 31))>(d);
         bool o = false, qb = false, r = false;
         bool neg_src = d < 0;
         Base::conv_from_fraction(di, &qb, &r, &o);
         quantization_adjust(qb, r, neg_src);

         neg_src &= o || Base::v[N - 1] < 0;

         if(O != AC_WRAP)
         {
            bool overflow = false, underflow = false;
            bool neg_trg = S && (bool)this->operator[](W - 1);
            if(o)
            {
               overflow = !neg_src;
               underflow = neg_src;
            }
            else
            {
               bool deleted_bits_zero = !(W & 31) & S || !(Base::v[N - 1] >> (W & 31));
               bool deleted_bits_one = !(W & 31) & S || !~(Base::v[N - 1] >> (W & 31));
               overflow = !neg_src && (neg_trg || !deleted_bits_zero);
               underflow = neg_src && (!neg_trg || !deleted_bits_one);
            }
            if(O == AC_SAT_SYM && S)
               underflow |=
                   neg_src && (W > 1 ? ac_private::iv_equal_zeros_to<((W > 1) ? W - 1 : 1), N>(Base::v) : true);
            overflow_adjust(underflow, overflow);
         }
         else
            bit_adjust();
      }
      template <size_t NN>
      __attribute__((always_inline)) inline constexpr ac_fixed(const char (&str)[NN])
      {
         *this = ac_fixed((double)Base::hex2doubleConverter::get(str));
      }






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"





      template <ac_special_val V>
      __attribute__((always_inline)) inline ac_fixed& set_val()
      {
         if(V == AC_VAL_DC)
         {
            ac_fixed r;
            Base::operator=(r);
            bit_adjust();
         }
         else if(V == AC_VAL_0 || V == AC_VAL_MIN || V == AC_VAL_QUANTUM)
         {
            Base::operator=(0);
            if(S && V == AC_VAL_MIN)
            {
               const unsigned rem = (W - 1) & 31;
               Base::v.set(N - 1, ((unsigned)~0 << rem));
               if(O == AC_SAT_SYM)
               {
                  if(W == 1)
                     Base::v.set(0, 0);
                  else
                     Base::v.set(0, Base::v[0] | 1);
               }
            }
            else if(V == AC_VAL_QUANTUM)
               Base::v.set(0, 1);
         }
         else if(V == AC_VAL_MAX)
         {
            Base::operator=(-1);
            const unsigned int rem = (32 - W - (unsigned)!S) & 31;
            Base::v.set(N - 1, ((unsigned)(-1) >> 1) >> rem);
         }
         return *this;
      }




#pragma GCC diagnostic pop







      __attribute__((always_inline)) inline ac_int<((I) > (1) ? (I) : (1)), S> to_ac_int() const
      {
         return ((ac_fixed<((I) > (1) ? (I) : (1)), ((I) > (1) ? (I) : (1)), S>)*this).template slc<((I) > (1) ? (I) : (1))>(0);
      }


      __attribute__((always_inline)) inline int to_int() const
      {
         return ((I - W) >= 32) ? 0 : (signed int)to_ac_int();
      }
      __attribute__((always_inline)) inline unsigned to_uint() const
      {
         return ((I - W) >= 32) ? 0 : (unsigned int)to_ac_int();
      }
      __attribute__((always_inline)) inline long to_long() const
      {
         return ((I - W) >= ac_private::long_w) ? 0 : (signed long)to_ac_int();
      }
      __attribute__((always_inline)) inline unsigned long to_ulong() const
      {
         return ((I - W) >= ac_private::long_w) ? 0 : (unsigned long)to_ac_int();
      }
      __attribute__((always_inline)) inline Slong to_int64() const
      {
         return ((I - W) >= 64) ? 0 : (Slong)to_ac_int();
      }
      __attribute__((always_inline)) inline Ulong to_uint64() const
      {
         return ((I - W) >= 64) ? 0 : (Ulong)to_ac_int();
      }
      __attribute__((always_inline)) inline constexpr double to_double() const
      {
         return ac_private::ldexpr<I - W>(Base::to_double());
      }
      __attribute__((always_inline)) inline constexpr float to_float() const
      {
         return ac_private::ldexpr<I - W>(Base::to_float());
      }
      __attribute__((always_inline)) inline int length() const
      {
         return W;
      }


      template <int W1, bool S1>
      __attribute__((always_inline)) inline operator ac_int<W1, S1>() const
      {
         ac_int<((I) > (1) ? (I) : (1)), S> temp = to_ac_int();
         return (ac_int<W1, S1>)temp;
      }
      __attribute__((always_inline)) inline operator bool() const
      {
         return !Base::equal_zero();
      }

      __attribute__((always_inline)) inline operator char() const
      {
         return (char)to_int();
      }

      __attribute__((always_inline)) inline operator signed char() const
      {
         return (signed char)to_int();
      }

      __attribute__((always_inline)) inline operator unsigned char() const
      {
         return (unsigned char)to_uint();
      }

      __attribute__((always_inline)) inline operator short() const
      {
         return (short)to_int();
      }

      __attribute__((always_inline)) inline operator unsigned short() const
      {
         return (unsigned short)to_uint();
      }
      __attribute__((always_inline)) inline operator int() const
      {
         return to_int();
      }
      __attribute__((always_inline)) inline operator unsigned() const
      {
         return to_uint();
      }
      __attribute__((always_inline)) inline operator long() const
      {
         return to_long();
      }
      __attribute__((always_inline)) inline operator unsigned long() const
      {
         return to_ulong();
      }
      __attribute__((always_inline)) inline operator Slong() const
      {
         return to_int64();
      }
      __attribute__((always_inline)) inline operator Ulong() const
      {
         return to_uint64();
      }
      __attribute__((always_inline)) inline constexpr explicit operator double() const
      {
         return to_double();
      }
      __attribute__((always_inline)) inline constexpr explicit operator float() const
      {
         return to_float();
      }

      __attribute__((always_inline)) inline std::string to_string(ac_base_mode base_rep, bool sign_mag = false) const
      {


         char r[(W - ((((W - I) < (I) ? (W - I) : (I))) < (0) ? (((W - I) < (I) ? (W - I) : (I))) : (0)) + 31) / 32 * 32 + 5] = {0};
         int i = 0;
         if(sign_mag)
            r[i++] = is_neg() ? '-' : '+';
         else if(base_rep == AC_DEC && is_neg())
            r[i++] = '-';
         if(base_rep != AC_DEC)
         {
            r[i++] = '0';
            r[i++] = base_rep == AC_BIN ? 'b' : (base_rep == AC_OCT ? 'o' : 'x');
         }
         ac_fixed<W + 1, I + 1, true> t;
         if((base_rep == AC_DEC || sign_mag) && is_neg())
            t = operator-();
         else
            t = *this;
         ac_fixed<((I + 1) > (1) ? (I + 1) : (1)), ((I + 1) > (1) ? (I + 1) : (1)), true> i_part = t;
         ac_fixed<((W - I) > (1) ? (W - I) : (1)), 0, false> f_part = t;
         i += ac_private::to_string(i_part.v, ((I + 1) > (1) ? (I + 1) : (1)), sign_mag, base_rep, false, r + i);
         if(W - I > 0)
         {
            r[i++] = '.';
            if(!ac_private::to_string(f_part.v, W - I, false, base_rep, true, r + i))
               r[--i] = 0;
         }
         if(!i)
         {
            r[0] = '0';
            r[1] = 0;
         }
         return std::string(r);
      }
      __attribute__((always_inline)) inline static std::string type_name()
      {
         const char* tf[] = {"false", "true"};
         const char* q[] = {"AC_TRN", "AC_RND", "AC_TRN_ZERO", "AC_RND_ZERO",
                            "AC_RND_INF", "AC_RND_MIN_INF", "AC_RND_CONV", "AC_RND_CONV_ODD"};
         const char* o[] = {"AC_WRAP", "AC_SAT", "AC_SAT_ZERO", "AC_SAT_SYM"};
         std::string r = "ac_fixed<";
         r += ac_int<32, true>(W).to_string(AC_DEC) + ',';
         r += ac_int<32, true>(I).to_string(AC_DEC) + ',';
         r += tf[S];
         r += ',';
         r += q[Q];
         r += ',';
         r += o[O];
         r += '>';
         return r;
      }


      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      typename rt<W2, I2, S2>::mult operator*(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         auto op1_local = *this;
         op1_local.bit_adjust();
         auto op2_local = op2;
         op2_local.bit_adjust();
         typename rt<W2, I2, S2>::mult r;
         op1_local.Base::mult(op2_local, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      typename rt<W2, I2, S2>::plus operator+(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         typename rt<W2, I2, S2>::plus r;
         if(F == F2)
            Base::add(op2, r);
         else if(F > F2)
            Base::add(op2.template shiftl<F - F2>(), r);
         else
            shiftl<F2 - F>().add(op2, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      typename rt<W2, I2, S2>::minus operator-(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         typename rt<W2, I2, S2>::minus r;
         if(F == F2)
            Base::sub(op2, r);
         else if(F > F2)
            Base::sub(op2.template shiftl<F - F2>(), r);
         else
            shiftl<F2 - F>().sub(op2, r);
         r.bit_adjust();
         return r;
      }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wenum-compare"

      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline typename rt<W2, I2, S2>::div operator/(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         typename rt<W2, I2, S2>::div r;
         enum
         {
            Num_w = W + ((W2 - I2) > (0) ? (W2 - I2) : (0)),
            Num_i = I,
            Num_w_minus = Num_w + S,
            Num_i_minus = Num_i + S,
            N1 = ac_fixed<Num_w, Num_i, S>::N,
            N1minus = ac_fixed<Num_w_minus, Num_i_minus, S>::N,
            N2 = ac_fixed<W2, I2, S2>::N,
            N2minus = ac_fixed<W2 + S2, I2 + S2, S2>::N,
            num_s = S + (N1minus > N1),
            den_s = S2 + (N2minus > N2),
            Nr = rt<W2, I2, S2>::div::N
         };
         ac_fixed<Num_w, Num_i, S> t = *this;
         t.template div<num_s, den_s>(op2, r);
         r.bit_adjust();
         return r;
      }

#pragma GCC diagnostic pop


      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator*=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator*(op2);
         return *this;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator+=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator+(op2);
         return *this;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator-=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator-(op2);
         return *this;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator/=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator/(op2);
         return *this;
      }



      __attribute__((always_inline)) inline ac_fixed& operator++()
      {
         ac_fixed<1, I - W + 1, false> q;
         q.template set_val<AC_VAL_QUANTUM>();
         operator+=(q);
         return *this;
      }
      __attribute__((always_inline)) inline ac_fixed& operator--()
      {
         ac_fixed<1, I - W + 1, false> q;
         q.template set_val<AC_VAL_QUANTUM>();
         operator-=(q);
         return *this;
      }

      __attribute__((always_inline)) inline const ac_fixed operator++(int)
      {
         ac_fixed t = *this;
         ac_fixed<1, I - W + 1, false> q;
         q.template set_val<AC_VAL_QUANTUM>();
         operator+=(q);
         return t;
      }
      __attribute__((always_inline)) inline const ac_fixed operator--(int)
      {
         ac_fixed t = *this;
         ac_fixed<1, I - W + 1, false> q;
         q.template set_val<AC_VAL_QUANTUM>();
         operator-=(q);
         return t;
      }

      __attribute__((always_inline)) inline ac_fixed operator+() const
      {
         ac_fixed t = *this;
         t.bit_adjust();
         return t;
      }
      __attribute__((always_inline)) inline typename rt_unary::neg operator-() const
      {
         typename rt_unary::neg r;
         Base::neg(r);
         r.bit_adjust();
         return r;
      }

      __attribute__((always_inline)) inline bool operator!() const
      {
         return Base::equal_zero();
      }


      __attribute__((always_inline)) inline ac_fixed<W + !S, I + !S, true> operator~() const
      {
         ac_fixed<W + !S, I + !S, true> r;
         Base::bitwise_complement(r);
         r.bit_adjust();
         return r;
      }

      __attribute__((always_inline)) inline ac_fixed<W, I, false> bit_complement() const
      {
         ac_fixed<W, I, false> r;
         Base::bitwise_complement(r);
         r.bit_adjust();
         return r;
      }

      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline typename rt<W2, I2, S2>::logic operator&(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         typename rt<W2, I2, S2>::logic r;
         if(F == F2)
            Base::bitwise_and(op2, r);
         else if(F > F2)
            Base::bitwise_and(op2.template shiftl<F - F2>(), r);
         else
            shiftl<F2 - F>().bitwise_and(op2, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline typename rt<W2, I2, S2>::logic operator|(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         typename rt<W2, I2, S2>::logic r;
         if(F == F2)
            Base::bitwise_or(op2, r);
         else if(F > F2)
            Base::bitwise_or(op2.template shiftl<F - F2>(), r);
         else
            shiftl<F2 - F>().bitwise_or(op2, r);
         r.bit_adjust();
         return r;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline typename rt<W2, I2, S2>::logic operator^(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         typename rt<W2, I2, S2>::logic r;
         if(F == F2)
            Base::bitwise_xor(op2, r);
         else if(F > F2)
            Base::bitwise_xor(op2.template shiftl<F - F2>(), r);
         else
            shiftl<F2 - F>().bitwise_xor(op2, r);
         r.bit_adjust();
         return r;
      }

      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator&=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator&(op2);
         return *this;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator|=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator|(op2);
         return *this;
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline ac_fixed& operator^=(const ac_fixed<W2, I2, S2, Q2, O2>& op2)
      {
         *this = this->operator^(op2);
         return *this;
      }

      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator<<(const ac_int<W2, true>& op2) const
      {

         ac_fixed r;
         Base::shift_l2(op2.to_int(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator<<(const ac_int<W2, false>& op2) const
      {

         ac_fixed r;
         Base::shift_l(op2.to_uint(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator>>(const ac_int<W2, true>& op2) const
      {

         ac_fixed r;
         Base::shift_r2(op2.to_int(), r);
         r.bit_adjust();
         return r;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator>>(const ac_int<W2, false>& op2) const
      {

         ac_fixed r;
         Base::shift_r(op2.to_uint(), r);
         r.bit_adjust();
         return r;
      }

      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator<<=(const ac_int<W2, true>& op2)
      {

         Base r;
         Base::shift_l2(op2.to_int(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator<<=(const ac_int<W2, false>& op2)
      {

         Base r;
         Base::shift_l(op2.to_uint(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator>>=(const ac_int<W2, true>& op2)
      {

         Base r;
         Base::shift_r2(op2.to_int(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }
      template <int W2>
      __attribute__((always_inline)) inline ac_fixed operator>>=(const ac_int<W2, false>& op2)
      {

         Base r;
         Base::shift_r(op2.to_uint(), r);
         Base::operator=(r);
         bit_adjust();
         return *this;
      }

      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator==(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return Base::equal(op2);
         else if(F > F2)
            return Base::equal(op2.template shiftl<F - F2>());
         else
            return shiftl<F2 - F>().equal(op2);
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator!=(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return !Base::equal(op2);
         else if(F > F2)
            return !Base::equal(op2.template shiftl<F - F2>());
         else
            return !shiftl<F2 - F>().equal(op2);
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator<(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return Base::less_than(op2);
         else if(F > F2)
            return Base::less_than(op2.template shiftl<F - F2>());
         else
            return shiftl<F2 - F>().less_than(op2);
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator>=(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return !Base::less_than(op2);
         else if(F > F2)
            return !Base::less_than(op2.template shiftl<F - F2>());
         else
            return !shiftl<F2 - F>().less_than(op2);
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator>(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return Base::greater_than(op2);
         else if(F > F2)
            return Base::greater_than(op2.template shiftl<F - F2>());
         else
            return shiftl<F2 - F>().greater_than(op2);
      }
      template <int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2>
      __attribute__((always_inline)) inline bool operator<=(const ac_fixed<W2, I2, S2, Q2, O2>& op2) const
      {
         enum
         {
            F = W - I,
            F2 = W2 - I2
         };
         if(F == F2)
            return !Base::greater_than(op2);
         else if(F > F2)
            return !Base::greater_than(op2.template shiftl<F - F2>());
         else
            return !shiftl<F2 - F>().greater_than(op2);
      }
      __attribute__((always_inline)) inline bool operator==(double d) const
      {
         if(is_neg() != (d < 0.0))
            return false;
         double di = ac_private::ldexpr<-(I + !S + ((32 - W - !S) & 31))>(d);
         bool overflow, qb, r;
         ac_fixed<W, I, S> t;
         t.conv_from_fraction(di, &qb, &r, &overflow);
         if(qb || r || overflow)
            return false;
         return operator==(t);
      }
      __attribute__((always_inline)) inline bool operator!=(double d) const
      {
         return !operator==(d);
      }
      __attribute__((always_inline)) inline bool operator<(double d) const
      {
         if(is_neg() != (d < 0.0))
            return is_neg();
         double di = ac_private::ldexpr<-(I + !S + ((32 - W - !S) & 31))>(d);
         bool overflow, qb, r;
         ac_fixed<W, I, S> t;
         t.conv_from_fraction(di, &qb, &r, &overflow);
         if(is_neg() && overflow)
            return false;
         return (!is_neg() && overflow) || ((qb || r) && operator<=(t)) || operator<(t);
      }
      __attribute__((always_inline)) inline bool operator>=(double d) const
      {
         return !operator<(d);
      }
      __attribute__((always_inline)) inline bool operator>(double d) const
      {
         if(is_neg() != (d < 0.0))
            return !is_neg();
         double di = ac_private::ldexpr<-(I + !S + ((32 - W - !S) & 31))>(d);
         bool overflow, qb, r;
         ac_fixed<W, I, S> t;
         t.conv_from_fraction(di, &qb, &r, &overflow);
         if(!is_neg() && overflow)
            return false;
         return (is_neg() && overflow) || operator>(t);
      }
      __attribute__((always_inline)) inline bool operator<=(double d) const
      {
         return !operator>(d);
      }

      struct range_ref_fixed
      {
         ac_fixed& ref;
         int low;
         int high;
         constexpr range_ref_fixed(ac_fixed& _ref, int _high, int _low) : ref(_ref), low(_low), high(_high)
         {
         }

         template <int W2, bool S2>
         __attribute__((always_inline)) inline constexpr const range_ref_fixed& operator=(const ac_int<W2, S2>& op) const
         {
            ref.set_slc(high, low, op);
            return *this;
         }

         template <int W2, bool S2>
         __attribute__((always_inline)) inline operator const ac_int<W2, S2>() const
         {
            const ac_int<W, S> r = ref.slc(high, low);
            return r;
         }
         template <class RRF>
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const RRF& b) const
         {
            return operator=(b.operator const ac_int<W, S>());
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const int& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline constexpr const range_ref_fixed& operator=(const unsigned& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const long& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const unsigned long& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const Slong& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const Ulong& b) const
         {
            return operator=(ac_int<W, S>(b));
         }
         __attribute__((always_inline)) inline const range_ref_fixed& operator=(const range_ref_fixed& b) const
         {
            return operator=(b.operator const ac_int<W, S>());
         }
      };


      template <int WS, int WX, bool SX>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(const ac_int<WX, SX>& index) const
      {
         ac_int<WS, S> r;
         ;
         ac_int<WX - SX, false> uindex = index;
         Base::shift_r(uindex.to_uint(), r);
         r.bit_adjust();
         return r;
      }
      __attribute__((always_inline)) inline ac_int<W, S> operator()(int Hi, int Lo) const
      {
         return slc(Hi, Lo);
      }
      __attribute__((always_inline)) inline constexpr const range_ref_fixed operator()(int Hi, int Lo)
      {
         return range_ref_fixed(*this, Hi, Lo);
      }

      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline ac_int<W, S> operator()(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo) const
      {
         int Hi = _Hi.to_int();
         int Lo = _Lo.to_int();
         ;
         ;
         return operator()(Hi, Lo);
      }
      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline range_ref_fixed operator()(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo)
      {
         int Hi = _Hi.to_int();
         int Lo = _Lo.to_int();
         ;
         ;
         return range_ref_fixed(*this, Hi, Lo);
      }

      __attribute__((always_inline)) inline ac_int<W, S> range(int Hi, int Lo) const
      {
         return operator()(Hi, Lo);
      }
      template <int W1, int W2, bool S1, bool S2>
      __attribute__((always_inline)) inline ac_int<W, S> range(const ac_int<W1, S1>& _Hi, const ac_int<W1, S2>& _Lo) const
      {
         return operator()(_Hi, _Lo);
      }
      __attribute__((always_inline)) inline range_ref_fixed range(int Hi, int Lo)
      {
         return range_ref_fixed(*this, Hi, Lo);
      }

      template <int WS>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(signed index) const
      {
         ac_int<WS, S> r;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         Base::shift_r(uindex, r);
         r.bit_adjust();
         return r;
      }
      template <int WS>
      __attribute__((always_inline)) inline ac_int<WS, S> slc(unsigned uindex) const
      {
         ac_int<WS, S> r;
         Base::shift_r(uindex, r);
         r.bit_adjust();
         return r;
      }
      __attribute__((always_inline)) inline ac_int<W, S> slc(int Hi, int Lo) const
      {
         ;
         ;
         ;
         ;
         ac_int<W, S> r;
         Base::shift_l(W - 1 - Hi, r);
         r.bit_adjust();
         return r >> (Lo + W - 1 - Hi);
      }

      template <int W2, bool S2, int WX, bool SX>
      __attribute__((always_inline)) inline ac_fixed& set_slc(const ac_int<WX, SX> lsb, const ac_int<W2, S2>& slc)
      {
         ;
         ac_int<WX - SX, false> ulsb = lsb;
         Base::set_slc(ulsb.to_uint(), W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_fixed& set_slc(signed lsb, const ac_int<W2, S2>& slc)
      {
         ;
         unsigned ulsb = lsb & ((unsigned)~0 >> 1);
         Base::set_slc(ulsb, W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_fixed& set_slc(unsigned ulsb, const ac_int<W2, S2>& slc)
      {
         ;
         Base::set_slc(ulsb, W2, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline constexpr ac_fixed& set_slc(int umsb, int ulsb, const ac_int<W2, S2>& slc)
      {



         Base::set_slc(ulsb, umsb + 1 - ulsb, (ac_int<W2, true>)slc);
         bit_adjust();
         return *this;
      }

      class ac_bitref
      {
         ac_fixed& d_bv;
         unsigned d_index;

       public:
         ac_bitref(ac_fixed* bv, unsigned index = 0) : d_bv(*bv), d_index(index)
         {
         }
         __attribute__((always_inline)) inline operator bool() const
         {
            return (d_index < W) ? (d_bv.v[d_index >> 5] >> (d_index & 31) & 1) : 0;
         }

         __attribute__((always_inline)) inline ac_bitref operator=(int val)
         {

            if(d_index < W)
            {
               d_bv.v.set(d_index >> 5, d_bv.v[d_index >> 5] ^
                                            ((d_bv.v[d_index >> 5] ^ (val << (d_index & 31))) & 1 << (d_index & 31)));
               d_bv.bit_adjust();
            }
            return *this;
         }
         template <int W2, bool S2>
         __attribute__((always_inline)) inline ac_bitref operator=(const ac_int<W2, S2>& val)
         {
            return operator=(val.to_int());
         }
         __attribute__((always_inline)) inline ac_bitref operator=(const ac_bitref& val)
         {
            return operator=((int)(bool)val);
         }
      };

      __attribute__((always_inline)) inline ac_bitref operator[](unsigned int uindex)
      {
         ;
         ac_bitref bvh(this, uindex);
         return bvh;
      }
      __attribute__((always_inline)) inline ac_bitref operator[](int index)
      {
         ;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         ac_bitref bvh(this, uindex);
         return bvh;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline ac_bitref operator[](const ac_int<W2, S2>& index)
      {
         ;
         ;
         ac_int<W2 - S2, false> uindex = index;
         ac_bitref bvh(this, uindex.to_uint());
         return bvh;
      }

      __attribute__((always_inline)) inline bool operator[](unsigned int uindex) const
      {
         ;
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex & 31) & 1) : 0;
      }
      __attribute__((always_inline)) inline bool operator[](int index) const
      {
         ;
         ;
         unsigned uindex = index & ((unsigned)~0 >> 1);
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex & 31) & 1) : 0;
      }
      template <int W2, bool S2>
      __attribute__((always_inline)) inline bool operator[](const ac_int<W2, S2>& index) const
      {
         ;
         ;
         ac_int<W2 - S2, false> uindex = index;
         return (uindex < W) ? (Base::v[uindex >> 5] >> (uindex.to_uint() & 31) & 1) : 0;
      }
      __attribute__((always_inline)) inline typename rt_unary::leading_sign leading_sign() const
      {
         unsigned ls = Base::leading_bits(S & (Base::v[N - 1] < 0)) - (32 * N - W) - S;
         return ls;
      }
      __attribute__((always_inline)) inline typename rt_unary::leading_sign leading_sign(bool& all_sign) const
      {
         unsigned ls = Base::leading_bits(S & (Base::v[N - 1] < 0)) - (32 * N - W) - S;
         all_sign = (ls == W - S);
         return ls;
      }

      template <int WE, bool SE>
      __attribute__((always_inline)) inline bool normalize(ac_int<WE, SE>& exp)
      {
         ac_int<W, S> m = this->template slc<W>(0);
         bool r = m.normalize(exp);
         this->set_slc(0, m);
         return r;
      }


      template <int WE, bool SE>
      __attribute__((always_inline)) inline bool normalize_RME(ac_int<WE, SE>& exp)
      {
         ac_int<W, S> m = this->template slc<W>(0);
         bool r = m.normalize_RME(exp);
         this->set_slc(0, m);
         return r;
      }
      __attribute__((always_inline)) inline void bit_fill_hex(const char* str)
      {


         ac_int<W, S> x;
         x.bit_fill_hex(str);
         set_slc(0, x);
      }
      template <int N>
      __attribute__((always_inline)) inline void bit_fill(const int (&ivec)[N], bool bigendian = true)
      {







         ac_int<W, S> x;
         x.bit_fill(ivec, bigendian);
         set_slc(0, x);
      }
   };

   namespace ac
   {
      template <typename T>
      struct ac_fixed_represent
      {
         enum
         {
            t_w = ac_private::c_type_params<T>::W,
            t_i = t_w,
            t_s = ac_private::c_type_params<T>::S
         };
         typedef ac_fixed<t_w, t_i, t_s> type;
      };
      template <>
      struct ac_fixed_represent<float>
      {
      };
      template <>
      struct ac_fixed_represent<double>
      {
      };
      template <int W, bool S>
      struct ac_fixed_represent<ac_int<W, S>>
      {
         typedef ac_fixed<W, W, S> type;
      };
      template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
      struct ac_fixed_represent<ac_fixed<W, I, S, Q, O>>
      {
         typedef ac_fixed<W, I, S, Q, O> type;
      };
   }

   namespace ac_private
   {

      template <int W2, int I2, bool S2>
      struct rt_ac_fixed_T<ac_fixed<W2, I2, S2>>
      {
         typedef ac_fixed<W2, I2, S2> fx2_t;
         template <int W, int I, bool S>
         struct op1
         {
            typedef ac_fixed<W, I, S> fx_t;
            typedef typename fx_t::template rt<W2, I2, S2>::mult mult;
            typedef typename fx_t::template rt<W2, I2, S2>::plus plus;
            typedef typename fx_t::template rt<W2, I2, S2>::minus minus;
            typedef typename fx2_t::template rt<W, I, S>::minus minus2;
            typedef typename fx_t::template rt<W2, I2, S2>::logic logic;
            typedef typename fx_t::template rt<W2, I2, S2>::div div;
            typedef typename fx2_t::template rt<W, I, S>::div div2;
         };
      };

      template <int W2, bool S2>
      struct rt_ac_fixed_T<ac_int<W2, S2>>
      {
         typedef ac_fixed<W2, W2, S2> fx2_t;
         template <int W, int I, bool S>
         struct op1
         {
            typedef ac_fixed<W, I, S> fx_t;
            typedef typename fx_t::template rt<W2, W2, S2>::mult mult;
            typedef typename fx_t::template rt<W2, W2, S2>::plus plus;
            typedef typename fx_t::template rt<W2, W2, S2>::minus minus;
            typedef typename fx2_t::template rt<W, I, S>::minus minus2;
            typedef typename fx_t::template rt<W2, W2, S2>::logic logic;
            typedef typename fx_t::template rt<W2, W2, S2>::div div;
            typedef typename fx2_t::template rt<W, I, S>::div div2;
         };
      };

      template <typename T>
      struct rt_ac_fixed_T<c_type<T>>
      {
         typedef typename ac::ac_fixed_represent<T>::type fx2_t;
         enum
         {
            W2 = fx2_t::width,
            I2 = W2,
            S2 = fx2_t::sign
         };
         template <int W, int I, bool S>
         struct op1
         {
            typedef ac_fixed<W, I, S> fx_t;
            typedef typename fx_t::template rt<W2, W2, S2>::mult mult;
            typedef typename fx_t::template rt<W2, W2, S2>::plus plus;
            typedef typename fx_t::template rt<W2, W2, S2>::minus minus;
            typedef typename fx2_t::template rt<W, I, S>::minus minus2;
            typedef typename fx_t::template rt<W2, W2, S2>::logic logic;
            typedef typename fx_t::template rt<W2, W2, S2>::div div;
            typedef typename fx2_t::template rt<W, I, S>::div div2;
         };
      };
   }



   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, true, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b ? -1 : 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(signed char b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned char b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(signed short b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned short b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(signed int b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned int b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(signed long b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned long b)
   {
      v.set(0, b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(Ulong b)
   {
      v.set(0, (int)b & 1);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<1, 1, false, AC_TRN, AC_WRAP>::ac_fixed(Slong b)
   {
      v.set(0, (int)b & 1);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, true, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, false, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, true, AC_TRN, AC_WRAP>::ac_fixed(signed char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, true, AC_TRN, AC_WRAP>::ac_fixed(unsigned char b)
   {
      v.set(0, (signed char)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<8, 8, false, AC_TRN, AC_WRAP>::ac_fixed(signed char b)
   {
      v.set(0, (unsigned char)b);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, true, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, false, AC_TRN, AC_WRAP>::ac_fixed(bool b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, true, AC_TRN, AC_WRAP>::ac_fixed(signed char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, true, AC_TRN, AC_WRAP>::ac_fixed(unsigned char b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, false, AC_TRN, AC_WRAP>::ac_fixed(signed char b)
   {
      v.set(0, (unsigned short)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, true, AC_TRN, AC_WRAP>::ac_fixed(signed short b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned short b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, true, AC_TRN, AC_WRAP>::ac_fixed(unsigned short b)
   {
      v.set(0, (signed short)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<16, 16, false, AC_TRN, AC_WRAP>::ac_fixed(signed short b)
   {
      v.set(0, (unsigned short)b);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, true, AC_TRN, AC_WRAP>::ac_fixed(signed int b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, true, AC_TRN, AC_WRAP>::ac_fixed(unsigned int b)
   {
      v.set(0, b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, false, AC_TRN, AC_WRAP>::ac_fixed(signed int b)
   {
      v.set(0, b);
      v.set(1, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, false, AC_TRN, AC_WRAP>::ac_fixed(unsigned int b)
   {
      v.set(0, b);
      v.set(1, 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, true, AC_TRN, AC_WRAP>::ac_fixed(Slong b)
   {
      v.set(0, (int)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, true, AC_TRN, AC_WRAP>::ac_fixed(Ulong b)
   {
      v.set(0, (int)b);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, false, AC_TRN, AC_WRAP>::ac_fixed(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<32, 32, false, AC_TRN, AC_WRAP>::ac_fixed(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, 0);
   }

   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<64, 64, true, AC_TRN, AC_WRAP>::ac_fixed(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<64, 64, true, AC_TRN, AC_WRAP>::ac_fixed(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<64, 64, false, AC_TRN, AC_WRAP>::ac_fixed(Slong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)((Ulong)b >> 32));
      v.set(2, 0);
   }
   template <>
   __attribute__((always_inline)) inline constexpr ac_fixed<64, 64, false, AC_TRN, AC_WRAP>::ac_fixed(Ulong b)
   {
      v.set(0, (int)b);
      v.set(1, (int)(b >> 32));
      v.set(2, 0);
   }



   template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
   __attribute__((always_inline)) inline std::ostream& operator<<(std::ostream& os, const ac_fixed<W, I, S, Q, O>& x)
   {



      return os;
   }

   template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
   __attribute__((always_inline)) inline std::istream& operator>>(std::istream& in, ac_fixed<W, I, S, Q, O>& x)
   {





      return in;
   }
# 1931 "../../../ac_types/include/ac_fixed.h"
   namespace ac
   {
      namespace ops_with_other_types
      {

         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::mult operator *( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator *(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::plus operator +( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator +(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::minus operator -( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator -(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::div operator /( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator /(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator >>(ac_int<1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator <<(ac_int<1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::logic operator &( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator &(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::logic operator |( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator |(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<1, 1, false>::template rt<W, I, S>::logic operator ^( bool i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<1, 1, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, bool i_op) { return op.operator ^(ac_fixed<1, 1, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator ==(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator !=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator >(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator >=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator <(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator <=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(bool op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<1, 1, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator +=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator -=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator *=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator /=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator >>=(ac_int<1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator <<=(ac_int<1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator &=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator |=(ac_fixed<1, 1, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, bool op2) { return op.operator ^=(ac_fixed<1, 1, false>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::mult operator *( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator *(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::plus operator +( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator +(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::minus operator -( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator -(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::div operator /( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator /(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator >>(ac_int<8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator <<(ac_int<8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator &( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator &(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator |( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator |(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator ^( char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, char i_op) { return op.operator ^(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator ==(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator !=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator >(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator >=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator <(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator <=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator +=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator -=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator *=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator /=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator >>=(ac_int<8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator <<=(ac_int<8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator &=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator |=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, char op2) { return op.operator ^=(ac_fixed<8, 8, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::mult operator *( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator *(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::plus operator +( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator +(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::minus operator -( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator -(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::div operator /( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator /(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator >>(ac_int<8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator <<(ac_int<8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator &( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator &(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator |( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator |(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, true>::template rt<W, I, S>::logic operator ^( signed char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, signed char i_op) { return op.operator ^(ac_fixed<8, 8, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator ==(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator !=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator >(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator >=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator <(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator <=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(signed char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator +=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator -=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator *=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator /=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator >>=(ac_int<8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator <<=(ac_int<8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator &=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator |=(ac_fixed<8, 8, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, signed char op2) { return op.operator ^=(ac_fixed<8, 8, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::mult operator *( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator *(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::plus operator +( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator +(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::minus operator -( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator -(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::div operator /( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator /(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator >>(ac_int<8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator <<(ac_int<8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::logic operator &( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator &(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::logic operator |( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator |(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<8, 8, false>::template rt<W, I, S>::logic operator ^( unsigned char i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<8, 8, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, unsigned char i_op) { return op.operator ^(ac_fixed<8, 8, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator ==(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator !=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator >(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator >=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator <(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator <=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(unsigned char op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<8, 8, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator +=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator -=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator *=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator /=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator >>=(ac_int<8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator <<=(ac_int<8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator &=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator |=(ac_fixed<8, 8, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, unsigned char op2) { return op.operator ^=(ac_fixed<8, 8, false>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::mult operator *( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator *(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::plus operator +( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator +(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::minus operator -( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator -(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::div operator /( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator /(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator >>(ac_int<16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator <<(ac_int<16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::logic operator &( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator &(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::logic operator |( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator |(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, true>::template rt<W, I, S>::logic operator ^( short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, short i_op) { return op.operator ^(ac_fixed<16, 16, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator ==(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator !=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator >(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator >=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator <(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator <=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator +=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator -=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator *=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator /=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator >>=(ac_int<16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator <<=(ac_int<16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator &=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator |=(ac_fixed<16, 16, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, short op2) { return op.operator ^=(ac_fixed<16, 16, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::mult operator *( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator *(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::plus operator +( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator +(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::minus operator -( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator -(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::div operator /( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator /(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator >>(ac_int<16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator <<(ac_int<16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::logic operator &( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator &(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::logic operator |( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator |(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<16, 16, false>::template rt<W, I, S>::logic operator ^( unsigned short i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<16, 16, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, unsigned short i_op) { return op.operator ^(ac_fixed<16, 16, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator ==(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator !=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator >(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator >=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator <(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator <=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(unsigned short op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<16, 16, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator +=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator -=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator *=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator /=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator >>=(ac_int<16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator <<=(ac_int<16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator &=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator |=(ac_fixed<16, 16, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, unsigned short op2) { return op.operator ^=(ac_fixed<16, 16, false>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::mult operator *( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator *(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::plus operator +( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator +(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::minus operator -( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator -(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::div operator /( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator /(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator >>(ac_int<32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator <<(ac_int<32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::logic operator &( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator &(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::logic operator |( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator |(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, true>::template rt<W, I, S>::logic operator ^( int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, int i_op) { return op.operator ^(ac_fixed<32, 32, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator ==(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator !=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator >(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator >=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator <(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator <=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator +=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator -=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator *=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator /=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator >>=(ac_int<32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator <<=(ac_int<32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator &=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator |=(ac_fixed<32, 32, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, int op2) { return op.operator ^=(ac_fixed<32, 32, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::mult operator *( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator *(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::plus operator +( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator +(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::minus operator -( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator -(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::div operator /( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator /(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator >>(ac_int<32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator <<(ac_int<32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::logic operator &( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator &(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::logic operator |( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator |(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<32, 32, false>::template rt<W, I, S>::logic operator ^( unsigned int i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<32, 32, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, unsigned int i_op) { return op.operator ^(ac_fixed<32, 32, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator ==(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator !=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator >(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator >=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator <(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator <=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(unsigned int op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<32, 32, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator +=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator -=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator *=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator /=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator >>=(ac_int<32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator <<=(ac_int<32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator &=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator |=(ac_fixed<32, 32, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, unsigned int op2) { return op.operator ^=(ac_fixed<32, 32, false>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::mult operator *( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator *(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::plus operator +( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator +(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::minus operator -( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator -(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::div operator /( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator /(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator >>(ac_int<ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator <<(ac_int<ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::logic operator &( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator &(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::logic operator |( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator |(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, true>::template rt<W, I, S>::logic operator ^( long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, long i_op) { return op.operator ^(ac_fixed<ac_private::long_w, ac_private::long_w, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator ==(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator !=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator >(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator >=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator <(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator <=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator +=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator -=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator *=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator /=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator >>=(ac_int<ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator <<=(ac_int<ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator &=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator |=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, long op2) { return op.operator ^=(ac_fixed<ac_private::long_w, ac_private::long_w, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::mult operator *( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator *(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::plus operator +( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator +(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::minus operator -( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator -(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::div operator /( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator /(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator >>(ac_int<ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator <<(ac_int<ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::logic operator &( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator &(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::logic operator |( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator |(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<ac_private::long_w, ac_private::long_w, false>::template rt<W, I, S>::logic operator ^( unsigned long i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<ac_private::long_w, ac_private::long_w, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, unsigned long i_op) { return op.operator ^(ac_fixed<ac_private::long_w, ac_private::long_w, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator ==(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator !=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator >(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator >=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator <(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator <=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(unsigned long op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator +=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator -=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator *=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator /=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator >>=(ac_int<ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator <<=(ac_int<ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator &=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator |=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, unsigned long op2) { return op.operator ^=(ac_fixed<ac_private::long_w, ac_private::long_w, false>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::mult operator *( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator *(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::plus operator +( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator +(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::minus operator -( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator -(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::div operator /( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::div operator /( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator /(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator >>(ac_int<64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator <<(ac_int<64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::logic operator &( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator &(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::logic operator |( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator |(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, true>::template rt<W, I, S>::logic operator ^( Slong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, true>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, Slong i_op) { return op.operator ^(ac_fixed<64, 64, true>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator ==(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator !=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator >(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator >=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator <(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator <=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(Slong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, true>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator +=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator -=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator *=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator /=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator >>=(ac_int<64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator <<=(ac_int<64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator &=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator |=(ac_fixed<64, 64, true>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, Slong op2) { return op.operator ^=(ac_fixed<64, 64, true>(op2)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::mult operator *( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator *(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::plus operator +( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator +(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::minus operator -( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator -(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::div operator /( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::div operator /( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator /(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::arg1 operator >>( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator >>(ac_int<64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::arg1 operator <<( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator <<(ac_int<64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::logic operator &( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator &(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::logic operator |( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator |(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<64, 64, false>::template rt<W, I, S>::logic operator ^( Ulong i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<64, 64, false>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, Ulong i_op) { return op.operator ^(ac_fixed<64, 64, false>(i_op)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator ==(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator ==(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator ==(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator !=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator !=(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator !=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator >(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator >(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator >=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator >=(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator >=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator <(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator <(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator <=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline bool operator <=(Ulong op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<64, 64, false>(op2).operator <=(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator +=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator -=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator *=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator /=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator >>=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator >>=(ac_int<64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S> operator <<=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator <<=(ac_int<64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator &=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator |=(ac_fixed<64, 64, false>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, Ulong op2) { return op.operator ^=(ac_fixed<64, 64, false>(op2)); }

      }

   }
# 2003 "../../../ac_types/include/ac_fixed.h"
   namespace ac
   {
      namespace ops_with_other_types
      {

         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::mult operator *( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator *(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::mult operator *( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator *(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::plus operator +( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator +(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::plus operator +( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator +(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::minus operator -( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator -(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::minus operator -( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator -(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::div operator /( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator /(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::div operator /( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator /(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::logic operator &( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator &(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::logic operator &( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator &(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::logic operator |( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator |(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::logic operator |( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator |(ac_fixed<WI, WI, SI>(i_op)); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<WI, WI, SI>::template rt<W, I, S>::logic operator ^( const ac_int<WI, SI>& i_op, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(i_op).operator ^(op); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline typename ac_fixed<W, I, S>::template rt<WI, WI, SI>::logic operator ^( const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& i_op) { return op.operator ^(ac_fixed<WI, WI, SI>(i_op)); }

         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator ==(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator ==(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator ==(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator ==(op); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator !=(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator !=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator !=(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator !=(op); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator >(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator >(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator >(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator >(op); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator >=(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator >=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator >=(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator >=(op); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator <(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator <(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator <(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator <(op); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator <=(const ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator <=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline bool operator <=(ac_int<WI, SI>& op2, const ac_fixed<W, I, S, Q, O>& op) { return ac_fixed<WI, WI, SI>(op2).operator <=(op); }

         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator +=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator +=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator +=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator +=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator -=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator -=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator -=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator -=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator *=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator *=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator *=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator *=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator /=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator /=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator /=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator /=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator %=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator %=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator %=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator %=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator &=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator &=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator &=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator &=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator |=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator |=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator |=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator |=(op2.to_ac_int()); }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O>& operator ^=(ac_fixed<W, I, S, Q, O>& op, const ac_int<WI, SI>& op2) { return op.operator ^=(ac_fixed<WI, WI, SI>(op2)); } template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O, int WI, bool SI> __attribute__((always_inline)) inline ac_int<WI, SI>& operator ^=(ac_int<WI, SI>& op, const ac_fixed<W, I, S, Q, O>& op2) { return op.operator ^=(op2.to_ac_int()); }



         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator==(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator==(op);
         }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator!=(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator!=(op);
         }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator>(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator<(op);
         }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator<(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator>(op);
         }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator<=(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator>=(op);
         }
         template <int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
         __attribute__((always_inline)) inline bool operator>=(double op, const ac_fixed<W, I, S, Q, O>& op2)
         {
            return op2.operator<=(op);
         }



      }
   }

   using namespace ac::ops_with_other_types;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"







   template <ac_special_val V, int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
   __attribute__((always_inline)) inline ac_fixed<W, I, S, Q, O> value(ac_fixed<W, I, S, Q, O>)
   {
      ac_fixed<W, I, S> r;
      return r.template set_val<V>();
   }

   namespace ac
   {


      template <ac_special_val V, int W, int I, bool S, ac_q_mode Q, ac_o_mode O>
      __attribute__((always_inline)) inline bool init_array(ac_fixed<W, I, S, Q, O>* a, int n)
      {
         ac_fixed<W, I, S> t = value<V>(*a);
         for(int i = 0; i < n; i++)
            a[i] = t;
         return true;
      }

      __attribute__((always_inline)) inline ac_fixed<54, 2, true> frexp_d(double d, ac_int<11, true>& exp)
      {
         enum
         {
            Min_Exp = -1022,
            Max_Exp = 1023,
            Mant_W = 52,
            Denorm_Min_Exp = Min_Exp - Mant_W
         };
         if(!d)
         {
            exp = 0;
            return 0;
         }
         int exp_i;
         double f0 = frexp(d, &exp_i);
        
                                                                                          ;
        
                                                                                             ;
         exp_i--;
         int rshift = exp_i < Min_Exp ? Min_Exp - exp_i : (exp_i > Min_Exp && f0 < 0 && f0 >= -0.5) ? -1 : 0;
         exp = exp_i + rshift;
         ac_int<Mant_W + 2, true> f_i = f0 * ((Ulong)1 << (Mant_W + 1 - rshift));
         ac_fixed<Mant_W + 2, 2, true> r;
         r.set_slc(0, f_i);
         return r;
      }
      __attribute__((always_inline)) inline ac_fixed<25, 2, true> frexp_f(float f, ac_int<8, true>& exp)
      {
         enum
         {
            Min_Exp = -126,
            Max_Exp = 127,
            Mant_W = 23,
            Denorm_Min_Exp = Min_Exp - Mant_W
         };
         if(!f)
         {
            exp = 0;
            return 0;
         }
         int exp_i;
         float f0 = frexpf(f, &exp_i);
        
                                                                                        ;
        
                                                                                           ;
         exp_i--;
         int rshift = exp_i < Min_Exp ? Min_Exp - exp_i : (exp_i >= Min_Exp && f0 < 0 && f0 >= -0.5) ? -1 : 0;
         exp = exp_i + rshift;
         ac_int<Mant_W + 2, true> f_i = f0 * (1 << (Mant_W + 1 - rshift));
         ac_fixed<Mant_W + 2, 2, true> r;
         r.set_slc(0, f_i);
         return r;
      }

      __attribute__((always_inline)) inline ac_fixed<53, 1, false> frexp_sm_d(double d, ac_int<11, true>& exp, bool& sign)
      {
         enum
         {
            Min_Exp = -1022,
            Max_Exp = 1023,
            Mant_W = 52,
            Denorm_Min_Exp = Min_Exp - Mant_W
         };
         if(!d)
         {
            exp = 0;
            sign = false;
            return 0;
         }
         int exp_i;
         bool s = d < 0;
         double f0 = frexp(s ? -d : d, &exp_i);
        
                                                                                          ;
        
                                                                                             ;
         exp_i--;
         int rshift = exp_i < Min_Exp ? Min_Exp - exp_i : 0;
         exp = exp_i + rshift;
         ac_int<Mant_W + 1, false> f_i = f0 * ((Ulong)1 << (Mant_W + 1 - rshift));
         ac_fixed<Mant_W + 1, 1, false> r;
         r.set_slc(0, f_i);
         sign = s;
         return r;
      }
      __attribute__((always_inline)) inline ac_fixed<24, 1, false> frexp_sm_f(float f, ac_int<8, true>& exp, bool& sign)
      {
         enum
         {
            Min_Exp = -126,
            Max_Exp = 127,
            Mant_W = 23,
            Denorm_Min_Exp = Min_Exp - Mant_W
         };
         if(!f)
         {
            exp = 0;
            sign = false;
            return 0;
         }
         int exp_i;
         bool s = f < 0;
         float f0 = frexp(s ? -f : f, &exp_i);
        
                                                                                        ;
        
                                                                                           ;
         exp_i--;
         int rshift = exp_i < Min_Exp ? Min_Exp - exp_i : 0;
         exp = exp_i + rshift;
         ac_int<24, false> f_i = f0 * (1 << (Mant_W + 1 - rshift));
         ac_fixed<24, 1, false> r;
         r.set_slc(0, f_i);
         sign = s;
         return r;
      }
   }







#pragma GCC diagnostic pop
# 44 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h" 2
# 86 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
   template <int W, int I, int E, ac_q_mode Q = AC_TRN>
   class ac_float;

   namespace ac_private
   {
      typedef ac_float<54, 2, 11> ac_float_cdouble_t;
      typedef ac_float<25, 2, 8> ac_float_cfloat_t;

      template <typename T>
      struct rt_ac_float_T
      {
         template <int W, int I, int E>
         struct op1
         {
            typedef ac_float<W, I, E> fl_t;
            typedef typename T::template rt_T<fl_t>::mult mult;
            typedef typename T::template rt_T<fl_t>::plus plus;
            typedef typename T::template rt_T<fl_t>::minus2 minus;
            typedef typename T::template rt_T<fl_t>::minus minus2;
            typedef typename T::template rt_T<fl_t>::logic logic;
            typedef typename T::template rt_T<fl_t>::div2 div;
            typedef typename T::template rt_T<fl_t>::div div2;
         };
      };


      __attribute__((always_inline)) inline ac_float_cdouble_t double_to_ac_float(double d);
      __attribute__((always_inline)) inline ac_float_cfloat_t float_to_ac_float(float f);
   }





   template <int W, int I, int E, ac_q_mode Q>
   class ac_float
   {
      enum
      {
         NO_UN = true,
         S = true,
         S2 = true,
         SR = true
      };

    public:
      typedef ac_fixed<W, I, S> mant_t;
      typedef ac_int<E, true> exp_t;
      mant_t m;
      exp_t e;

      void set_mantissa(const ac_fixed<W, I, S>& man)
      {
         m = man;
      }
      void set_exp(const ac_int<E, true>& exp)
      {
         if(E)
            e = exp;
      }

    private:
      __attribute__((always_inline)) inline bool is_neg() const
      {
         return m < 0;
      }

      enum
      {
         NZ_E = !!E,
         MIN_EXP = static_cast<int>(static_cast<unsigned>(-NZ_E) << (E - NZ_E)),
         MAX_EXP = (1 << (E - NZ_E)) - 1
      };

    public:
      static const int width = W;
      static const int i_width = I;
      static const int e_width = E;
      static const bool sign = S;
      static const ac_q_mode q_mode = Q;
      static const ac_o_mode o_mode = AC_SAT;

      template <int W2, int I2, int E2>
      struct rt
      {
         enum
         {

            F = W - I,
            F2 = W2 - I2,
            mult_w = W + W2,
            mult_i = I + I2,
            mult_e = ((E) > (E2) ? (E) : (E2)) + 1,
            mult_s = S || S2,
            plus_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1 + ((F) > (F2) ? (F) : (F2)),
            plus_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1,
            plus_e = ((E) > (E2) ? (E) : (E2)),
            plus_s = S || S2,
            minus_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1 + ((F) > (F2) ? (F) : (F2)),
            minus_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + 1,
            minus_e = ((E) > (E2) ? (E) : (E2)),
            minus_s = true,
            div_w = W + ((W2 - I2) > (0) ? (W2 - I2) : (0)) + S2,
            div_i = I + (W2 - I2) + S2,
            div_e = ((E) > (E2) ? (E) : (E2)) + 1,
            div_s = S || S2,
            logic_w = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))) + ((F) > (F2) ? (F) : (F2)),
            logic_i = ((I + (S2 && !S)) > (I2 + (S && !S2)) ? (I + (S2 && !S)) : (I2 + (S && !S2))),
            logic_s = S || S2,
            logic_e = ((E) > (E2) ? (E) : (E2))
         };
         typedef ac_float<mult_w, mult_i, mult_e> mult;
         typedef ac_float<plus_w, plus_i, plus_e> plus;
         typedef ac_float<minus_w, minus_i, minus_e> minus;
         typedef ac_float<logic_w, logic_i, logic_e> logic;
         typedef ac_float<div_w, div_i, div_e> div;
         typedef ac_float arg1;
      };

      template <int WI, bool SI>
      struct rt_i
      {
         enum
         {
            lshift_w = W,
            lshift_i = I,
            lshift_s = S,
            lshift_e_0 = exp_t::template rt<WI, SI>::plus::width,
            lshift_e = ((lshift_e_0) < (24) ? (lshift_e_0) : (24)),
            rshift_w = W,
            rshift_i = I,
            rshift_s = S,
            rshift_e_0 = exp_t::template rt<WI, SI>::minus::width,
            rshift_e = ((rshift_e_0) < (24) ? (rshift_e_0) : (24))
         };
         typedef ac_float<lshift_w, lshift_i, lshift_e> lshift;
         typedef ac_float<rshift_w, rshift_i, rshift_e> rshift;
      };

      template <typename T>
      struct rt_T
      {
         typedef typename ac_private::map<T>::t map_T;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::mult mult;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::plus plus;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::minus minus;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::minus2 minus2;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::logic logic;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::div div;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::div2 div2;
         typedef ac_float arg1;
      };

      template <typename T>
      struct rt_T2
      {
         typedef typename ac_private::map<T>::t map_T;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::mult mult;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::plus plus;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::minus2 minus;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::minus minus2;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::logic logic;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::div2 div;
         typedef typename ac_private::rt_ac_float_T<map_T>::template op1<W, I, E>::div div2;
         typedef ac_float arg1;
      };

      struct rt_unary
      {
         enum
         {
            neg_w = W + 1,
            neg_i = I + 1,
            neg_e = E,
            neg_s = true,
            mag_sqr_w = 2 * W - S + NO_UN,
            mag_sqr_i = 2 * I - S + NO_UN,
            mag_sqr_e = E,
            mag_sqr_s = false | NO_UN,
            mag_w = W + S + NO_UN,
            mag_i = I + S + NO_UN,
            mag_e = E,
            mag_s = false | NO_UN,
            to_fx_i = I + MAX_EXP,
            to_fx_w = W + MAX_EXP - MIN_EXP,
            to_fx_s = S,
            to_i_w = ((to_fx_i) > (1) ? (to_fx_i) : (1)),
            to_i_s = S
         };
         typedef ac_float<neg_w, neg_i, neg_e> neg;
         typedef ac_float<mag_sqr_w, mag_sqr_i, mag_sqr_e> mag_sqr;
         typedef ac_float<mag_w, mag_i, mag_e> mag;
         template <unsigned N>
         struct set
         {
            enum
            {
               sum_w = W + ac::log2_ceil<N>::val,
               sum_i = (sum_w - W) + I,
               sum_e = E,
               sum_s = S
            };
            typedef ac_float<sum_w, sum_i, sum_e> sum;
         };
         typedef ac_fixed<to_fx_w, to_fx_i, to_fx_s> to_ac_fixed_t;
         typedef ac_int<to_i_w, to_i_s> to_ac_int_t;
      };

      template <int W2, int I2, int E2, ac_q_mode Q2>
      friend class ac_float;

      ac_float()
      {


      }
      ac_float(const ac_float& op)
      {
         m = op.m;
         e = op.e;
      }

      template <int W2, int I2, int E2, ac_q_mode Q2>
      ac_float(const ac_float<W2, I2, E2, Q2> & op, bool assert_on_overflow = false, bool assert_on_rounding = false)
      {
         typedef ac_float<W2, I2, E2, Q2> fl2_t;
         enum
         {
            ST2 = S | S2,
            WT2 = W2 + (S2 == 0 && S != 0 ? 1 : 0),
            IT2 = I2 + (S2 == 0 && S != 0 ? 1 : 0),
            RND = (Q != AC_TRN) && (Q != AC_TRN_ZERO) && (WT2 > W),
            MAX_EXP2 = fl2_t::MAX_EXP,
            MIN_EXP2 = fl2_t::MIN_EXP,
            I_DIFF = IT2 - I,
            MAX_EXP_T = MAX_EXP2 + I_DIFF + RND,
            MIN_EXP_T = MIN_EXP2 + I_DIFF,
            MAX_EXP_T_P = MAX_EXP_T < 0 ? ~MAX_EXP_T : MAX_EXP_T,
            MIN_EXP_T_P = MIN_EXP_T < 0 ? ~MIN_EXP_T : MIN_EXP_T,
            WC_EXP_T = ((MAX_EXP_T_P) > (MIN_EXP_T_P) ? (MAX_EXP_T_P) : (MIN_EXP_T_P)),
            ET = ac::template nbits<WC_EXP_T>::val + 1
         };

         typedef ac_fixed<WT2, IT2, ST2> fx2_t;
         typedef ac_fixed<WT2, I, S> fx_t;

         fx2_t m2 = op.m;
         fx_t t;
         t.set_slc(0, m2.template slc<fx_t::width>(0));
         ac_fixed<W + RND, I + RND, S, Q> m_1 = t;
         bool rnd_ovfl = false;
         if(RND)
         {
            rnd_ovfl = !m_1[W] && m_1[W - 1];
            m_1[W - 1] = m_1[W - 1] && !rnd_ovfl;
            m_1[W - 2] = m_1[W - 2] || rnd_ovfl;
         }
         m.set_slc(0, m_1.template slc<W>(0));
         if(fx_t::width > W && assert_on_rounding)
            ;
         ac_int<ET, true> exp = !m ? ac_int<ET, true>(0) : ac_int<ET, true>(op.e + I_DIFF + (RND & rnd_ovfl));
         adjust(exp, false, assert_on_overflow);
      }

      ac_float(const ac_fixed<W, I, S>& m2, const ac_int<E, true>& e2, bool normalize = true)
      {
         m = m2;
         if(E)
         {
            if(!m)
               e = 0;
            else
            {
               e = e2;
               if(normalize)
                  m.normalize(e);
            }
         }
      }

      template <int WFX, int IFX, bool SFX, int E2>
      ac_float(const ac_fixed<WFX, IFX, SFX>& m2, const ac_int<E2, true>& e2, bool normalize = true)
      {
         enum
         {
            WF2 = WFX + !SFX,
            IF2 = IFX + !SFX
         };
         ac_float<WF2, IF2, E2> f(ac_fixed<WF2, IF2, true>(m2), e2, normalize);
         *this = f;
      }

      template <int WFX, int IFX, bool SFX, ac_q_mode QFX, ac_o_mode OFX>
      ac_float(const ac_fixed<WFX, IFX, SFX, QFX, OFX>& op, bool normalize = true)
      {
         enum
         {
            U2S = !SFX,
            WT2 = WFX + U2S,
            IT2 = IFX + U2S,
            RND = (QFX != AC_TRN) && (QFX != AC_TRN_ZERO) && (WT2 > W),
            I_DIFF = IT2 - I,
            MAX_EXP_T = -(I_DIFF + RND),
            MIN_EXP_T = ((MIN_EXP - I_DIFF) > (-WT2 + 1) ? (MIN_EXP - I_DIFF) : (-WT2 + 1)),
            MAX_EXP_T_P = MAX_EXP_T < 0 ? ~MAX_EXP_T : MAX_EXP_T,
            MIN_EXP_T_P = MIN_EXP_T < 0 ? ~MIN_EXP_T : MIN_EXP_T,
            WC_EXP_T = ((MAX_EXP_T_P) > (MIN_EXP_T_P) ? (MAX_EXP_T_P) : (MIN_EXP_T_P)),
            ET = ac::template nbits<WC_EXP_T>::val + 1
         };
         ac_float<WT2, IT2, ET> f(op, ac_int<ET, true>(0), normalize);
         *this = f;
      }

      template <int WI, bool SI>
      ac_float(const ac_int<WI, SI>& op)
      {
         *this = ac_fixed<WI, WI, SI>(op);
      }

      __attribute__((always_inline)) inline ac_float(bool b)
      {
         *this = (ac_int<1, false>)b;
      }
      __attribute__((always_inline)) inline ac_float(char b)
      {
         *this = (ac_int<8, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(signed char b)
      {
         *this = (ac_int<8, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(unsigned char b)
      {
         *this = (ac_int<8, false>)b;
      }
      __attribute__((always_inline)) inline ac_float(signed short b)
      {
         *this = (ac_int<16, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(unsigned short b)
      {
         *this = (ac_int<16, false>)b;
      }
      __attribute__((always_inline)) inline ac_float(signed int b)
      {
         *this = (ac_int<32, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(unsigned int b)
      {
         *this = (ac_int<32, false>)b;
      }
      __attribute__((always_inline)) inline ac_float(signed long b)
      {
         *this = (ac_int<ac_private::long_w, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(unsigned long b)
      {
         *this = (ac_int<ac_private::long_w, false>)b;
      }
      __attribute__((always_inline)) inline ac_float(Slong b)
      {
         *this = (ac_int<64, true>)b;
      }
      __attribute__((always_inline)) inline ac_float(Ulong b)
      {
         *this = (ac_int<64, false>)b;
      }


      __attribute__((always_inline)) inline typename rt_unary::to_ac_fixed_t to_ac_fixed() const
      {
         typename rt_unary::to_ac_fixed_t r = m;
         r <<= e;
         return r;
      }
      __attribute__((always_inline)) inline typename rt_unary::to_ac_int_t to_ac_int() const
      {
         return to_ac_fixed().to_ac_int();
      }


      __attribute__((always_inline)) inline int to_int() const
      {
         return to_ac_int().to_int();
      }
      __attribute__((always_inline)) inline unsigned to_uint() const
      {
         return to_ac_int().to_uint();
      }
      __attribute__((always_inline)) inline long to_long() const
      {
         return (signed long)to_ac_int().to_int64();
      }
      __attribute__((always_inline)) inline unsigned long to_ulong() const
      {
         return (unsigned long)to_ac_int().to_uint64();
      }
      __attribute__((always_inline)) inline Slong to_int64() const
      {
         return to_ac_int().to_int64();
      }
      __attribute__((always_inline)) inline Ulong to_uint64() const
      {
         return to_ac_int().to_uint64();
      }
      __attribute__((always_inline)) inline float to_float() const
      {
         return ldexpf(m.to_double(), exp());
      }
      __attribute__((always_inline)) inline double to_double() const
      {
         return ldexp(m.to_double(), exp());
      }

      const ac_fixed<W, I, S> mantissa() const
      {
         return m;
      }
      const ac_int<E, true> exp() const
      {
         return e;
      }
      bool normalize()
      {
         bool normalized = operator!() || !S && m[W - 1] || S && (m[W - 1] ^ m[W - 2]);
         if(E && !normalized)
            normalized = m.normalize(e);
         return normalized;
      }

      template <int ET>
      void adjust(ac_int<ET, true> new_e, bool normalize, bool assert_on_overflow)
      {
         if(E >= ET)
         {
            e = new_e;
            if(E && normalize)
               m.normalize(e);
         }
         else
         {
            ac_int<E, false> offset = 0;
            offset[E - 1] = 1;
            ac_int<ET + 1, true> e_s = new_e + offset;
            if(e_s < 0)
            {
               m >>= (MIN_EXP - new_e);
               e = MIN_EXP;
            }
            else
            {


               ac_int<ET, false> e_u = e_s;
               if(ET && normalize)
                  m.normalize(e_u);
               e_u -= offset;
               if(e_u[ET - 1] | !(e_u >> (E - 1)))
                  e = e_u;
               else
               {
                  e = MAX_EXP;
                  m = m < 0 ? value<AC_VAL_MIN>(m) : value<AC_VAL_MAX>(m);
                  if(assert_on_overflow)
                     ;
               }
            }
         }
      }

      ac_float(double d, bool assert_on_overflow = false, bool assert_on_rounding = false)
      {
         enum
         {
            I_EXT = ((I) > (1) ? (I) : (1)),
            W_EXT = ac_private::ac_float_cdouble_t::width + I_EXT - 1,
         };
         ac_private::ac_float_cdouble_t t = ac_private::double_to_ac_float(d);
         ac_float r(t, assert_on_overflow, assert_on_rounding);
         *this = r;
      }

      ac_float(float f, bool assert_on_overflow = false, bool assert_on_rounding = false)
      {
         enum
         {
            I_EXT = ((I) > (1) ? (I) : (1)),
            W_EXT = ac_private::ac_float_cfloat_t::width + I_EXT - 1,
         };
         ac_private::ac_float_cfloat_t t = ac_private::float_to_ac_float(f);
         ac_float r(t, assert_on_overflow, assert_on_rounding);
         *this = r;
      }

      template <int W2, int I2, int E2, ac_q_mode Q2>
      typename rt<W2, I2, E2>::mult operator*(const ac_float<W2, I2, E2, Q2> & op2) const
      {
         typename rt<W2, I2, E2>::mult r(m * op2.m, exp() + op2.exp(), false);
         return r;
      }

      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool compare(const ac_float<W2, I2, E2, Q2> & op2, bool* gt) const
      {
         typedef ac_fixed<W2, I, S2> fx2_t;
         typedef typename ac_fixed<W, I, S>::template rt_T<fx2_t>::logic fx_t;
         typedef ac_fixed<fx_t::width, fx_t::i_width, false> fxu_t;

         fx2_t op2_m_0;
         op2_m_0.set_slc(0, op2.m.template slc<W2>(0));

         fx_t op1_m = m;
         fx_t op2_m = op2_m_0;
         int e_dif = exp() - op2.exp() + I - I2;
         bool op2_m_neg = op2_m[fx_t::width - 1];
         fx_t out_bits = op2_m ^ ((op2_m_neg & e_dif < 0) ? ~fx_t(0) : fx_t(0));
         out_bits &= ~(fxu_t(~fxu_t(0)) << e_dif);
         op2_m >>= e_dif;
         bool overflow = e_dif < 0 & !!out_bits | op2_m_neg ^ op2_m[fx_t::width - 1];

         *gt = overflow & op2_m_neg | !overflow & op1_m > op2_m;
         bool eq = op1_m == op2_m & !overflow & !out_bits;
         return eq;
      }

      template <int W2, int I2, int E2, ac_q_mode Q2, int WR, int IR, int ER, ac_q_mode QR>
      void plus_minus(const ac_float<W2, I2, E2, Q2> & op2, ac_float<WR, IR, ER, QR> & r, bool sub = false) const
      {
         typedef ac_float<WR, IR, ER, QR> r_type;
         enum
         {
            IT = ((I) > (I2) ? (I) : (I2))
         };
         typedef ac_fixed<W, IT, S> fx1_t;
         typedef ac_fixed<W2, IT, S2> fx2_t;
         typedef typename fx1_t::template rt_T<ac_fixed<WR, IT, SR>>::logic fx1t_t;
         typedef typename fx2_t::template rt_T<ac_fixed<WR, IT, SR>>::logic fx2t_t;
         typedef typename fx1t_t::template rt_T<fx2t_t>::plus mt_t;
         typedef ac_fixed<mt_t::width + 1, mt_t::i_width, SR> t1_t;
         typedef ac_fixed<mt_t::width + 2, mt_t::i_width, SR> t2_t;
         typedef ac_fixed<t2_t::width, IR, SR> r1_t;

         enum
         {
            MAX_EXP2 = ac_float<W2, I2, E2, Q2>::MAX_EXP,
            MIN_EXP2 = ac_float<W2, I2, E2, Q2>::MIN_EXP,
            I_DIFF = mt_t::i_width - IR,
            MAX_EXP_T = ((MAX_EXP) > (MAX_EXP2) ? (MAX_EXP) : (MAX_EXP2)) + I_DIFF,
            MIN_EXP_T = ((MIN_EXP) < (MIN_EXP2) ? (MIN_EXP) : (MIN_EXP2)) + I_DIFF,
            MAX_EXP_T_P = MAX_EXP_T < 0 ? ~MAX_EXP_T : MAX_EXP_T,
            MIN_EXP_T_P = MIN_EXP_T < 0 ? ~MIN_EXP_T : MIN_EXP_T,
            WC_EXP_T = ((MAX_EXP_T_P) > (MIN_EXP_T_P) ? (MAX_EXP_T_P) : (MIN_EXP_T_P)),
            ET = ac::template nbits<WC_EXP_T>::val + 1
         };

         ac_fixed<mt_t::width, I + 1, mt_t::sign> op1_m_0 = m;
         mt_t op1_m = 0;
         op1_m.set_slc(0, op1_m_0.template slc<mt_t::width>(0));
         int op1_e = exp() + I - IT + (SR & !S);

         ac_fixed<mt_t::width, I2 + 1, mt_t::sign> op2_m_0 = op2.m;
         mt_t op2_m = 0;
         op2_m.set_slc(0, op2_m_0.template slc<mt_t::width>(0));
         if(sub)
            op2_m = -op2_m;
         int op2_e = op2.exp() + I2 - IT + (SR & !S2);

         bool op1_zero = operator!();
         bool op2_zero = !op2;
         int e_dif = op1_e - op2_e;
         bool e1_lt_e2 = e_dif < 0;
         e_dif = (op1_zero | op2_zero) ? 0 : e1_lt_e2 ? -e_dif : e_dif;
         mt_t op_sl = e1_lt_e2 ? op1_m : op2_m;

         mt_t sticky_bits = op_sl;
         sticky_bits &= ~((~t1_t(0)) << e_dif);
         bool sticky_bit = !!sticky_bits;
         bool msb_shifted_out = (bool)t1_t(op_sl).template slc<1>(e_dif);
         op_sl >>= e_dif;
         op1_m = e1_lt_e2 ? op_sl : op1_m;
         op2_m = e1_lt_e2 ? op2_m : op_sl;

         t1_t t1 = op1_m;
         t1 += op2_m;
         t1[0] = msb_shifted_out;

         bool shift_r_1 = false;
         sticky_bit |= shift_r_1 & t1[0];
         t1 >>= shift_r_1;
         t2_t t2 = t1;
         t2[0] = sticky_bit;
         r1_t r1;
         r1.set_slc(0, t2.template slc<t2_t::width>(0));
         r_type r_t;
         r_t.m = (ac_fixed<WR, IR, SR, QR>)r1;
         ac_int<ET, true> r_e = op1_zero ? op2_e : (op2_zero ? op1_e : ((op1_e) > (op2_e) ? (op1_e) : (op2_e)));
         r_e = ac_int<1, true>(!op1_zero | !op2_zero) & (r_e + shift_r_1 + I_DIFF);
         r_t.adjust(r_e, true, false);
         r.m = r_t.m;
         r.e = r_t.e;
      }

      template <int W1, int I1, int E1, ac_q_mode Q1, int W2, int I2, int E2, ac_q_mode Q2>
      ac_float add(const ac_float<W1, I1, E1, Q1> & op1, const ac_float<W2, I2, E2, Q2> & op2)
      {
         op1.plus_minus(op2, *this);
         return *this;
      }

      template <int W1, int I1, int E1, ac_q_mode Q1, int W2, int I2, int E2, ac_q_mode Q2>
      ac_float sub(const ac_float<W1, I1, E1, Q1> & op1, const ac_float<W2, I2, E2, Q2> & op2)
      {
         op1.plus_minus(op2, *this, true);
         return *this;
      }

      typename rt_unary::neg abs() const
      {
         typedef typename rt_unary::neg r_t;
         r_t r;
         r.m = is_neg() ? -m : r_t::mant_t(m);
         r.e = e;
         return r;
      }
# 730 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
      template <int W2, int I2, int E2, ac_q_mode Q2>
      typename rt<W2, I2, E2>::div operator/(const ac_float<W2, I2, E2, Q2> & op2) const
      {
         typename rt<W2, I2, E2>::div r(m / op2.m, exp() - op2.exp());
         return r;
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      ac_float operator+=(const ac_float<W2, I2, E2, Q2> & op2)
      {
         ac_float r;
         plus_minus(op2, r);
         *this = r;
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      ac_float operator-=(const ac_float<W2, I2, E2, Q2> & op2)
      {
         ac_float r;
         plus_minus(op2, r, true);
         *this = r;
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      ac_float operator*=(const ac_float<W2, I2, E2, Q2> & op2)
      {
         *this = *this * op2;
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      ac_float operator/=(const ac_float<W2, I2, E2, Q2> & op2)
      {
         *this = *this / op2;
      }
      ac_float operator+() const
      {
         return *this;
      }
      typename rt_unary::neg operator-() const
      {
         typename rt_unary::neg r;
         r.m = -m;
         r.e = e;
         return r;
      }
      bool operator!() const
      {
         return !m;
      }


      template <int WI, bool SI>
      typename rt_i<WI, SI>::lshift operator<<(const ac_int<WI, SI>& op2) const
      {
         typename rt_i<WI, SI>::lshift r;
         r.m = m;
         r.e = e + op2;
         return r;
      }
      template <int WI, bool SI>
      typename rt_i<WI, SI>::rshift operator>>(const ac_int<WI, SI>& op2) const
      {
         typename rt_i<WI, SI>::rshift r;
         r.m = m;
         r.e = e - op2;
         return r;
      }

      template <int WI, bool SI>
      ac_float& operator<<=(const ac_int<WI, SI>& op2)
      {
         *this = operator<<(op2);
         return *this;
      }
      template <int WI, bool SI>
      ac_float& operator>>=(const ac_int<WI, SI>& op2)
      {
         *this = operator>>(op2);
         return *this;
      }

      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator==(const ac_float<W2, I2, E2, Q2> & f) const
      {
         bool gt;
         return compare(f, &gt);
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator!=(const ac_float<W2, I2, E2, Q2> & f) const
      {
         return !operator==(f);
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator<(const ac_float<W2, I2, E2, Q2> & f) const
      {
         bool gt;
         bool eq = compare(f, &gt);
         return !(eq | gt);
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator>=(const ac_float<W2, I2, E2, Q2> & f) const
      {
         return !operator<(f);
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator>(const ac_float<W2, I2, E2, Q2> & f) const
      {
         bool gt;
         compare(f, &gt);
         return gt;
      }
      template <int W2, int I2, int E2, ac_q_mode Q2>
      bool operator<=(const ac_float<W2, I2, E2, Q2> & f) const
      {
         return !operator>(f);
      }

      __attribute__((always_inline)) inline std::string to_string(ac_base_mode base_rep, bool sign_mag = false, bool hw = true) const
      {

         if(!hw)
         {
            ac_fixed<W, 0, S> mantissa;
            mantissa.set_slc(0, m.template slc<W>(0));
            std::string r = mantissa.to_string(base_rep, sign_mag);
            r += "e2";
            r += (e + I).to_string(base_rep, sign_mag | base_rep == AC_DEC);
            return r;
         }
         else
         {
            std::string r = m.to_string(base_rep, sign_mag);
            if(base_rep != AC_DEC)
               r += "_";
            r += "e2";
            if(base_rep != AC_DEC)
               r += "_";
            if(E)
               r += e.to_string(base_rep, sign_mag | base_rep == AC_DEC);
            else
               r += "0";
            return r;
         }
      }

      __attribute__((always_inline)) inline static std::string type_name()
      {
         const char* tf[] = {"false", "true"};
         const char* q[] = {"AC_TRN", "AC_RND", "AC_TRN_ZERO", "AC_RND_ZERO",
                            "AC_RND_INF", "AC_RND_MIN_INF", "AC_RND_CONV"};
         std::string r = "ac_float<";
         r += ac_int<32, true>(W).to_string(AC_DEC) + ',';
         r += ac_int<32, true>(I).to_string(AC_DEC) + ',';
         r += ac_int<32, true>(E).to_string(AC_DEC) + ',';
         r += tf[S];
         r += ',';
         r += q[Q];
         r += '>';
         return r;
      }

      template <ac_special_val V>
      __attribute__((always_inline)) inline ac_float& set_val()
      {
         m.template set_val<V>();
         if(V == AC_VAL_MIN)
            e.template set_val<AC_VAL_MAX>();
         else if(V == AC_VAL_QUANTUM)
            e.template set_val<AC_VAL_MIN>();
         else
            e.template set_val<V>();
         return *this;
      }
   };

   namespace ac_private
   {
      template <typename T>
      bool ac_fpclassify(T x, bool& inf)
      {
         bool nan = !(x == x);
         if(!nan)
         {
            T d = x - x;
            inf = !(d == d);
         }
         return nan;
      }

      __attribute__((always_inline)) inline ac_float_cdouble_t double_to_ac_float(double d)
      {
         typedef ac_float_cdouble_t r_t;
# 926 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
         r_t::exp_t exp;
         r_t::mant_t mant = ac::frexp_d(d, exp);
         return r_t(mant, exp, false);
      }

      __attribute__((always_inline)) inline ac_float_cfloat_t float_to_ac_float(float f)
      {
         typedef ac_float_cfloat_t r_t;
# 942 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
         r_t::exp_t exp;
         r_t::mant_t mant = ac::frexp_f(f, exp);
         return r_t(mant, exp, false);
      }
   };

   namespace ac
   {
      template <typename T>
      struct ac_float_represent
      {
         typedef typename ac_fixed_represent<T>::type fx_t;
         typedef ac_float<fx_t::width + !fx_t::sign, fx_t::i_width + !fx_t::sign, 1, fx_t::q_mode> type;
      };
      template <>
      struct ac_float_represent<float>
      {
         typedef ac_private::ac_float_cfloat_t type;
      };
      template <>
      struct ac_float_represent<double>
      {
         typedef ac_private::ac_float_cdouble_t type;
      };
   }

   namespace ac_private
   {

      template <int W2, int I2, int E2>
      struct rt_ac_float_T<ac_float<W2, I2, E2> >
      {
         typedef ac_float<W2, I2, E2> fl2_t;
         template <int W, int I, int E>
         struct op1
         {
            typedef ac_float<W, I, E> fl_t;
            typedef typename fl_t::template rt<W2, I2, E2>::mult mult;
            typedef typename fl_t::template rt<W2, I2, E2>::plus plus;
            typedef typename fl_t::template rt<W2, I2, E2>::minus minus;
            typedef typename fl2_t::template rt<W, I, E>::minus minus2;
            typedef typename fl_t::template rt<W2, I2, E2>::logic logic;
            typedef typename fl_t::template rt<W2, I2, E2>::div div;
            typedef typename fl2_t::template rt<W, I, E>::div div2;
         };
      };

      template <int WFX, int IFX, bool SFX>
      struct rt_ac_float_T<ac_fixed<WFX, IFX, SFX>>
      {

         enum
         {
            E2 = 1,
            S2 = true,
            W2 = WFX + !SFX,
            I2 = IFX + !SFX
         };
         typedef ac_float<W2, I2, E2> fl2_t;
         template <int W, int I, int E>
         struct op1
         {
            typedef ac_float<W, I, E> fl_t;
            typedef typename fl_t::template rt<W2, I2, E2>::mult mult;
            typedef typename fl_t::template rt<W2, I2, E2>::plus plus;
            typedef typename fl_t::template rt<W2, I2, E2>::minus minus;
            typedef typename fl2_t::template rt<W, I, E>::minus minus2;
            typedef typename fl_t::template rt<W2, I2, E2>::logic logic;
            typedef typename fl_t::template rt<W2, I2, E2>::div div;
            typedef typename fl2_t::template rt<W, I, E>::div div2;
         };
      };

      template <int WI, bool SI>
      struct rt_ac_float_T<ac_int<WI, SI>>
      {

         enum
         {
            E2 = 1,
            S2 = true,
            I2 = WI + !SI,
            W2 = I2
         };
         typedef ac_float<W2, I2, E2> fl2_t;
         template <int W, int I, int E>
         struct op1
         {
            typedef ac_float<W, I, E> fl_t;
            typedef typename fl_t::template rt<W2, I2, E2>::mult mult;
            typedef typename fl_t::template rt<W2, I2, E2>::plus plus;
            typedef typename fl_t::template rt<W2, I2, E2>::minus minus;
            typedef typename fl2_t::template rt<W, I, E>::minus minus2;
            typedef typename fl_t::template rt<W2, I2, E2>::logic logic;
            typedef typename fl_t::template rt<W2, I2, E2>::div div;
            typedef typename fl2_t::template rt<W, I, E>::div div2;
         };
      };


      template <typename T>
      struct rt_ac_float_T<c_type<T>>
      {

         enum
         {
            SCT = c_type_params<T>::S,
            S2 = true,
            W2 = c_type_params<T>::W + !SCT,
            I2 = c_type_params<T>::I + !SCT,
            E2 = ((1) > (c_type_params<T>::E) ? (1) : (c_type_params<T>::E))
         };
         typedef ac_float<W2, I2, E2> fl2_t;
         template <int W, int I, int E>
         struct op1
         {
            typedef ac_float<W, I, E> fl_t;
            typedef typename fl_t::template rt<W2, I2, E2>::mult mult;
            typedef typename fl_t::template rt<W2, I2, E2>::plus plus;
            typedef typename fl_t::template rt<W2, I2, E2>::minus minus;
            typedef typename fl2_t::template rt<W, I, E>::minus minus2;
            typedef typename fl_t::template rt<W2, I2, E2>::logic logic;
            typedef typename fl_t::template rt<W2, I2, E2>::div div;
            typedef typename fl2_t::template rt<W, I, E>::div div2;
         };
      };
   }
# 1167 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<float>::mult operator *(float c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<float>::mult operator *(const ac_float<W, I, E, Q> & op, float c_op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<float>::plus operator +(float c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<float>::plus operator +(const ac_float<W, I, E, Q> & op, float c_op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<float>::minus operator -(float c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<float>::minus operator -(const ac_float<W, I, E, Q> & op, float c_op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<float>::div operator /(float c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<float>::div operator /(const ac_float<W, I, E, Q> & op, float c_op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(float op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, float op2) { typedef typename ac::template ac_float_represent<float>::type fl2_t; return op.operator /=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<double>::mult operator *(double c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<double>::mult operator *(const ac_float<W, I, E, Q> & op, double c_op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<double>::plus operator +(double c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<double>::plus operator +(const ac_float<W, I, E, Q> & op, double c_op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<double>::minus operator -(double c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<double>::minus operator -(const ac_float<W, I, E, Q> & op, double c_op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<double>::div operator /(double c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<double>::div operator /(const ac_float<W, I, E, Q> & op, double c_op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(double op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, double op2) { typedef typename ac::template ac_float_represent<double>::type fl2_t; return op.operator /=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<bool>::mult operator *(bool c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<bool>::mult operator *(const ac_float<W, I, E, Q> & op, bool c_op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<bool>::plus operator +(bool c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<bool>::plus operator +(const ac_float<W, I, E, Q> & op, bool c_op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<bool>::minus operator -(bool c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<bool>::minus operator -(const ac_float<W, I, E, Q> & op, bool c_op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<bool>::div operator /(bool c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<bool>::div operator /(const ac_float<W, I, E, Q> & op, bool c_op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(bool op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, bool op2) { typedef typename ac::template ac_float_represent<bool>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<bool>::W, ac_private::c_type_params<bool>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, bool i_op) { typedef typename ac::template ac_int_represent<bool>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<bool>::W, ac_private::c_type_params<bool>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, bool i_op) { typedef typename ac::template ac_int_represent<bool>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, bool i_op) { typedef typename ac::template ac_int_represent<bool>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, bool i_op) { typedef typename ac::template ac_int_represent<bool>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<char>::mult operator *(char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<char>::mult operator *(const ac_float<W, I, E, Q> & op, char c_op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<char>::plus operator +(char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<char>::plus operator +(const ac_float<W, I, E, Q> & op, char c_op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<char>::minus operator -(char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<char>::minus operator -(const ac_float<W, I, E, Q> & op, char c_op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<char>::div operator /(char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<char>::div operator /(const ac_float<W, I, E, Q> & op, char c_op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, char op2) { typedef typename ac::template ac_float_represent<char>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<char>::W, ac_private::c_type_params<char>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, char i_op) { typedef typename ac::template ac_int_represent<char>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<char>::W, ac_private::c_type_params<char>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, char i_op) { typedef typename ac::template ac_int_represent<char>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, char i_op) { typedef typename ac::template ac_int_represent<char>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, char i_op) { typedef typename ac::template ac_int_represent<char>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<signed char>::mult operator *(signed char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<signed char>::mult operator *(const ac_float<W, I, E, Q> & op, signed char c_op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<signed char>::plus operator +(signed char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<signed char>::plus operator +(const ac_float<W, I, E, Q> & op, signed char c_op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<signed char>::minus operator -(signed char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<signed char>::minus operator -(const ac_float<W, I, E, Q> & op, signed char c_op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<signed char>::div operator /(signed char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<signed char>::div operator /(const ac_float<W, I, E, Q> & op, signed char c_op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(signed char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, signed char op2) { typedef typename ac::template ac_float_represent<signed char>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<signed char>::W, ac_private::c_type_params<signed char>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, signed char i_op) { typedef typename ac::template ac_int_represent<signed char>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<signed char>::W, ac_private::c_type_params<signed char>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, signed char i_op) { typedef typename ac::template ac_int_represent<signed char>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, signed char i_op) { typedef typename ac::template ac_int_represent<signed char>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, signed char i_op) { typedef typename ac::template ac_int_represent<signed char>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned char>::mult operator *(unsigned char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned char>::mult operator *(const ac_float<W, I, E, Q> & op, unsigned char c_op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned char>::plus operator +(unsigned char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned char>::plus operator +(const ac_float<W, I, E, Q> & op, unsigned char c_op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned char>::minus operator -(unsigned char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned char>::minus operator -(const ac_float<W, I, E, Q> & op, unsigned char c_op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned char>::div operator /(unsigned char c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned char>::div operator /(const ac_float<W, I, E, Q> & op, unsigned char c_op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(unsigned char op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, unsigned char op2) { typedef typename ac::template ac_float_represent<unsigned char>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned char>::W, ac_private::c_type_params<unsigned char>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, unsigned char i_op) { typedef typename ac::template ac_int_represent<unsigned char>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned char>::W, ac_private::c_type_params<unsigned char>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, unsigned char i_op) { typedef typename ac::template ac_int_represent<unsigned char>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, unsigned char i_op) { typedef typename ac::template ac_int_represent<unsigned char>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, unsigned char i_op) { typedef typename ac::template ac_int_represent<unsigned char>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<short>::mult operator *(short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<short>::mult operator *(const ac_float<W, I, E, Q> & op, short c_op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<short>::plus operator +(short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<short>::plus operator +(const ac_float<W, I, E, Q> & op, short c_op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<short>::minus operator -(short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<short>::minus operator -(const ac_float<W, I, E, Q> & op, short c_op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<short>::div operator /(short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<short>::div operator /(const ac_float<W, I, E, Q> & op, short c_op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, short op2) { typedef typename ac::template ac_float_represent<short>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<short>::W, ac_private::c_type_params<short>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, short i_op) { typedef typename ac::template ac_int_represent<short>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<short>::W, ac_private::c_type_params<short>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, short i_op) { typedef typename ac::template ac_int_represent<short>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, short i_op) { typedef typename ac::template ac_int_represent<short>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, short i_op) { typedef typename ac::template ac_int_represent<short>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned short>::mult operator *(unsigned short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned short>::mult operator *(const ac_float<W, I, E, Q> & op, unsigned short c_op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned short>::plus operator +(unsigned short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned short>::plus operator +(const ac_float<W, I, E, Q> & op, unsigned short c_op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned short>::minus operator -(unsigned short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned short>::minus operator -(const ac_float<W, I, E, Q> & op, unsigned short c_op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned short>::div operator /(unsigned short c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned short>::div operator /(const ac_float<W, I, E, Q> & op, unsigned short c_op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(unsigned short op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, unsigned short op2) { typedef typename ac::template ac_float_represent<unsigned short>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned short>::W, ac_private::c_type_params<unsigned short>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, unsigned short i_op) { typedef typename ac::template ac_int_represent<unsigned short>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned short>::W, ac_private::c_type_params<unsigned short>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, unsigned short i_op) { typedef typename ac::template ac_int_represent<unsigned short>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, unsigned short i_op) { typedef typename ac::template ac_int_represent<unsigned short>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, unsigned short i_op) { typedef typename ac::template ac_int_represent<unsigned short>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<int>::mult operator *(int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<int>::mult operator *(const ac_float<W, I, E, Q> & op, int c_op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<int>::plus operator +(int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<int>::plus operator +(const ac_float<W, I, E, Q> & op, int c_op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<int>::minus operator -(int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<int>::minus operator -(const ac_float<W, I, E, Q> & op, int c_op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<int>::div operator /(int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<int>::div operator /(const ac_float<W, I, E, Q> & op, int c_op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, int op2) { typedef typename ac::template ac_float_represent<int>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<int>::W, ac_private::c_type_params<int>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, int i_op) { typedef typename ac::template ac_int_represent<int>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<int>::W, ac_private::c_type_params<int>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, int i_op) { typedef typename ac::template ac_int_represent<int>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, int i_op) { typedef typename ac::template ac_int_represent<int>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, int i_op) { typedef typename ac::template ac_int_represent<int>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned int>::mult operator *(unsigned int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned int>::mult operator *(const ac_float<W, I, E, Q> & op, unsigned int c_op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned int>::plus operator +(unsigned int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned int>::plus operator +(const ac_float<W, I, E, Q> & op, unsigned int c_op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned int>::minus operator -(unsigned int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned int>::minus operator -(const ac_float<W, I, E, Q> & op, unsigned int c_op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned int>::div operator /(unsigned int c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned int>::div operator /(const ac_float<W, I, E, Q> & op, unsigned int c_op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(unsigned int op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, unsigned int op2) { typedef typename ac::template ac_float_represent<unsigned int>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned int>::W, ac_private::c_type_params<unsigned int>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, unsigned int i_op) { typedef typename ac::template ac_int_represent<unsigned int>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned int>::W, ac_private::c_type_params<unsigned int>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, unsigned int i_op) { typedef typename ac::template ac_int_represent<unsigned int>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, unsigned int i_op) { typedef typename ac::template ac_int_represent<unsigned int>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, unsigned int i_op) { typedef typename ac::template ac_int_represent<unsigned int>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<long>::mult operator *(long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<long>::mult operator *(const ac_float<W, I, E, Q> & op, long c_op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<long>::plus operator +(long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<long>::plus operator +(const ac_float<W, I, E, Q> & op, long c_op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<long>::minus operator -(long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<long>::minus operator -(const ac_float<W, I, E, Q> & op, long c_op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<long>::div operator /(long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<long>::div operator /(const ac_float<W, I, E, Q> & op, long c_op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, long op2) { typedef typename ac::template ac_float_represent<long>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<long>::W, ac_private::c_type_params<long>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, long i_op) { typedef typename ac::template ac_int_represent<long>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<long>::W, ac_private::c_type_params<long>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, long i_op) { typedef typename ac::template ac_int_represent<long>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, long i_op) { typedef typename ac::template ac_int_represent<long>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, long i_op) { typedef typename ac::template ac_int_represent<long>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned long>::mult operator *(unsigned long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned long>::mult operator *(const ac_float<W, I, E, Q> & op, unsigned long c_op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned long>::plus operator +(unsigned long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned long>::plus operator +(const ac_float<W, I, E, Q> & op, unsigned long c_op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned long>::minus operator -(unsigned long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned long>::minus operator -(const ac_float<W, I, E, Q> & op, unsigned long c_op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<unsigned long>::div operator /(unsigned long c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<unsigned long>::div operator /(const ac_float<W, I, E, Q> & op, unsigned long c_op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(unsigned long op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, unsigned long op2) { typedef typename ac::template ac_float_represent<unsigned long>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned long>::W, ac_private::c_type_params<unsigned long>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, unsigned long i_op) { typedef typename ac::template ac_int_represent<unsigned long>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<unsigned long>::W, ac_private::c_type_params<unsigned long>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, unsigned long i_op) { typedef typename ac::template ac_int_represent<unsigned long>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, unsigned long i_op) { typedef typename ac::template ac_int_represent<unsigned long>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, unsigned long i_op) { typedef typename ac::template ac_int_represent<unsigned long>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Slong>::mult operator *(Slong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Slong>::mult operator *(const ac_float<W, I, E, Q> & op, Slong c_op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Slong>::plus operator +(Slong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Slong>::plus operator +(const ac_float<W, I, E, Q> & op, Slong c_op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Slong>::minus operator -(Slong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Slong>::minus operator -(const ac_float<W, I, E, Q> & op, Slong c_op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Slong>::div operator /(Slong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Slong>::div operator /(const ac_float<W, I, E, Q> & op, Slong c_op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(Slong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, Slong op2) { typedef typename ac::template ac_float_represent<Slong>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<Slong>::W, ac_private::c_type_params<Slong>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, Slong i_op) { typedef typename ac::template ac_int_represent<Slong>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<Slong>::W, ac_private::c_type_params<Slong>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, Slong i_op) { typedef typename ac::template ac_int_represent<Slong>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, Slong i_op) { typedef typename ac::template ac_int_represent<Slong>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, Slong i_op) { typedef typename ac::template ac_int_represent<Slong>::type i_t; return op.operator <<=(i_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Ulong>::mult operator *(Ulong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(c_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Ulong>::mult operator *(const ac_float<W, I, E, Q> & op, Ulong c_op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator *(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Ulong>::plus operator +(Ulong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(c_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Ulong>::plus operator +(const ac_float<W, I, E, Q> & op, Ulong c_op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator +(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Ulong>::minus operator -(Ulong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(c_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Ulong>::minus operator -(const ac_float<W, I, E, Q> & op, Ulong c_op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator -(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<Ulong>::div operator /(Ulong c_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(c_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T<Ulong>::div operator /(const ac_float<W, I, E, Q> & op, Ulong c_op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator /(fl2_t(c_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator ==(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator ==(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator !=(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator !=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator >(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator >=(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator >=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator <(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline bool operator <=(Ulong op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return fl2_t(op2).operator <=(op); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator +=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator -=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator *=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, Ulong op2) { typedef typename ac::template ac_float_represent<Ulong>::type fl2_t; return op.operator /=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<Ulong>::W, ac_private::c_type_params<Ulong>::S>::rshift operator >>(const ac_float<W, I, E, Q> & op, Ulong i_op) { typedef typename ac::template ac_int_represent<Ulong>::type i_t; return op.operator >>(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_i<ac_private::c_type_params<Ulong>::W, ac_private::c_type_params<Ulong>::S>::lshift operator <<(const ac_float<W, I, E, Q> & op, Ulong i_op) { typedef typename ac::template ac_int_represent<Ulong>::type i_t; return op.operator <<(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator >>=(ac_float<W, I, E, Q> & op, Ulong i_op) { typedef typename ac::template ac_int_represent<Ulong>::type i_t; return op.operator >>=(i_t(i_op)); } template <int W, int I, int E, ac_q_mode Q> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator <<=(ac_float<W, I, E, Q> & op, Ulong i_op) { typedef typename ac::template ac_int_represent<Ulong>::type i_t; return op.operator <<=(i_t(i_op)); }
# 1234 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::mult operator *(const ac_int<WI, SI>& i_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(i_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::mult operator *(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& i_op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator *(fl2_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::plus operator +(const ac_int<WI, SI>& i_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(i_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::plus operator +(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& i_op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator +(fl2_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::minus operator -(const ac_int<WI, SI>& i_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(i_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::minus operator -(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& i_op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator -(fl2_t(i_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::div operator /(const ac_int<WI, SI>& i_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(i_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_int<WI, SI>>::div operator /(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& i_op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator /(fl2_t(i_op)); }

   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator ==(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator ==(op); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator !=(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator !=(op); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator >(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator >(op); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator >=(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator >=(op); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator <(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator <(op); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline bool operator <=(ac_int<WI, SI>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return fl2_t(op2).operator <=(op); }

   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator +=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator -=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator *=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator /=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WI, bool SI> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator %=(ac_float<W, I, E, Q> & op, const ac_int<WI, SI>& op2) { typedef typename ac::template ac_float_represent<ac_int<WI, SI>>::type fl2_t; return op.operator %=(fl2_t(op2)); }
# 1304 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/../ac_types/include/ac_float.h"
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::mult operator *( const ac_fixed<WF, IF, SF, QF, OF>& f_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(f_op).operator *(op); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::mult operator *( const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& f_op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator *(fl2_t(f_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::plus operator +( const ac_fixed<WF, IF, SF, QF, OF>& f_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(f_op).operator +(op); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::plus operator +( const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& f_op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator +(fl2_t(f_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::minus operator -( const ac_fixed<WF, IF, SF, QF, OF>& f_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(f_op).operator -(op); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::minus operator -( const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& f_op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator -(fl2_t(f_op)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::div operator /( const ac_fixed<WF, IF, SF, QF, OF>& f_op, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(f_op).operator /(op); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline typename ac_float<W, I, E, Q>::template rt_T2<ac_fixed<WF, IF, SF>>::div operator /( const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& f_op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator /(fl2_t(f_op)); }

   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator ==(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator ==(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator ==(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator ==(op); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator !=(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator !=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator !=(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator !=(op); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator >(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator >(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator >(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator >(op); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator >=(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator >=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator >=(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator >=(op); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator <(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator <(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator <(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator <(op); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator <=(const ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator <=(fl2_t(op2)); } template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline bool operator <=(ac_fixed<WF, IF, SF, QF, OF>& op2, const ac_float<W, I, E, Q> & op) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return fl2_t(op2).operator <=(op); }

   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator +=(ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator +=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator -=(ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator -=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator *=(ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator *=(fl2_t(op2)); }
   template <int W, int I, int E, ac_q_mode Q, int WF, int IF, bool SF, ac_q_mode QF, ac_o_mode OF> __attribute__((always_inline)) inline ac_float<W, I, E, Q>& operator /=(ac_float<W, I, E, Q> & op, const ac_fixed<WF, IF, SF, QF, OF>& op2) { typedef typename ac::template ac_float_represent<ac_fixed<WF, IF, SF>>::type fl2_t; return op.operator /=(fl2_t(op2)); }



   template <ac_special_val V, int W, int I, int E, ac_q_mode Q>
   __attribute__((always_inline)) inline ac_float<W, I, E, Q> value(ac_float<W, I, E, Q>)
   {
      ac_float<W, I, E, Q> r;
      return r.template set_val<V>();
   }

   namespace ac
   {

      template <ac_special_val V, int W, int I, int E, ac_q_mode Q>
      __attribute__((always_inline)) inline bool init_array(ac_float<W, I, E, Q> * a, int n)
      {
         ac_float<W, I, E> t = value<V>(*a);
         for(int i = 0; i < n; i++)
            a[i] = t;
         return true;
      }
   }
# 2 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/custom_float_def.h" 2

typedef ac_float<25, 2, 8> custom_float;
# 2 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.cpp" 2
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.h" 1
# 1 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/custom_float_def.h" 1


typedef ac_float<25, 2, 8> custom_float;
# 2 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.h" 2
template<typename input_a_t, typename input_b_t, typename result_t>
void mul(const input_a_t& a, const input_b_t &b, result_t &res)
{
    res = a * b;
}

extern void mul_top(const custom_float &a, const custom_float &b, custom_float &res);
# 3 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.cpp" 2

void mul_top(const custom_float &a, const custom_float &b, custom_float &res)
{
    mul<custom_float, custom_float, custom_float>(a, b, res);
}
#ifndef HLS_FASTSIM
#ifdef __cplusplus
extern "C"
#endif
void apatb_mul_top_ir(const ac_float<25, 2, 8, AC_TRN> &, const ac_float<25, 2, 8, AC_TRN> &, ac_float<25, 2, 8, AC_TRN> &);
#ifdef __cplusplus
extern "C"
#endif
void mul_top_hw_stub(const ac_float<25, 2, 8, AC_TRN> &a, const ac_float<25, 2, 8, AC_TRN> &b, ac_float<25, 2, 8, AC_TRN> &res){
mul_top(a, b, res);
return ;
}
#ifdef __cplusplus
extern "C"
#endif
void apatb_mul_top_sw(const ac_float<25, 2, 8, AC_TRN> &a, const ac_float<25, 2, 8, AC_TRN> &b, ac_float<25, 2, 8, AC_TRN> &res){
apatb_mul_top_ir(a, b, res);
return ;
}
#endif
# 7 "/home/nghielme/PycharmProjects/thesis-project/addmul/mul/mul.cpp"

